ArchiveEntry "Parachute with Declarations".

Functions.
  R g().      /* gravity */
  R pr().     /* parachute drag coefficient */
  R ar().     /* skydiver drag coefficient */
  R m().      /* impact velocity */
  R T().      /* skydiver reaction time */

  R steadyStateSpeed() = (-(g()/pr())^(1/2)).                            /* Steady state speed of an opened parachute */

  R reactionDelaySpeed(R v) = (v - g()*T()).                        /* Speed after a delay equal to the reaction time */

  B parachuteIsClosed(R r) <-> (r=ar()).                                /* Indicates whether the parachute is closed. */

  B dive(R v) <-> (reactionDelaySpeed(v) > steadyStateSpeed()).            /* Indicates whether diving is still safe. */

  B bounds() <-> (                                                                             /* bounds on constants */
      g() > 0 & pr() > ar() & ar() > 0 & T() > 0 &
      m() < steadyStateSpeed()
    ).

  B loopinv() <-> ((x >= 0 & v < 0) & bounds() & v > steadyStateSpeed()). /* conservative: open parachute before getting too fast */

  B initialState() <-> (                                                  /* start in free fall with parachute closed */
    x >= 0 & v < 0 & parachuteIsClosed(r) & v > steadyStateSpeed()
  ).

  B assumptions() <-> (bounds() & initialState()).

  /* A helping QEand */
  B fourwayTransitivity() <-> (\forall a \forall b \forall c \forall d (a>=b&b>=c&c>d->a>d)).
End.

ProgramVariables.
  R x.    /* skydiver altitude */
  R v.    /* skydiver speed (< 0, so lower is faster) */
  R r.    /* skydiver current drag coefficient (depends on parachute open/closed) */
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        ?(dive(v) & parachuteIsClosed(r));
        ++
        r := pr();
      }
      t := 0;
      {x'=v, v'=-g() + r*v^2, t'=1 & t <= T() & x >= 0 & v < 0}
    }*@invariant(loopinv())
  ](x=0 -> v >= m())
End.

Tactic "Proof: Parachute with Declarations".
implyR(1);
loop({`loopinv()`}, 1) <(
  QE,
  QE,
  boxAnd(1); andR(1) <(master, nil); /* prove x>=0 & v<0 is an invariant */
  boxAnd(1); andR(1) <(master, nil); /* prove all constraints on constants are invariants */
  unfold <(
    dC({`g()>0 & pr()>0`}, 1) <(nil, dI(1));
    dC({`v >= old(v) - g()*t`}, 1) <(nil, dI(1));
    dC({`old(v) - g()*t >= reactionDelaySpeed(old(v))`}, 1) <(nil, dW(1); QE({`Mathematica`}));
    dC({`reactionDelaySpeed(old(v)) > steadyStateSpeed()`}, 1) <(nil, dI(1));
    dW(1);
    cut({`fourwayTransitivity()`}) <(nil, cohideR('Rlast); QE({`Mathematica`}));
    allL({`v`}, 'Llast) ; allL({`v_0-g()*t`}, 'Llast) ; allL({`reactionDelaySpeed(v_0)`}, 'Llast) ; allL({`steadyStateSpeed()`}, 'Llast);
    QE({`Mathematica`})
    ,
    dC({`pr()>0&g()>0`}, 1) <(nil, dI(1)); /* avoid singularities in dG */
    dG({`y'=(-1/2*pr()*(v+steadyStateSpeed()))*y`}, {`pr()>0&g()>0&y^2*(v-steadyStateSpeed())=1`}, 1) ;
    dI(1.0); /* Apply dI inside of existential. */
    QE({`Mathematica`})
  )
)
End.

Tactic "Proof: Parachute with Declarations (transformation and abbreviate)".
  implyR(1) ; loop({`loopinv()`}, 1) ; <(
    QE,
    QE,
    boxAnd(1) ; andR(1) ; <(
      master,
      boxAnd(1) ; andR(1) ; <(
        master,
        unfold ; <(
          fullSimplify ; diffInvariant({`v>=old(v)-g()*t`}, 1) ;
            dW(1) ; abbrv({`steadyStateSpeed()`}, {`c`}) ; hideL('L=={`c=-(g()/pr())^(1/2)`}) ; QE({`Mathematica`}),
          diffInvariant({`g()>0&pr()>0`}, 1) ;
            dG({`y' = (-1/2*pr()*(v+steadyStateSpeed()))*y`}, {`g()>0&pr()>0&y^2*(v-steadyStateSpeed())=1`}, 1) ;
            dI(1.0) ; QE({`Mathematica`})
          )
        )
      )
    )
End.

End.

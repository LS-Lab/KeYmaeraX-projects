Theorem "Theorem 1: Static safety".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = (v^2 / (2*b())).            /* The straight-line stopping distance from brake start to full stop. */
  R accelComp(R v) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*v))./* Straight-line distance to compensate acceleration */
  R admissibleSeparation(R v) = (stopDist(v) + accelComp(v)).   /* Separation that allows accelerating on a new curve */

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      {
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        t' = 1 & t <= ep & v >= 0
      }@invariant(t>=0, isWellformedDir(),
         (v'=-b() -> v = old(v) - b()*t),
         (v'=-b() -> (-t * (old(v) - b()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - b()/2*t))),
         (v'=-b() -> (-t * (old(v) - b()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - b()/2*t))),
         (v'=0 -> v = old(v)),
         (v'=0 -> x = old(x)),
         (v'=0 -> y = old(y)),
         (v'=A() -> v = old(v) + A()*t),
         (v'=A() -> (-t * (old(v) + A()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t))),
         (v'=A() -> (-t * (old(v) + A()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t)))
       )
      }
    }*@invariant(loopinv())
  ](x - xo)^2 + (y - yo)^2 > 0
End.

Tactic "Proof Theorem 1: Static safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo)>v_0^2/(2*b())+(A()/b()+1)*(A()/2*t^2+t*v_0)`}, 'L=={`abs(x_0-xo)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo)>v_0^2/(2*b())+(A()/b()+1)*(A()/2*t^2+t*v_0)`}, 'L=={`abs(y_0-yo)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`abs(x-xo_0)>stopDist(v)|abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

Tactic "Proof Theorem 1: Static safety from annotations".
  master
End.

End.

Theorem "Theorem 2: Passive safety".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = (v^2 / (2*b()) + V()*v/b()).
  R accelComp(R v) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*(v+V))).
  R admissibleSeparation(R v) = (stopDist(v) + accelComp(v)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      {
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }@invariant(t>=0, isWellformedDir(),
          (-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()),
          (-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()),
          (v'=-b() -> v = old(v) - b()*t),
          (v'=-b() -> (-t * (old(v) - b()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - b()/2*t))),
          (v'=-b() -> (-t * (old(v) - b()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - b()/2*t))),
          (v'=0 -> v = old(v)),
          (v'=0 -> x = old(x)),
          (v'=0 -> y = old(y)),
          (v'=A() -> v = old(v) + A()*t),
          (v'=A() -> (-t * (old(v) + A()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t))),
          (v'=A() -> (-t * (old(v) + A()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t)))
        )
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 2: Passive safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 3: Passive Friendly Safety".
Functions.
  R ep().      /* time limit for control decisions */
  R tau().     /* time limit for obstacle reaction */
  R b().       /* minimum braking capability of the robot */
  R bo().      /* obstacle brakes */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R friendlyMargin(R v) = ( v^2/(2*bo()) + tau()*v ).
  R stopDist(R v) = (v^2 / (2*b()) + V()*v/b()).
  R accelComp(R v) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*(v+V))).
  R admissibleSeparation(R v) = (stopDist(v) + friendlyMargin(V()) + accelComp(v)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & tau() >= 0
    & bo() > 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (abs(x-xo) > friendlyMargin(V()) | abs(y-yo) > friendlyMargin(V()))
    & vxo^2+vyo^2<=V()^2
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v)+friendlyMargin(V()) | abs(y-yo) > stopDist(v)+friendlyMargin(V()))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R vo.   /* refined obstacle: speed, acceleration, and direction */
  R ao.
  R dxo.
  R dyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V()^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep() & v >= 0
      }
    }*@invariant(loopinv())
  ](  (v>0 -> (x - xo)^2 + (y - yo)^2 > (friendlyMargin(V()))^2)                     /* robot ensures friendly margin */
    & (  0<=vo & vo^2=vxo^2+vyo^2 & dxo*vo=vxo & dyo*vo=vyo                                      /* obstacle can stop */
       & (x - xo)^2 + (y - yo)^2 > (friendlyMargin(V()))^2
       ->
        <{
          ao := *; ?-bo() <= ao & vo + ao*ep() <= V();
          t := 0;
          {xo'=vo*dxo, yo'=vo*dyo, vo'=ao, t'=1 & vo>=0 & t<=ep()}
         }*>((x-xo)^2 + (y-yo)^2 > 0 & vo=0))
  )
End.

Tactic "Proof Theorem 3: Passive Friendly Safety".
  tactic obstacleCanStop as (
    unfold ; cut({`vo=0|dxo^2+dyo^2=1`}) ; <(
      cut({`vo<=V()`}) ; <(
        hideL('L=={`vo^2=vxo^2+vyo^2`}) ; hideL('L=={`vxo^2+vyo^2<=V()^2`});
        con({`(vo=0|dxo^2+dyo^2=1)&bo()>0&ep()>0&(x-xo)^2+(y-yo)^2>(vo^2/(2*bo()))^2&0<=vo&vo<=V()&(v*ep()*bo()>=vo|vo=0)`}, 1); <(
          QE,
          unfold ; existsR({`-bo()`}, 1) ; unfold ; <(
            fullSimplify ; closeTrue
            ,
            solve(1) ; existsR({`min((vo/bo(),ep()))`}, 1) ; abbrv({`min((vo/bo(),ep()))`}, {`minT`}) ; minmax(-10.1) ;
            orL('L=={`vo=0|dxo^2+dyo^2=1`}) ; doall(QE)
            ,
            QE
          )
          ,
          QE
        )
        ,
        hideR(1) ; QE
      ),
      hideR(1) ; QE
    )
  );

  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+fm+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+fm+(A()/b()+1)*(A()/2*ep()^2+ep()*(v_0+V()))`});
    hideR('R=={`abs(y-yo)>stopDist(v)+fm`});
    smartQE; /* needs QE({`Mathematica`}) */
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+fm+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+fm+(A()/b()+1)*(A()/2*ep()^2+ep()*(v_0+V()))`});
    hideR('R=={`abs(x-xo)>stopDist(v)+fm`});
    smartQE; /* needs QE({`Mathematica`}) */
    print({`Proved acc arithmetic`})
  );

  tactic robotAlwaysStops as (
    loop({`loopinv()`}, 1); <(
      print({`Base case...`}); smartQE; print({`Base case done`})
      ,
      print({`Use case...`}); smartQE; print({`Use case done`})
      ,
      print({`Induction step`}); unfold; <(
        print({`Braking branch`});
        abbrv({`(V()^2/(2*bo())+tau()*V())`}, {`fm`});
        cut({`fm>=0`}); <(hideL('L=={`fm=(V()^2/(2*bo())+tau()*V())`}), hideR(1); QE);
        dib; dw; prop; doall(smartQE); print({`Braking branch done`})
        ,
        print({`Stopped branch`});
        abbrv({`(V()^2/(2*bo())+tau()*V())`}, {`fm`});
        cut({`fm>=0`}); <(hideL('L=={`fm=(V()^2/(2*bo())+tau()*V())`}), hideR(1); QE);
        di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
        ,
        print({`Acceleration branch`});
        hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v)+friendlyMargin(V()) | abs(y-yo_0)>stopDist(v)+friendlyMargin(V())`});
        abbrv({`(V()^2/(2*bo())+tau()*V())`}, {`fm`});
        cut({`fm>=0`}); <(hideL('L=={`fm=(V()^2/(2*bo())+tau()*V())`}), hideR(1); QE);
        dia; dw;
        prop; <(
          xAccArith,
          yAccArith
        );
        print({`Acceleration branch done`})
      );
      print({`Induction step done`})
    );
    done;
    print({`Robot done`})
  );

  implyR(1) ; andL('L)* ; boxAnd(1) ; andR(1) ; <(
    robotAlwaysStops
    ,
    MR({`vxo^2+vyo^2<=V()^2`},1); <(
      loop({`vxo^2+vyo^2<=V()^2`}, 1) ; <(
        closeId,
        closeId,
        composeb(1) ; GV(1.1) ; composeb(1) ; GV(1.1) ; master
      )
      ,
      andL('L)* ;
      hideL('L=={`A()>=0`});
      hideL('L=={`b()>0`});
      obstacleCanStop
    )

  )
End.

End.

Theorem "Theorem 4: Passive orientation safety".
Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Gamma().   /* Sensor range in radian */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v)   = ( v^2 / (2*b()) ).
  R stopMargin(R v) = ( stopDist(v) + V()*v/b() ).
  R accelComp(R v)  = ( (A()/b() + 1) * (A()/2 * ep()^2 + ep()*v) ).
  R accelMargin(R v)  = ( accelComp(v) + (A()/b() + 1)*ep()*V() ).
  R admissibleSeparation(R v) = ( stopMargin(v) + accelMargin(v) ).
  R admissibleTurnLength(R v) = ( stopDist(v) + accelComp(v) ).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B isVisible(R) <-> ((.)>0).      /* Indicates whether or not the obstacle is visible for the robot at the decision. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & Gamma() > 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & beta = 0
    & r != 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & r != 0
    & (v>0 -> ( (abs(x-xo) > stopMargin(v) | abs(y-yo) > stopMargin(v))
              | (!isVisible(visDeg) & abs(beta) + stopDist(v)/abs(r) < Gamma() )) )
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
  R beta. /* Angle that the robot traveled since it last chose a new curve */
  R visDeg. /* Indicates the "degree" to which the obstacle is visible to the robot (input to isVisible) */
End.

Problem.
  assumptions() -> [
      {
        {
        /* obstacle control */
        {
          vxo := *;
          vyo := *;
          ?vxo^2+vyo^2 <= V()^2;
        }

        /* robot control */
        {
           /* brake on current curve. If the velocity is zero this just means that the robot remains stopped */
           {a := -b();}
        ++ /* When we are stopped, both translational and rotational acceleration are 0 */
           {?v=0; a := 0; w := 0;}
        ++ /* or choose a new safe curve */
           {a := A();
            beta := 0;
            r :=*; ?r!=0;

            /* measure obstacle position and whether or not it is visible to the robot */
            xo := *; yo := *; visDeg := *;
            ?(isVisible(visDeg) ->
               ( abs(x-xo) > admissibleSeparation(v)
               | abs(y-yo) > admissibleSeparation(v)) );
            ?admissibleTurnLength(v) < Gamma()*abs(r);
            }
        }

        /* Reset the clocks */
        t := 0;
        /* Set w according to physics (rigid body motion) */
        w :=*; ?w*r = v;
        }

        {x' = v * dx, y' = v * dy, dx' = -w * dy, dy' = w * dx, v' = a, w' = a/r, beta'=w,
                      xo' = vxo, yo' = vyo, t' = 1 & (t <= ep & v >= 0)}
      }*
    ] (v > 0 -> ((x - xo)^2 + (y - yo)^2 > 0 | (!isVisible(visDeg) & (abs(beta) < Gamma()))) )
End.

Tactic "Proof Theorem 4: Passive orientation safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1);
    diffInvariant({`w*r=v`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`beta = old(beta) + t/r*(v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`beta = old(beta)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`beta = old(beta) + t/r*(v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    hideR('R=={`abs(y-yo)>stopMargin(v)`});
    hideL('L=={`-t*(v-A()/2*t)<=y-y_0`});
    hideL('L=={`y-y_0<=t*(v-A()/2*t)`});
    hideL('L=={`-t*V()<=yo-yo_0`});
    hideL('L=={`yo-yo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+((A()/b()+1)*(A()/2*t^2+t*v_0)+(A()/b()+1)*t*V())`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    hideR('R=={`abs(x-xo)>stopMargin(v)`});
    hideL('L=={`-t*(v-A()/2*t)<=x-x_0`});
    hideL('L=={`x-x_0<=t*(v-A()/2*t)`});
    hideL('L=={`-t*V()<=xo-xo_0`});
    hideL('L=={`xo-xo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+((A()/b()+1)*(A()/2*t^2+t*v_0)+(A()/b()+1)*t*V())`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop ; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0->((abs(x-xo_0)>stopMargin(v)|abs(y-yo_0)>stopMargin(v))|!isVisible(visDeg_0)&abs(beta_0)+stopDist(v)/abs(r_0) < Gamma())`});
      unfold;
      dia; dw;
      print({`Acceleration arithmetic`});
      implyR(1) ; andL('L)* ; fullSimplify ; implyR(1) ; orR(1) ; orR(1) ;
      implyL('L=={`isVisible(visDeg) -> ( abs(x_0-xo_0) > admissibleSeparation(v_0) | abs(y_0-yo_0) > admissibleSeparation(v_0))`}) ; <(
        hideR('R=={`abs(x-xo)>stopMargin(v)`}) ; hideR('R=={`abs(y-yo)>stopMargin(v)`}) ; andR(1) ; doall(smartQE)
        ,
        print({`Acc Distance`});
        hideL('L=={`admissibleTurnLength(v_0) < Gamma()*abs(r)`}) ;
        hideR('R=={`visDeg<=0 & abs(beta) + stopDist(v)/abs(r) < Gamma()`});
        hideL('L=={`r_0!=0`});
        hideL('L=={`vxo^2+vyo^2<=V()^2`});
        hideL('L=={`dx^2+dy^2=1`});
        hideL('L=={`Gamma()>0`});
        hideL('L=={`beta_0=0`});
        hideL('L=={`w*r=v`});
        hideL('L=={`beta=beta_0+t/r*(v-A()/2*t)`});
        orL('L=={`abs(x_0-xo_0)>admissibleSeparation(v_0) | abs(y_0-yo_0)>admissibleSeparation(v_0)`}); <(
          xAccArith
          ,
          yAccArith
        )
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 5: Passive safety with actual acceleration".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = (v^2 / (2*b()) + V()*v/b()).
  R accelComp(R v, R a) = ((a/b() + 1) * (a/2 * ep()^2 + ep()*(v+V))).
  R admissibleSeparationG(R v, R a) = (stopDist(v) + accelComp(v,a)).
  R admissibleSeparationL(R v, R a) = (-v^2/(2*a)-V*v/a).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := *; ?-b<=a & a<=A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            if (v+a*ep>=0) { ?abs(x-xo) > admissibleSeparationG(v,a) | abs(y-yo) > admissibleSeparationG(v,a); }
            else           { ?abs(x-xo) > admissibleSeparationL(v,a) | abs(y-yo) > admissibleSeparationL(v,a); }
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 5: Passive safety with actual acceleration".
  tactic diall as (
    diffInvariant({`t>=0`}, 'R);
    diffInvariant({`isWellformedDir()`}, 'R);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 'R);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 'R)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 'R);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 'R);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 'R)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 'R);
    diffInvariant({`x = old(x)`}, 'R);
    diffInvariant({`y = old(y)`}, 'R)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + a*t`}, 'R);
    diffInvariant({`-t * (v - a/2*t) <= x - old(x) & x - old(x) <= t * (v - a/2*t)`}, 'R);
    diffInvariant({`-t * (v - a/2*t) <= y - old(y) & y - old(y) <= t * (v - a/2*t)`}, 'R)
  );

  tactic dw as (andL('L)*; dW('R));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    ?(transform({`abs(x_0-xo_0)>stopDist(v_0) + (a/b+1)*(a/2*t^2 + t*(v_0+V))`}, 'L=={`abs(x_0-xo_0)>stopDist(v_0) + (a/b+1)*(a/2*ep^2 + ep*(v_0+V))`}));
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    ?(transform({`abs(y_0-yo_0)>stopDist(v_0) + (a/b+1)*(a/2*t^2 + t*(v_0+V))`}, 'L=={`abs(y_0-yo_0)>stopDist(v_0) + (a/b+1)*(a/2*ep^2 + ep*(v_0+V))`}));
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Free driving non-stopping branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Free driving non-stopping branch done`})
      ,
      print({`Free driving stopping branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Free driving stopping branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 6: Passive safety despite location uncertainty".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Dp().      /* maximum location uncertainty */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = (v^2 / (2*b()) + V()*v/b()).
  R accelComp(R v) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*(v+V())) + Dp()).
  R admissibleSeparation(R v) = (stopDist(v) + accelComp(v)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & Dp() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R mx.   /* robot measured position: x */
  R my.   /* robot measured position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* locate */
        {
          mx := *; my := *;
          ?(mx-x)^2+(my-y)^2 <= Dp()^2;
        }
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(mx-xo) > admissibleSeparation(v)
            | abs(my-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 6: Passive safety despite location uncertainty".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(mx-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))+Dp()`}, 'L=={`abs(mx-xo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(my-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))+Dp()`}, 'L=={`abs(my-yo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 7: Passive safety despite actuator perturbation".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Da().      /* maximum actuator perturbation 0< Da <= 1 (robot will not loose brakes entirely) */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = ( v^2 / (2*(b()*Da())) + V()*v/(b()*Da()) ).
  R accelComp(R v) = ( (A()/(b()*Da()) + 1) * (A()/2 * ep()^2 + ep()*(v+V())) ).
  R admissibleSeparation(R v) = (stopDist(v) + accelComp(v)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & 0 < Da() & Da() <= 1
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot control choice: translational acceleration */
  R da.   /* robot actuator disturbance */
  R acc.  /* robot actual translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
        /* actuator perturbation */
        {
          da := *; ?(Da<=da & da<=1); acc := da*a;
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = acc,      /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = acc/r, /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 7: Passive safety despite actuator perturbation".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v <= old(v) - (b()*Da())*t`}, 1);
    diffInvariant({`-t * (old(v) - (b()*Da())/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - (b()*Da())/2*t)`}, 1);
    diffInvariant({`-t * (old(v) - (b()*Da())/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - (b()*Da())/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v <= old(v) + A()*t`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t)`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*(b()*Da()))+V()*v_0/(b()*Da())+(A()/(b()*Da())+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    abbrv({`b*Da()`},{`actB`}); cut({`actB>0`}); <(hideL('L=={`actB=b*Da()`}), hideR(1); smartQE);
    hideL('L=={`t<=ep()`});
    hideL('L=={`b()>0`});
    hideL('L=={`ep()>0`});
    hideL('L=={`0<Da()`});
    hideL('L=={`Da()<=1`});
    hideL('L=={`Da()<=da`});
    hideL('L=={`da<=1`});
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=y-y_0`});
    hideL('L=={`y-y_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=yo-yo_0`});
    hideL('L=={`yo-yo_0<=t*V()`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*(b()*Da()))+V()*v_0/(b()*Da())+(A()/(b()*Da())+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    abbrv({`b*Da()`},{`actB`}); cut({`actB>0`}); <(hideL('L=={`actB=b*Da()`}), hideR(1); smartQE);
    hideL('L=={`t<=ep()`});
    hideL('L=={`b()>0`});
    hideL('L=={`ep()>0`});
    hideL('L=={`0<Da()`});
    hideL('L=={`Da()<=1`});
    hideL('L=={`Da()<=da`});
    hideL('L=={`da<=1`});
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=x-x_0`});
    hideL('L=={`x-x_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=xo-xo_0`});
    hideL('L=={`xo-xo_0<=t*V()`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; abbrv({`b*Da()`},{`actB`}); cut({`actB>0`}); <(hideL('L=={`actB=b*Da()`}), hideR(1); smartQE); prop; doall(print({`Braking QE`}); smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 8: Passive safety despite velocity uncertainty".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Dv().      /* maximum velocity uncertainty */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = ( v^2 / (2*b()) + V()*v/b() ).
  R accelComp(R v) = ( (A()/b() + 1) * (A()/2 * ep()^2 + ep()*(v+V())) ).
  R admissibleSeparation(R v) = (stopDist(v) + accelComp(v)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & Dv() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R mv.   /* robot measured velocity */
  R a.    /* robot control choice: translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* sense */
        {
          mv := *; ?0<=mv & v-Dv()<=mv & mv<=v+Dv();
        }
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(mv+Dv())
            | abs(y-yo) > admissibleSeparation(mv+Dv());
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 8: Passive safety despite velocity uncertainty".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v <= old(v) - b()*t`}, 1);
    diffInvariant({`-t * (old(v) - b()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - b()/2*t)`}, 1);
    diffInvariant({`-t * (old(v) - b()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v <= old(v) + A()*t`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t)`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=y-y_0`});
    hideL('L=={`y-y_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=yo-yo_0`});
    hideL('L=={`yo-yo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(mv+Dv())`});
    hideL('L=={`t<=ep()`});
    hideL('L=={`ep()>0`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=x-x_0`});
    hideL('L=={`x-x_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=xo-xo_0`});
    hideL('L=={`xo-xo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(mv+Dv())`});
    hideL('L=={`t<=ep()`});
    hideL('L=={`ep()>0`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(print({`Braking QE`}); smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 9: Passive safety for asynchronous controllers".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = (v^2 / (2*b()) + V()*v/b()).
  R accelComp(R v) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*(v+V))).
  R admissibleSeparation(R v) = (stopDist(v) + accelComp(v)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).

  /* todo invariant lookup for inner fails */
  B innerloopinv() <-> (
    0<=t & t<=ep()
    & v >= 0
    & isWellformedDir()
    & -t*V() <= xo - old(xo) & xo - old(xo) <= t*V() /* todo: old(.) support in loop invariants */
    & -t*V() <= yo - old(yo) & yo - old(yo) <= t*V()
    & -t * (v - a/2*t) <= x - old(x) & x - old(x) <= t * (v - a/2*t)
    & -t * (v - a/2*t) <= y - old(y) & y - old(y) <= t * (v - a/2*t)
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        };
        /* dynamics */
        { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
          dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
          xo' = vxo, yo' = vyo,                    /* obstacle moves */
          t' = 1 & t <= ep & v >= 0
        }
      }*@invariant(innerloopinv())
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 9: Passive safety for asynchronous controllers".
  tactic diall as (
    diffInvariant({`t>=old(t)`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-(t-old(t))*V() <= xo - old(xo) & xo - old(xo) <= (t-old(t))*V()`}, 1);
    diffInvariant({`-(t-old(t))*V() <= yo - old(yo) & yo - old(yo) <= (t-old(t))*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*(t-old(t))`}, 1);
    diffInvariant({`-(t-old(t)) * (v + b()/2*(t-old(t))) <= x - old(x) & x - old(x) <= (t-old(t)) * (v + b()/2*(t-old(t)))`}, 1);
    diffInvariant({`-(t-old(t)) * (v + b()/2*(t-old(t))) <= y - old(y) & y - old(y) <= (t-old(t)) * (v + b()/2*(t-old(t)))`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*(t-old(t))`}, 1);
    diffInvariant({`-(t-old(t)) * (v - A()/2*(t-old(t))) <= x - old(x) & x - old(x) <= (t-old(t)) * (v - A()/2*(t-old(t)))`}, 1);
    diffInvariant({`-(t-old(t)) * (v - A()/2*(t-old(t))) <= y - old(y) & y - old(y) <= (t-old(t)) * (v - A()/2*(t-old(t)))`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic ghosts as (
    discreteGhost({`v`}, 1) ; discreteGhost({`x`}, 1) ; discreteGhost({`y`}, 1) ; discreteGhost({`xo`}, 1) ;
    discreteGhost({`yo`}, 1) ; (assignEquality(1) ; allR2L('Llast))*5
  );

  tactic innerUseCase as (
    andR(1) ; <(
    prop,
    andR(1) ; <(
      prop,
      implyR(1) ; orR(1) ; implyL('L=={`v_0>0 -> abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)`}) ; <(
        QE,
        orL('L=={`abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)`}) ; <(
          hideR('R=={`abs(y-yo) > stopDist(v)`}); smartQE,
          hideR('R=={`abs(x-xo) > stopDist(v)`}); smartQE
          )
        )
      )
    )
  );

  tactic brakingInnerLoop as (
    ghosts;
    loop({`0<=t&t<=ep()&v>=0&dx^2+dy^2=1&v=v_0-b()*t&-t*V()<=xo-xo_0&xo-xo_0<=t*V()&-t*V()<=yo-yo_0&yo-yo_0<=t*V()&-t*(v+b()/2*t)<=x-x_0&x-x_0<=t*(v+b()/2*t)&-t*(v+b()/2*t)<=y-y_0&y-y_0<=t*(v+b()/2*t)`}, 1) ; <(
      QE,
      innerUseCase,
      unfold;
      hideL('L=={`v_0>0 -> abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)`});
      dib; dw; unfold; doall(smartQE)
    )
  );

  tactic stoppedInnerLoop as (
    ghosts;
    loop({`0<=t&t<=ep()&v>=0&dx^2+dy^2=1&v=v_0&-t*V()<=xo-xo_0&xo-xo_0<=t*V()&-t*V()<=yo-yo_0&yo-yo_0<=t*V()&x=x_0&y=y_0`}, 1) ; <(
      QE,
      innerUseCase,
      unfold;
      hideL('L=={`v_0>0 -> abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)`});
      di0; dw; unfold; doall(smartQE)
    )
  );

  tactic accInnerLoop as (
    hideL('L=={`v>0 -> abs(x-xo_0) > stopDist(v) | abs(y-yo_0) > stopDist(v)`}) ;
    ghosts;
    loop({`0<=t&t<=ep()&v>=0&dx^2+dy^2=1&v=v_0+A()*t&-t*V()<=xo-xo_0&xo-xo_0<=t*V()&-t*V()<=yo-yo_0&yo-yo_0<=t*V()&-t*(v-A()/2*t)<=x-x_0&x-x_0<=t*(v-A()/2*t)&-t*(v-A()/2*t)<=y-y_0&y-y_0<=t*(v-A()/2*t)`}, 1) ; <(
      QE,
      andR(1) ; <(
        prop,
        andR(1) ; <(
          prop,
          implyR(1) ; orR(1) ;
          orL('L=={`abs(x_0-xo_0) > admissibleSeparation(v_0) | abs(y_0-yo_0) > admissibleSeparation(v_0)`}); <(
            transform({`abs(x_0-xo_0) > v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
            hideR('R=={`abs(y-yo) > stopDist(v)`}); smartQE
            ,
            transform({`abs(y_0-yo_0) > v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
            hideR('R=={`abs(x-xo) > stopDist(v)`}); smartQE
          )
        )
      ),
      unfold; hideL('L=={`abs(x_0-xo_0) > admissibleSeparation(v_0) | abs(y_0-yo_0) > admissibleSeparation(v_0)`});
      dia; dw; unfold; doall(smartQE)
    )
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); brakingInnerLoop; print({`Braking branch done`})
      ,
      print({`Stopped branch`}); stoppedInnerLoop; print({`Stopped branch done`})
      ,
      print({`Acceleration branch`}); accInnerLoop; print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

Theorem "Theorem 11: Reach waypoint".

/*
 *	Robot must stop within distance delta at goal.
 *
 *  Robot
 * 	- must stop within distance delta of goal
 *  - can only drive straight and forward
 *  - ensures progress towards goal
 *
 *  Liveness property:
 *  - Robot can stop at goal
 *
 */

Definitions.
	R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R GDelta().	 /* goal area size */
	R Vmax().    /* robot cannot go faster than this */

	R waypointStartDist(R xg) = ( xg-GDelta() ).
	R waypointEndDist(R xg)   = ( xg+GDelta() ).

  R minV() = ( A()*ep() ).

	R stopDist(R v) = ( v^2/(2*b()) ).
	R accComp(R v)  = ( (A()/b() + 1)*(A()/2*ep()^2 + ep()*v) ).

	B bounds() <-> (                                                                     /* Bounds for global constants */
      A() > 0                                                                                       /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & Vmax() >= 2*A()*ep()
    & GDelta() > Vmax()*ep() + Vmax()^2/(2*b())                            /* waypoint is large enough that robot can
                                                                                  start driving and still stop inside */
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    vr = 0
    & xr < waypointStartDist(xg)
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

	B loopinv() <-> (
	  0 <= vr & vr <= Vmax & xr + stopDist(vr) < waypointEndDist(xg)
	).

	HP ctrl ::= {
      ar := -b();
   ++ ?vr = 0; ar := 0;
   ++ ?xr + stopDist(vr) + accComp(vr) < waypointEndDist(xg) & vr+A()*ep()<=Vmax(); ar := A();
   ++ ?xr <= waypointStartDist(xg) & vr <= Vmax(); ar := *; ?-b() <= ar & ar <= (Vmax()-vr)/ep() & ar <= A();
	}.

	HP dyn ::= { {xr' = vr, vr' = ar, t' = 1 & t <= ep() & vr >= 0} }.

	HP dwwp ::= { { { ctrl; t:=0; } dyn; }*@invariant(loopinv()) }.
End.

ProgramVariables.
	R xr.		/* robot position: x */
	R vr.		/* robot translational velocity */
	R ar.		/* robot translational acceleration */
	R xg.		/* goal position */
	R t.		/* control cycle time */
End.

Problem.
  assumptions()
	  ->
	  /* safety */
	  [ dwwp; ] (xr < waypointEndDist(xg))
		&
		/* liveness */
		< dwwp; >(waypointStartDist(xg) < xr)
End.

Tactic "Proof Theorem 11: Reach waypoint".
  implyR(1) ; andL('L)* ; andR(1) ; <(
    master,
    iterated(1) ; orR(1) ; composed(2) ; composed(2) ; choiced(2) ; orR(2) ; hideR(2) ; choiced(2) ; orR(2) ;
    hideR(2) ; choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; andR(2); <(
      QE,
      composed(2) ; randomd(2) ; existsR({`min(((Vmax()-vr)/ep(),A()))`}, 2) ; testd(2) ; andR(2) ; <(
        QE,
        assignd(2) ; allR(2) ; implyR(2) ; solve(2) ; existsR({`ep()`}, 2) ; andR(2) ; <(
          QE,
          andR(2) ; <(
            QE,
            existsR({`ar*ep()+vr_1`}, 2) ; simplify(2) ;
            existsR({`ar/2*ep()^2+vr_1*ep()+xr_1`}, 2) ; simplify(2) ;
            con({`Vmax()>0&A()>0&b()>0&ep()>0&0 < vr&vr<=Vmax()&xg-GDelta() < xr+v*ep()*vr`}, 2) ; <(
              QE,
              composed(1) ; composed(1) ; cut({`xr<=xg-GDelta()|xg-GDelta() < xr`}) ; <(
                orL('L=={`xr<=xg-GDelta()|xg-GDelta() < xr`}) ; <(
                  choiced(1) ; orR(1) ; hideR(1) ; choiced(1) ; orR(1) ; hideR(1) ; choiced(1) ; orR(1) ;
                  hideR(1) ; composed(1) ; testd(1) ; andR(1) ; <(
                    master,
                    composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
                      QE,
                      assignd(1) ; allR(1) ; implyR(1) ; solve(1) ; QE({`Mathematica`})
                      )
                    ),
                  choiced(1) ; orR(1) ; hideR(2) ; assignd(1) ; assignd(1) ; allR(1) ; implyR(1) ; solve(1) ; QE({`Mathematica`})
                  ),
                hideR(1) ; QE
                ),
              QE
              )
            )
          )
        )
      )
    )
End.

End.

Theorem "Theorem 12: Cross intersection".

/*
 *	Robot must safely cross an intersection.
 *
 *  Robot
 * 	- must cross intersection safely
 *  - can only drive straight and forward
 *  - ensures progress towards intersection
 *
 *  Obstacle
 *  - Drives forward with minimum speed (does not block intersection)
 *
 *  Intersection
 *  - At position 0 (on both the robot's and the obstacle's path)
 *
 *  Liveness property:
 *  - Robot can cross intersection
 *
 *  Safety property:
 *  - Robot and obstacle are not at the intersection at the same time
 *
 */

Definitions.
	R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
	R Vmin().    /* obstacle minimum speed */
	R ixr() = ( 0 ). /* position of intersection on path of robot */
	R ixo() = ( 0 ). /* position of intersection on path of obstacle */

	R minV() = ( A()*ep() ).

	R stopDist(R v) = ( v^2/(2*b()) ).
	R accComp(R v)  = ( (A()/b() + 1)*(A()/2*ep()^2 + ep()*v) ).

	B OAfterX(R xo) <-> ( xo>ixo() ).
	B RAfterX(R x) <-> ( x>ixr() ).

	B bounds() <-> (                                                                     /* Bounds for global constants */
      A() > 0                                                                                       /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & Vmin() > 0
  ).
  B initialState() <-> (                                                   /* Somewhere before intersection initially */
    vr = 0
    & vo>=Vmin()
    & xr < ixr()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

	B loopinv() <-> (
	  0 <= vr & Vmin()<=vo & (RAfterX(xr) | OAfterX(xo) | xr + stopDist(vr) < ixr() |
	    (vr>0 & ( xo+vo*(ixr()-xr)/vr+A/2*((ixr()-xr)/vr)^2 < ixo()
              | ixo() < xo + Vmin()*(ixr()-xr)/vr))
    )
	).

	HP obstacle ::= { ao := *; ?-b()<=ao&ao<=A(); }.

	HP robot ::= {
    if (RAfterX(xr) | OAfterX(xo)) {
      ar := *; ?-b()<=ar&ar<=A();
    } else { if (/*PassFaster*/ vr>0 & ( xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()
                                       | ixo() < xo + Vmin()*(ixr()-xr)/(vr+A()*ep()) ) ) {
      ar := *; ?0<=ar&ar<=A();
    } else { if (/*PassCoast*/ vr>0 & ixo() < xo + Vmin()*(ixr()-xr)/vr) {
      ar := 0;
    } else {         /* 1D Model 3 */
        ar := -b();
     ++ ?vr = 0; ar := 0;
     ++ ?xr + stopDist(vr) + accComp(vr) < ixr(); ar := A();
    }}}
	}.

	HP dyn ::= { {xr' = vr, vr' = ar, xo'=vo, vo'=ao, t' = 1 & t <= ep() & vr >= 0 & vo>=Vmin() } }.

	HP dwcx ::= {
	  {	obstacle;
      { robot; t := 0; }
      dyn;
    }*@invariant(loopinv())
	}.
End.

ProgramVariables.
	R xr.		/* robot position: x */
	R vr.		/* robot translational velocity */
	R ar.		/* robot translational acceleration */
	R xo.		/* obstacle position */
	R vo.   /* obstacle velocity */
	R ao.   /* obstacle acceleration */
	R t.		/* control cycle time */
End.

Problem.
  assumptions()
	  ->
	  /* safety */
	  [ dwcx; ](xr=ixr() -> xo!=ixo())
		&
		/* liveness */
		< dwcx; >(RAfterX(xr))
End.

Tactic "Proof Theorem 12: Cross intersection (single convergence condition)".
/* some of the QE need QE({`Mathematica`}) */
  implyR(1) ; andR(1) ; <(
  loop({`0<=vr&Vmin()<=vo&(xr>0|xo>0|xr+vr^2/(2*b()) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr))`}, 1) ; <(
    QE,
    QE,
    composeb(1) ; composeb(1.1) ; solve(1.1.1) ; chase(1) ; allR(1) ; implyR(1) ; andL(-1) ; andL(-7) ; andR(1) ; <(
      implyR(1) ; allR(1) ; implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; orL(-9) ; <(
        fullSimplify ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            orR(1) ; hideR(2) ; QE
            )
          ),
        fullSimplify ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            orR(1) ; orR(2) ; hideR(3) ; hideR(1) ; QE
            )
          )
        ),
      implyR(1) ; andR(1) ; <(
        implyR(1) ; andL(-10) ; fullSimplify ; allR(1) ; implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            orR(1) ; orR(2) ; orR(3) ; hideL(-7) ; hideR(3) ; andR(3) ; <(
              QE,
              orR(3) ; orL(-9) ; <(
                hideR(4) ; hideL(-7) ; hideR(2) ; QE,
                hideL(-7) ; hideR(3) ; hideR(2) ; QE
                )
              )
            )
          ),
        implyR(1) ; andR(1) ; <(
          implyR(1) ; andL(-11) ; fullSimplify ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
            QE,
            orR(1) ; orR(2) ; orR(3) ; orR(4) ; hideR(4) ; hideR(3) ; hideL(-7) ; hideL(-7) ; hideL(-7) ; QE
            ),
          implyR(1) ; andR(1) ; <(
            notOr(-9) ; andL(-9) ; notAnd(-9) ; notAnd(-10) ; fullSimplify ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
              QE,
              andR(1) ; <(
                QE,
                orR(1) ; orR(2) ; orR(3) ; orL(-8) ; <(
                  hideR(4) ; hideR(1) ; hideR(1) ; hideL(-9) ; hideL(-9) ; QE,
                  andL(-8) ; fullSimplify ; fullSimplify ; closeFalse
                  )
                )
              ),
            andR(1) ; <(
              implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; fullSimplify ; andR(1) ; <(
                QE,
                QE
                ),
              implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; hideL(-10) ; hideL(-10) ; hideL(-9) ; hideL(-8) ; andR(1) ; <(
                QE,
                andR(1) ; <(
                  QE,
                  orR(1) ; orR(2) ; orR(3) ; hideR(4) ; hideR(1) ; hideR(1) ; QE
                  )
                )
              )
            )
          )
        )
      )
    ),
  con({`A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo<=0->vr=0)&\exists n (n>=2&xo+(v-n)*ep()*Vmin()>0&vr+(min((v,n-1))-(n-2))*ep()*A()>=A()*ep()&(xr>0|xr+min((v,n-2))*ep()*(A()*ep())>0))`}, 1) ; <(
    QE,
    composed(1) ; composed(1.1) ; solve(1.1.1) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
      QE,
      composed(1) ; andL(-2) ; andL(-3) ; andL(-4) ; andL(-5) ; andL(-6) ; andL(-7) ; andL(-8) ; existsL(-9) ; andL(-9) ; andL(-10) ; andL(-11) ; choiced(1) ; orR(1) ; composed(1) ; testd(1) ; orL(-12) ; <(
        hideR(2) ; fullSimplify ; composed(1) ; randomd(1) ; implyL(-8) ; <(
          cut({`xo+vo*ep()>0|xo+vo*ep()<=0`}) ; <(
            orL(-12) ; <(
              existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
                QE,
                assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                  QE,
                  andR(1) ; <(
                    QE,
                    fullSimplify ; andR(1) ; <(
                      QE,
                      existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                        QE,
                        andR(1) ; <(
                          QE,
                          QE
                          )
                        )
                      )
                    )
                  )
                ),
              hideR(1) ; QE
              ),
            hideR(1) ; QE
            ),
          cut({`xo+vo*ep()>0|xo+vo*ep()<=0`}) ; <(
            orL(-13) ; <(
              existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
                QE,
                assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                  QE,
                  andR(1) ; <(
                    QE,
                    fullSimplify ; andR(1) ; <(
                      QE,
                      existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                        QE,
                        andR(1) ; <(
                          QE,
                          QE
                          )
                        )
                      )
                    )
                  )
                ),
              existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
                QE,
                assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                  QE,
                  andR(1) ; <(
                    QE,
                    fullSimplify ; existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                      QE,
                      andR(1) ; <(
                        QE,
                        QE
                        )
                      )
                    )
                  )
                )
              ),
            hideR(1) ; QE
            )
          ),
        composed(2) ; testd(2) ; implyL(-8) ; <(
          andR(1) ; <(
            hideR(2) ; QE,
            hideR(2) ; composed(1) ; randomd(1) ; existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
              QE,
              assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                QE,
                andR(1) ; <(
                  QE,
                  fullSimplify ; andR(1) ; <(
                    QE,
                    existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                      QE,
                      andR(1) ; <(
                        QE,
                        QE
                        )
                      )
                    )
                  )
                )
              )
            ),
          andR(1) ; <(
            andR(2) ; <(
              QE,
              choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; andR(2) ; <(
                QE,
                choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; andR(2) ; <(
                  QE,
                  choiced(2) ; orR(2) ; hideR(2) ; choiced(2) ; orR(2) ; hideR(3) ; composed(2) ; testd(2) ; fullSimplify ; assignd(2) ; assignd(2) ; existsR({`ep()`}, 2) ; andR(2) ; <(
                    QE,
                    andR(2) ; <(
                      QE,
                      fullSimplify ; existsR({`n`}, 2) ; fullSimplify ; andR(2) ; <(
                        QE,
                        andR(2) ; <(
                          QE,
                          QE
                          )
                        )
                      )
                    )
                  )
                )
              ),
            hideR(2) ; composed(1) ; randomd(1) ; cut({`xo+vo*ep()>0|xo+vo*ep()<=0`}) ; <(
              orL(-13) ; <(
                existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
                  QE,
                  assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                    QE,
                    andR(1) ; <(
                      QE,
                      fullSimplify ; andR(1) ; <(
                        QE,
                        existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                          QE,
                          andR(1) ; <(
                            QE,
                            QE
                            )
                          )
                        )
                      )
                    )
                  ),
                existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
                  QE,
                  assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                    QE,
                    andR(1) ; <(
                      QE,
                      fullSimplify ; existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                        QE,
                        andR(1) ; <(
                          QE,
                          QE
                          )
                        )
                      )
                    )
                  )
                ),
              hideR(1) ; QE
              )
            )
          )
        )
      ),
    QE
    )
  )
End.

Tactic "Proof Theorem 12: Cross intersection (loop split and unroll)".
/* some of the QE need QE({`Mathematica`}) */
implyR(1) ; andR(1) ; <(
  loop({`0<=vr&Vmin()<=vo&(xr>0|xo>0|xr+vr^2/(2*b()) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr))`}, 1) ; <(
    QE,
    QE,
    composeb(1) ; composeb(1.1) ; solve(1.1.1) ; chase(1) ; allR(1) ; implyR(1) ; andL(-1) ; andL(-7) ; andR(1) ; <(
      implyR(1) ; allR(1) ; implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; orL(-9) ; <(
        fullSimplify ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            orR(1) ; hideR(2) ; QE
            )
          ),
        fullSimplify ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            orR(1) ; orR(2) ; hideR(3) ; hideR(1) ; QE
            )
          )
        ),
      implyR(1) ; andR(1) ; <(
        implyR(1) ; andL(-10) ; fullSimplify ; allR(1) ; implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            orR(1) ; orR(2) ; orR(3) ; hideL(-7) ; hideR(3) ; andR(3) ; <(
              QE,
              orR(3) ; orL(-9) ; <(
                hideR(4) ; hideL(-7) ; hideR(2) ; QE,
                hideL(-7) ; hideR(3) ; hideR(2) ; QE
                )
              )
            )
          ),
        implyR(1) ; andR(1) ; <(
          implyR(1) ; andL(-11) ; fullSimplify ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
            QE,
            orR(1) ; orR(2) ; orR(3) ; orR(4) ; hideR(4) ; hideR(3) ; hideL(-7) ; hideL(-7) ; hideL(-7) ; QE
            ),
          implyR(1) ; andR(1) ; <(
            notOr(-9) ; andL(-9) ; notAnd(-9) ; notAnd(-10) ; fullSimplify ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
              QE,
              andR(1) ; <(
                QE,
                orR(1) ; orR(2) ; orR(3) ; orL(-8) ; <(
                  hideR(4) ; hideR(1) ; hideR(1) ; hideL(-9) ; hideL(-9) ; QE,
                  andL(-8) ; fullSimplify ; fullSimplify ; closeFalse
                  )
                )
              ),
            andR(1) ; <(
              implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; fullSimplify ; andR(1) ; <(
                QE,
                QE
                ),
              implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; hideL(-10) ; hideL(-10) ; hideL(-9) ; hideL(-8) ; andR(1) ; <(
                QE,
                andR(1) ; <(
                  QE,
                  orR(1) ; orR(2) ; orR(3) ; hideR(4) ; hideR(1) ; hideR(1) ; QE
                  )
                )
              )
            )
          )
        )
      )
    ),
  andL('L)* ; useAt({`<*> merge`}, {`1`}, 1) ; con({`A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+v*ep()*Vmin()>0`}, 1) ; <(
    QE,
    andL('L)* ; composed(1) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
      QE,
      composed(1) ; solve(1.1) ; composed(1) ; choiced(1) ; orR(1) ; orL(-8) ; <(
        hideR(2) ; composed(1) ; testd(1) ; simplify(1) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
          QE,
          assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; QE
          ),
        composed(1) ; testd(1) ; andR(1) ; <(
          composed(2) ; testd(2) ; andR(2) ; <(
            QE,
            choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; simplify(2) ; choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; simplify(2) ; choiced(2) ; orR(2) ; hideR(2) ; choiced(2) ; orR(2) ; hideR(3) ; composed(2) ; testd(2) ; simplify(2) ; assignd(2) ; assignd(2) ; existsR({`ep()`}, 2) ; simplify(2) ; QE
            ),
          hideR(2) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
            QE,
            assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; QE
            )
          )
        )
      ),
    andL('L)* ; edit({`xo>0`}, -9) ; hideL(-1) ; fullSimplify ; iterated(1) ; orR(1) ; composed(2) ; composed(2) ; randomd(2) ; existsR({`0`}, 2) ; testd(2) ; andR(2) ; <(
      QE,
      composed(2) ; composed(2) ; choiced(2) ; orR(2) ; hideR(3) ; composed(2) ; testd(2) ; simplify(2) ; composed(2) ; randomd(2) ; existsR({`A()`}, 2) ; testd(2) ; andR(2) ; <(
        QE,
        assignd(2) ; allR(2) ; implyR(2) ; solve(2) ; existsR({`ep()`}, 2) ; simplify(2) ; andR(2) ; <(
          QE,
          print({`Solved`}); existsR({`vo_1+0`}, 2) ; fullSimplify ; existsR({`A()*ep()+vr_1`}, 2) ; simplify(2) ; existsR({`vo_1*ep()+xo_1`}, 2) ; simplify(2) ; existsR({`A()/2*ep()^2+vr_1*ep()+xr_1`}, 2) ; simplify(2) ; edit({`vr>=A()*ep()`}, -10) ; edit({`xr>=xr_1`}, -12) ; edit({`xo>0`}, -11) ; hideL(-7=={`xo_1>0`}) ; hideL(-6=={`vr_1>=0`}) ; con({`A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&xo>0&vr>=A()*ep()&xr+v*ep()*(A()*ep())>0`}, 2) ; <(
            QE,
            andL('L)* ; composed(1) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
              QE,
              composed(1) ; solve(1.1) ; composed(1) ; choiced(1) ; orR(1) ; composed(1) ; testd(1) ; simplify(1) ; hideR(2) ; composed(1) ; randomd(1) ; existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
                QE,
                assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; QE
                )
              ),
            QE
            )
          )
        )
      )
    )
  )
End.

End.

Theorem "Theorem 13: Passive safety with trajectory distance measurement".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = (v^2 / (2*b()) + V()*v/b()).
  R accelComp(R v, R a) = ((a/b() + 1) * (a/2 * ep()^2 + ep()*(v+V))).
  R admissibleSeparationG(R v, R a) = (stopDist(v) + accelComp(v,a)).
  R admissibleSeparationL(R v, R a) = (-v^2/(2*a)-V*v/a).
  R trajectoryDist(R r, R xo, R xc, R yo, R yc) = ( abs(abs(r) - ((xo-xc)^2 + (yo-yc)^2)^(1/2)) ).

  B isWellformedDir() <-> ( r!=0 & r^2 = (x-xc)^2 + (y-yc)^2 & dx^2 + dy^2 = 1 & dx = -(y-yc)/r & dy = (x-xc)/r & w*r=v ).

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v) | abs(abs(r) - ((xo-xc)^2 + (yo-yc)^2)^(1/2)) > V*v/b)
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xc.
  R yc.
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; { dx:=-dx;dy:=-dy; ++ dx:=dx;dy:=dy; }; r := *; xc := *; yc := *;
            ?(r!=0 & r^2 = (x-xc)^2+(y-yc)^2 & dx=-(y-yc)/r & dy=(x-xc)/r & r*w=v); }
      	  ++
          /* or choose a new safe curve */
          { a := *; ?-b<=a & a<=A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xc := *; yc := *;

            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?(r!=0 & r^2 = (x-xc)^2+(y-yc)^2 & dx=-(y-yc)/r & dy=(x-xc)/r & r*w=v);

            /* use that curve, if it is a safe one (admissible velocities) */
            if (v+a*ep>=0) { ?abs(x-xo) > admissibleSeparationG(v,a) | abs(y-yo) > admissibleSeparationG(v,a) | trajectoryDist(r,xo,xc,yo,yc) > V*(ep + (v+a*ep)/b); }
            else           { ?abs(x-xo) > admissibleSeparationL(v,a) | abs(y-yo) > admissibleSeparationL(v,a) | trajectoryDist(r,xo,xc,yo,yc) > -V*v/a; }
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 13: Passive safety with trajectory distance measurement".
/* Some of the QE need QE({`Mathematica`}) */
implyR(1) ; loop({`v>=0&(r!=0&r^2=(x-xc)^2+(y-yc)^2&dx^2+dy^2=1&dx=-(y-yc)/r&dy=(x-xc)/r&w*r=v)&(v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b()|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V()*v/b())`}, 1) ; <(
  QE,
  unfold ; fullSimplify ; hideL(-6) ; hideL(-7) ; hideL(-7) ; hideL(-7) ; hideL(-7) ; hideL(-3) ; hideL(-1) ; orL(-3) ; <(
    QE,
    orL(-3) ; <(
      QE,
      absExp(-3.0) ; absExp(-6.0.0.0.0) ; orL(-7) ; <(
        QE,
        QE
        )
      )
    ),
  unfold ; <(
    dC({`t>=0&dx^2+dy^2=1&v=old(v)-b()*t&w*r=v`}, 1) ; <(
      dC({`dx=-(y-yc)/r&dy=(x-xc)/r`}, 1) ; <(
        dC({`xo=old(xo)+vxo*t&yo=old(yo)+vyo*t`}, 1) ; <(
          dC({`-t*(v+b()/2*t)<=x-old(x)&x-old(x)<=t*(v+b()/2*t)`}, 1) ; <(
            dC({`-t*(v+b()/2*t)<=y-old(y)&y-old(y)<=t*(v+b()/2*t)`}, 1) ; <(
              dW(1) ; implyR(1) ; andL('L)* ; fullSimplify ; andR(1) ; <(
                hideL(-6) ; QE,
                implyR(1) ; orR(1) ; orR(2) ; hideL(-1) ; hideL(-6) ; hideL(-6) ; hideL(-13) ; hideL(-13) ; hideL(-16) ; hideL(-17) ; hideL(-13) ; hideL(-2) ; implyL(-4) ; <(
                  hideR(1) ; hideR(1) ; hideR(1) ; QE,
                  orL(-4) ; <(
                    hideR(2) ; hideR(2) ; smartQE,
                    orL(-4) ; <(
                      hideR(1) ; hideR(2) ; smartQE,
                      hideR(1) ; hideR(1) ; edit({`abs(abs(r)-abbrv((((xo_0-xc)^2+(yo_0-yc)^2)^(1/2),oldCDist)))>V()*v_0/b()`}, -4) ; edit({`abs(abs(r)-abbrv((((xo-xc)^2+(yo-yc)^2)^(1/2),cDist)))>V()*v/b()`}, 1) ; cut({`abs(cDist-oldCDist)<=t*V()`}) ; <(
                        hideL(-16) ; hideL(-16) ; hideL(-5) ; hideL(-5) ; hideL(-5) ; hideL(-5) ; hideL(-5) ; hideL(-5) ; hideL(-5) ; smartQE,
                        hideR(1) ; hideL(-4) ; hideL(-5) ; hideL(-5) ; hideL(-5) ; hideL(-5) ; hideL(-3) ; hideL(-6) ; hideL(-7) ; hideL(-7) ; cut({`abs(cDist-oldCDist)<=t*(vxo^2+vyo^2)^(1/2)`}) ; <(
                          hideL(-7) ; hideL(-7) ; hideL(-4) ; hideL(-4) ; hideL(-1) ; QE,
                          hideR(1) ; hideL(-3) ; hideL(-2) ; hideL(-1) ; smartQE
                          )
                        )
                      )
                    )
                  )
                ),
              hideL(-6) ; dI(1)
              ),
            hideL(-6) ; dI(1)
            ),
          hideL(-6) ; dI(1)
          ),
        hideL(-6) ; dI(1)
        ),
      hideL(-6) ; dI(1)
      ),
    dC({`t>=0&dx^2+dy^2=1&v=old(v)&w*r=v`}, 1) ; <(
      dC({`dx=-(y-yc)/r&dy=(x-xc)/r`}, 1) ; <(
        dW(1) ; implyR(1) ; allL2R(-10) ; hideL(-10) ; andL('L)* ; fullSimplify ; QE,
        hideL(-6) ; dI(1)
        ),
      hideL(-6) ; dI(1)
      ),
    hideL(-6) ; hideL(-6) ; hideL(-6) ; hideL(-7) ; hideL(-7) ; hideL(-7) ; hideL(-9) ; hideL(-9) ; hideL(-9) ; hideL(-1) ; dC({`t>=0&dx^2+dy^2=1&v=old(v)+a*t&w*r=v`}, 1) ; <(
      dC({`dx=-(y-yc)/r&dy=(x-xc)/r`}, 1) ; <(
        dC({`xo=old(xo)+vxo*t&yo=old(yo)+vyo*t`}, 1) ; <(
          dC({`-t*(v-a/2*t)<=x-old(x)&x-old(x)<=t*(v-a/2*t)`}, 1) ; <(
            dC({`-t*(v-a/2*t)<=y-old(y)&y-old(y)<=t*(v-a/2*t)`}, 1) ; <(
              dW(1) ; implyR(1) ; andL('L)* ; fullSimplify ; andR(1) ; <(
                hideL(-10) ; QE,
                implyR(1) ; orR(1) ; orR(2) ; hideL(-7) ; hideL(-7) ; hideL(-15) ; hideL(-15) ; hideL(-18) ; hideL(-19) ; hideL(-19) ; orL(-8) ; <(
                  hideR(2) ; hideR(2) ; edit({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*t^2+t*(v_0+V()))`}, -8) ; hideL(-7) ; hideL(-2) ; hideL(-13) ; smartQE,
                  orL(-8) ; <(
                    hideR(1) ; hideR(2) ; edit({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*t^2+t*(v_0+V()))`}, -8) ; hideL(-7) ; hideL(-2) ; hideL(-13) ; smartQE,
                    hideR(1) ; hideR(1) ; hideL(-9) ; hideL(-9) ; hideL(-9) ; hideL(-9) ; edit({`abs(abs(r)-abbrv((((xo-xc)^2+(yo-yc)^2)^(1/2),cDist)))>V()*v/b()`}, 1) ; edit({`abs(abs(r)-abbrv((((xo_0-xc)^2+(yo_0-yc)^2)^(1/2),oldCDist)))>V()*(ep()+(v_0+a*ep())/b())`}, -8) ; cut({`abs(cDist-oldCDist)<=t*V()`}) ; <(
                      hideL(-15) ; hideL(-15) ; edit({`abs(abs(r)-oldCDist)>V()*(t+(v_0+a*t)/b())`}, -8) ; hideL(-11) ; hideL(-7) ; hideL(-2) ; hideL(-4) ; hideL(-4) ; hideL(-5) ; hideL(-5) ; smartQE,
                      hideR(1) ; hideL(-8) ; hideL(-7) ; hideL(-12) ; hideL(-9) ; hideL(-2) ; hideL(-5) ; hideL(-3) ; hideL(-6) ; cut({`abs(cDist-oldCDist)<=t*(vxo^2+vyo^2)^(1/2)`}) ; <(
                        hideL(-7) ; hideL(-7) ; hideL(-4) ; hideL(-4) ; hideL(-1) ; edit({`abbrv((abs(cDist-oldCDist),X))<=t*V()`}, 1) ; hideL(-5) ; QE,
                        hideR(1) ; hideL(-3) ; hideL(-2) ; hideL(-1) ; smartQE
                        )
                      )
                    )
                  )
                ),
              hideL(-14) ; dI(1)
              ),
            hideL(-14) ; dI(1)
            ),
          hideL(-14) ; dI(1)
          ),
        hideL(-14) ; dI(1)
        ),
      hideL(-14) ; dI(1)
      ),
    dC({`t>=0&dx^2+dy^2=1&v=old(v)&w*r=v`}, 1) ; <(
      dC({`dx=-(y-yc)/r&dy=(x-xc)/r`}, 1) ; <(
        dW(1) ; implyR(1) ; allL2R(-9) ; hideL(-9) ; andL('L)* ; fullSimplify ; QE,
        hideL(-6) ; dI(1)
        ),
      hideL(-6) ; dI(1)
      ),
    edit({`!v+a*ep() < 0`}, 1) ; notR(1) ; hideL(-6) ; hideL(-6) ; hideL(-6) ; hideL(-7) ; hideL(-7) ; hideL(-7) ; hideL(-10) ; hideL(-10) ; hideL(-9) ; hideL(-1) ; cut({`a < 0`}) ; <(
      dC({`t>=0&dx^2+dy^2=1&v=old(v)+a*t&w*r=v`}, 1) ; <(
        dC({`dx=-(y-yc)/r&dy=(x-xc)/r`}, 1) ; <(
          dC({`xo=old(xo)+vxo*t&yo=old(yo)+vyo*t`}, 1) ; <(
            dC({`-t*(v-a/2*t)<=x-old(x)&x-old(x)<=t*(v-a/2*t)`}, 1) ; <(
              dC({`-t*(v-a/2*t)<=y-old(y)&y-old(y)<=t*(v-a/2*t)`}, 1) ; <(
                dW(1) ; implyR(1) ; andL('L)* ; fullSimplify ; andR(1) ; <(
                  hideL(-9) ; QE,
                  implyR(1) ; orR(1) ; orR(2) ; hideL(-26) ; hideL(-25) ; hideL(-23) ; hideL(-19) ; hideL(-18) ; hideL(-18) ; hideL(-10) ; hideL(-8) ; hideL(-7) ; hideL(-2) ; orL(-6) ; <(
                    hideR(2) ; hideR(2) ; smartQE,
                    orL(-6) ; <(
                      hideR(1) ; hideR(2) ; smartQE,
                      hideR(1) ; hideR(1) ; edit({`abs(abs(r)-abbrv((((xo-xc)^2+(yo-yc)^2)^(1/2),cDist)))>V()*v/b()`}, 1) ; edit({`abs(abs(r)-abbrv((((xo_0-xc)^2+(yo_0-yc)^2)^(1/2),oldCDist)))>-V()*v_0/a`}, -6) ; cut({`abs(cDist-oldCDist)<=t*V()`}) ; <(
                        hideL(-17) ; hideL(-17) ; hideL(-8) ; hideL(-8) ; hideL(-8) ; hideL(-8) ; hideL(-8) ; hideL(-8) ; hideL(-4) ; smartQE,
                        hideR(1) ; hideL(-8) ; hideL(-8) ; hideL(-8) ; hideL(-8) ; hideL(-6) ; hideL(-11) ; hideL(-9) ; hideL(-5) ; hideL(-5) ; hideL(-3) ; hideL(-1) ; cut({`abs(cDist-oldCDist)<=t*(vxo^2+vyo^2)^(1/2)`}) ; <(
                          hideL(-6) ; hideL(-6) ; hideL(-3) ; hideL(-3) ; edit({`abbrv((abs(cDist-oldCDist),X))<=t*V()`}, 1) ; hideL(-5) ; QE,
                          hideR(1) ; hideL(-2) ; hideL(-1) ; smartQE
                          )
                        )
                      )
                    )
                  ),
                hideL(-13) ; dI(1)
                ),
              hideL(-13) ; dI(1)
              ),
            hideL(-13) ; dI(1)
            ),
          hideL(-13) ; dI(1)
          ),
        hideL(-13) ; dI(1)
        ),
      hideR(1) ; hideL(-13) ; QE
      )
    )
  )
End.

Theorem "Theorem 14: Reach waypoint with deadline".

/*
 *	Robot must stop within distance delta at goal.
 *
 *  Robot
 * 	- must stop within distance delta of goal
 *  - can only drive straight and forward
 *  - ensures progress towards goal
 *
 *  Liveness property:
 *  - Robot can stop at goal
 *
 */

Functions.
	R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R GDelta().	 /* goal area size */
	R Vmax().    /* robot cannot go faster than this */

	R waypointStartDist(R xg) = ( xg-GDelta() ).
	R waypointEndDist(R xg)   = ( xg+GDelta() ).

  R minV() = ( A()*ep() ).
  R maxTravelTime(R g) = ( waypointStartDist(g)/minV() ).
  R stopTime(R v)      = ( v/b() ).
  R speedUpTime(R v)   = ( ep()-v/A() ).

	R stopDist(R v) = ( v^2/(2*b()) ).
	R accComp(R v)  = ( (A()/b() + 1)*(A()/2*ep()^2 + ep()*v) ).

	B bounds() <-> (                                                                     /* Bounds for global constants */
      A() > 0                                                                                       /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & Vmax() >= 2*A()*ep()
    & GDelta() > Vmax()*ep() + Vmax()^2/(2*b())                            /* waypoint is large enough that robot can
                                                                                  start driving and still stop inside */
    & T > ep() + maxTravelTime(xg-xr) + ep() + stopTime(Vmax())
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    vr = 0
    & xr < waypointStartDist(xg)
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

	B loopinv() <-> (
	  0 <= vr & vr <= Vmax & xr + stopDist(vr) < waypointEndDist(xg)
    				& (waypointStartDist(xg) < xr -> (vr = 0 | T >= stopTime(vr)))
    				& (xr <= waypointStartDist(xg) ->
    				       (vr >= minV() & T > maxTravelTime(xg-xr) + ep() + stopTime(Vmax()))
    				     | (vr <= minV() & T > speedUpTime(vr) + maxTravelTime(xg-xr) + ep() + stopTime(Vmax())))
	).

	HP ctrl ::= {
    if (xr > waypointStartDist(xg)) {
      /* in the goal area: brake or stay stopped */
      ar := -b(); ++ ?vr = 0; ar := 0;
    } else {
      if (xr + stopDist(vr) + accComp(vr) < waypointEndDist(xg) & vr+A()*ep() <= Vmax()) {
        /* if robot can stop from higher speed before leaving goal area then accelerate */
        ar := A();
      } else {
        /* else coast until at goal */
        ar := 0;
      }
    }
	}.

	HP dyn ::= { {xr' = vr, vr' = ar, t' = 1, T'=-1 & t <= ep() & vr >= 0} }.

	HP dwwpdl ::= {
    {	{ ctrl; t := 0; }
      dyn;
    }*@invariant(loopinv())
	}.
End.

ProgramVariables.
	R xr.		/* robot position: x */
	R vr.		/* robot translational velocity */
	R ar.		/* robot translational acceleration */
	R xg.		/* goal position */
	R t.		/* control cycle time */
	R T.		/* global time */
End.

Problem.
  assumptions()
	  -> [ dwwpdl; ](xr < waypointEndDist(xg) & (T <= 0 -> (waypointStartDist(xg) < xr & vr = 0)))
		 & < dwwpdl; >(waypointStartDist(xg) < xr & vr = 0)
End.

Tactic "Proof Theorem 14: Reach waypoint with deadline".
  /* Some of the QE need QE({`Mathematica`}) */
  implyR(1) ; andR(1) ; <(
    loop({`0<=vr&vr<=Vmax()&xr+vr^2/(2*b()) < xg+GDelta()&(xg-GDelta() < xr->vr=0|T>=vr/b())&(xr<=xg-GDelta()->vr>=A()*ep()&T>(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()|vr<=A()*ep()&T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b())`}, 1) ; <(
      QE,
      andR(1) ; <(
        andL('L)* ; hideL(-10=={`xr<=xg-GDelta()->vr>=A()*ep()&T>(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()|vr<=A()*ep()&T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; QE,
        implyR(1) ; andL('L)* ; andR(1) ; <(
          hideL(-10=={`xg-GDelta() < xr->vr=0|T>=vr/b()`}) ; implyL(-10) ; <(
            QE,
            QE
            ),
          implyL(-10) ; <(
            implyL(-10) ; <(
              QE,
              QE
              ),
            hideL(-11=={`xr<=xg-GDelta()->vr>=A()*ep()&T>(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()|vr<=A()*ep()&T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; QE
            )
          )
        ),
      andL('L)* ; notGreater(1.0.0.0.1.0.0) ; notAnd(1.0.0.0.1.1.1.0.0) ; composeb(1) ; solve(1.1) ; chase(1) ; andR(1) ; <(
        implyR(1) ; fullSimplify ; andR(1) ; <(
          allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
            QE,
            andR(1) ; <(
              QE,
              andR(1) ; <(
                QE,
                andR(1) ; <(
                  QE,
                  implyR(1) ; orR(1) ; allL({`t_`}, -12) ; implyL(-12) ; <(
                    hideR(1=={`(-b())*t_+vr>=A()*ep()&-t_+T>(xg-((-b())/2*t_^2+vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideR(1=={`(-b())*t_+vr<=A()*ep()&-t_+T>ep()-((-b())*t_+vr)/A()+(xg-((-b())/2*t_^2+vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; QE,
                    hideR(1=={`(-b())*t_+vr>=A()*ep()&-t_+T>(xg-((-b())/2*t_^2+vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideR(1=={`(-b())*t_+vr<=A()*ep()&-t_+T>ep()-((-b())*t_+vr)/A()+(xg-((-b())/2*t_^2+vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideL(-5=={`GDelta()>Vmax()*ep()+Vmax()^2/(2*b())`}) ; hideL(-7=={`xr+vr^2/(2*b()) < xg+GDelta()`}) ; QE
                    )
                  )
                )
              )
            ),
          implyR(1) ; fullSimplify ; allR(1) ; implyR(1) ; implyR(1) ; QE
          ),
        implyR(1) ; fullSimplify ; andR(1) ; <(
          implyR(1) ; andL(-11) ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
            QE,
            andR(1) ; <(
              QE,
              andR(1) ; <(
                hideL(-9=={`vr>=A()*ep()&T>(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()|vr<=A()*ep()&T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideL(-9=={`xr<=xg-GDelta()`}) ; hideL(-8=={`xr+vr^2/(2*b()) < xg+GDelta()`}) ; hideL(-4=={`Vmax()>=2*A()*ep()`}) ; hideL(-4=={`GDelta()>Vmax()*ep()+Vmax()^2/(2*b())`}) ; hideL(-5=={`vr<=Vmax()`}) ; hideL(-6=={`vr+A()*ep()<=Vmax()`}) ; QE,
                andR(1) ; <(
                  hideL(-11=={`xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()`}) ; hideL(-8=={`xr+vr^2/(2*b()) < xg+GDelta()`}) ; implyR(1) ; orR(1) ; QE,
                  implyR(1) ; orR(1) ; hideL(-11=={`xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()`}) ; hideL(-8=={`xr+vr^2/(2*b()) < xg+GDelta()`}) ; orL(-8) ; <(
                    hideR(2=={`A()*t_+vr<=A()*ep()&-t_+T>ep()-(A()*t_+vr)/A()+(xg-(A()/2*t_^2+vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; andL(-8) ; andR(1) ; <(
                      QE,
                      QE
                      ),
                    andL(-8) ; andR(1) ; <(
                      andR(2) ; <(
                        QE,
                        QE
                        ),
                      andR(2) ; <(
                        allL({`t_`}, -11) ; implyL(-11) ; <(
                          hideR(1=={`-t_+T>(xg-(A()/2*t_^2+vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideR(1=={`A()*t_+vr<=A()*ep()`}) ; QE,
                          andL(-11) ; hideL(-11=={`A()/2*t_^2+vr*t_+xr<=xg-GDelta()`}) ; hideL(-5=={`GDelta()>Vmax()*ep()+Vmax()^2/(2*b())`}) ; edit({`-t_+T>(xg-(A()/2*t_^2+vr*t_+xr)-GDelta())/(A()*ep())+abbrv(ep()+Vmax()/b())`}, 1) ; edit({`T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+abbrv`}, -11) ; hideL(-14=={`abbrv=ep()+Vmax()/b()`}) ; edit({`vr+A()*t_<=Vmax()`}, -8) ; QE
                          ),
                        QE
                        )
                      )
                    )
                  )
                )
              )
            ),
          implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
            hideL(-9=={`vr>=A()*ep()&T>(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()|vr<=A()*ep()&T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideL(-10=={`xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr)>=xg+GDelta()|vr+A()*ep()>Vmax()`}) ; QE,
            andR(1) ; <(
              hideL(-8=={`xr+vr^2/(2*b()) < xg+GDelta()`}) ; allL({`t_`}, -12) ; implyL(-12) ; <(
                hideR(1=={`xg-GDelta() < vr*t_+xr->vr=0|-t_+T>=vr/b()`}) ; QE,
                orL(-8) ; <(
                  orL(-10) ; <(
                    QE,
                    QE
                    ),
                  implyR(1) ; orR(1) ; orL(-10) ; <(
                    QE,
                    QE
                    )
                  )
                ),
              implyR(1) ; orR(1) ; fullSimplify ; orL(-9) ; <(
                hideR(2=={`vr<=A()*ep()&-t_+T>ep()-vr/A()+(xg-(vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; andL(-9) ; fullSimplify ; orL(-10) ; <(
                  edit({`-t_+T>(xg-(vr*t_+xr)-GDelta())/(A()*ep())+abbrv(ep()+Vmax()/b())`}, 1) ; edit({`T>(xg-xr-GDelta())/(A()*ep())+abbrv`}, -15) ; hideL(-16=={`abbrv=ep()+Vmax()/b()`}) ; allL({`t_`}, -12) ; implyL(-12) ; <(
                    QE,
                    hideL(-10=={`xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr)>=xg+GDelta()`}) ; hideL(-5=={`GDelta()>Vmax()*ep()+Vmax()^2/(2*b())`}) ; QE
                    ),
                  allL({`t_`}, -12) ; implyL(-12) ; <(
                    QE,
                    edit({`-t_+T>(xg-(vr*t_+xr)-GDelta())/(A()*ep())+abbrv(ep()+Vmax()/b())`}, 1) ; edit({`T>(xg-xr-GDelta())/(A()*ep())+abbrv`}, -15) ; hideL(-16=={`abbrv=ep()+Vmax()/b()`}) ; hideL(-8=={`xr+vr^2/(2*b()) < xg+GDelta()`}) ; hideL(-5=={`GDelta()>Vmax()*ep()+Vmax()^2/(2*b())`}) ; QE
                    )
                  ),
                allL({`t_`}, -13) ; implyL(-13) ; <(
                  hideR(1=={`vr>=A()*ep()&-t_+T>(xg-(vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideR(1=={`vr<=A()*ep()&-t_+T>ep()-vr/A()+(xg-(vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; QE,
                  andL(-9) ; fullSimplify ; hideR(1=={`vr>=A()*ep()&-t_+T>(xg-(vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideR(1=={`-t_+T>ep()-vr/A()+(xg-(vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; orL(-10) ; <(
                    hideL(-15=={`T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideL(-9=={`xr<=xg-GDelta()`}) ; QE,
                    hideL(-15=={`T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; QE
                    )
                  )
                )
              )
            )
          )
        )
      ),
    notGreater(1.0.0.0.0.1.0.0) ; notAnd(1.0.0.0.0.1.1.1.0.0) ; iterated(1) ; orR(1) ; composed(2) ; solve(2.1) ; composed(2) ; choiced(2) ; orR(2) ; hideR(2=={`<?xr_1>xg-GDelta();{ar:=-b();++?vr_1=0;ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr_1>=0)&\exists T (T=-t_+T_1&\exists vr (vr=ar*t_+vr_1&\exists xr (xr=ar/2*t_^2+vr_1*t_+xr_1&<{{{?xr>xg-GDelta();{ar:=-b();++?vr=0;ar:=0;}++?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}}t:=0;}{xr'=vr,vr'=ar,t'=1,T'=-1&t<=ep()&vr>=0}}*>(xg-GDelta() < xr&vr=0)))))`}) ; composed(2) ; andL('L)* ; testd(2) ; hideL(-8=={`T_1>ep()+(xg-xr_1-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; simplify(2) ; choiced(2) ; orR(2) ; composed(2) ; testd(2) ; andR(2) ; <(
      hideR(3=={`<?!xr_1+vr_1^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr_1) < xg+GDelta()|!vr_1+A()*ep()<=Vmax();ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr_1>=0)&\exists T (T=-t_+T_1&\exists vr (vr=ar*t_+vr_1&\exists xr (xr=ar/2*t_^2+vr_1*t_+xr_1&<{{{?xr>xg-GDelta();{ar:=-b();++?vr=0;ar:=0;}++?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}}t:=0;}{xr'=vr,vr'=ar,t'=1,T'=-1&t<=ep()&vr>=0}}*>(xg-GDelta() < xr&vr=0)))))`}) ; QE,
      hideR(3=={`<?!xr_1+vr_1^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr_1) < xg+GDelta()|!vr_1+A()*ep()<=Vmax();ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr_1>=0)&\exists T (T=-t_+T_1&\exists vr (vr=ar*t_+vr_1&\exists xr (xr=ar/2*t_^2+vr_1*t_+xr_1&<{{{?xr>xg-GDelta();{ar:=-b();++?vr=0;ar:=0;}++?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}}t:=0;}{xr'=vr,vr'=ar,t'=1,T'=-1&t<=ep()&vr>=0}}*>(xg-GDelta() < xr&vr=0)))))`}) ; assignd(2) ; assignd(2) ; existsR({`ep()`}, 2) ; andR(2) ; <(
        QE,
        andR(2) ; <(
          QE,
          existsR({`-ep()+T_1`}, 2) ; simplify(2) ; existsR({`A()*ep()+vr_1`}, 2) ; simplify(2) ; existsR({`A()/2*ep()^2+vr_1*ep()+xr_1`}, 2) ; simplify(2) ; useAt({`<*> merge`}, {`1`}, 2) ; hideL(-8=={`T=-ep()+T_1`}) ; con({`Vmax()>0&A()>0&b()>0&ep()>0&0 < vr&vr<=Vmax()&(xg-GDelta() < xr|xg-GDelta() < xr+v*ep()*vr)`}, 2) ; <(
            QE,
            andL('L)* ; composed(1) ; solve(1.1) ; composed(1) ; choiced(1) ; orR(1) ; composed(1) ; testd(1) ; orL(-8) ; <(
              simplify(1) ; hideR(2=={`<?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < ar*t_+vr&ar*t_+vr<=Vmax()&(xg-GDelta() < ar/2*t_^2+vr*t_+xr|xg-GDelta() < ar/2*t_^2+vr*t_+xr+(v-1)*ep()*(ar*t_+vr)))`}) ; choiced(1) ; orR(1) ; hideR(2=={`<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < ar*t_+vr&ar*t_+vr<=Vmax()&(xg-GDelta() < ar/2*t_^2+vr*t_+xr|xg-GDelta() < ar/2*t_^2+vr*t_+xr+(v-1)*ep()*(ar*t_+vr)))`}) ; assignd(1) ; assignd(1) ; QE,
              cut({`xr>xg-GDelta()&(xr>xg-GDelta()-><ar:=-b();++?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < ar*t_+vr&ar*t_+vr<=Vmax()&(xg-GDelta() < ar/2*t_^2+vr*t_+xr|xg-GDelta() < ar/2*t_^2+vr*t_+xr+(v-1)*ep()*(ar*t_+vr))))`}) ; <(
                hideR(2=={`<?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < ar*t_+vr&ar*t_+vr<=Vmax()&(xg-GDelta() < ar/2*t_^2+vr*t_+xr|xg-GDelta() < ar/2*t_^2+vr*t_+xr+(v-1)*ep()*(ar*t_+vr)))`}) ; andL(-9) ; fullSimplify ; closeTrue,
                hideR(1=={`xr>xg-GDelta()&<ar:=-b();++?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < ar*t_+vr&ar*t_+vr<=Vmax()&(xg-GDelta() < ar/2*t_^2+vr*t_+xr|xg-GDelta() < ar/2*t_^2+vr*t_+xr+(v-1)*ep()*(ar*t_+vr)))`}) ; andR(2) ; <(
                  composed(1) ; testd(1) ; andR(1) ; <(
                    QE,
                    choiced(1) ; orR(1) ; composed(2) ; testd(2) ; andR(2) ; <(
                      composed(3) ; testd(3) ; andR(3) ; <(
                        prop,
                        assignd(3) ; assignd(3) ; existsR({`ep()`}, 3) ; fullSimplify ; QE
                        ),
                      assignd(2) ; assignd(2) ; composed(3) ; testd(3) ; andR(3) ; <(
                        fullSimplify ; orR(3) ; existsR({`ep()`}, 2) ; andR(2) ; <(
                          QE,
                          andR(2) ; <(
                            QE,
                            andR(2) ; <(
                              QE,
                              andR(2) ; <(
                                QE,
                                orR(2) ; QE
                                )
                              )
                            )
                          ),
                        assignd(3) ; assignd(3) ; existsR({`ep()`}, 3) ; hideR(2=={`\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&A()*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < A()*t_+vr&A()*t_+vr<=Vmax()&(xg-GDelta() < A()/2*t_^2+vr*t_+xr|xg-GDelta() < A()/2*t_^2+vr*t_+xr+(v-1)*ep()*(A()*t_+vr)))`}) ; fullSimplify ; QE
                        )
                      )
                    ),
                  hideR(1=={`<?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < ar*t_+vr&ar*t_+vr<=Vmax()&(xg-GDelta() < ar/2*t_^2+vr*t_+xr|xg-GDelta() < ar/2*t_^2+vr*t_+xr+(v-1)*ep()*(ar*t_+vr)))`}) ; implyR(1) ; choiced(1) ; orR(1) ; hideR(2=={`<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < ar*t_+vr&ar*t_+vr<=Vmax()&(xg-GDelta() < ar/2*t_^2+vr*t_+xr|xg-GDelta() < ar/2*t_^2+vr*t_+xr+(v-1)*ep()*(ar*t_+vr)))`}) ; assignd(1) ; assignd(1) ; QE
                  )
                )
              ),
            andL('L)* ; edit({`xg-GDelta() < xr`}, -8) ; hideL(-1=={`v<=0`}) ; useAt({`<*> merge`}, {`1`}, 1) ; con({`Vmax()>0&A()>0&b()>0&ep()>0&vr>=0&vr-v*ep()*b()<=b()*ep()&xg-GDelta() < xr`}, 1) ; <(
              QE,
              andL('L)* ; composed(1) ; solve(1.1) ; composed(1) ; choiced(1) ; orR(1) ; hideR(2=={`<?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&ar*t_+vr-(v-1)*ep()*b()<=b()*ep()&xg-GDelta() < ar/2*t_^2+vr*t_+xr)`}) ; composed(1) ; testd(1) ; simplify(1) ; choiced(1) ; orR(1) ; hideR(2=={`<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&ar*t_+vr-(v-1)*ep()*b()<=b()*ep()&xg-GDelta() < ar/2*t_^2+vr*t_+xr)`}) ; assignd(1) ; assignd(1) ; QE,
              andL('L)* ; edit({`vr<=b()*ep()`}, -7) ; hideL(-1=={`v<=0`}) ; iterated(1) ; orR(1) ; composed(2) ; solve(2.1) ; composed(2) ; choiced(2) ; orR(2) ; composed(2) ; testd(2) ; simplify(2) ; hideR(3=={`<?xr_1<=xg-GDelta();{?xr_1+vr_1^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr_1) < xg+GDelta()&vr_1+A()*ep()<=Vmax();ar:=A();++?!xr_1+vr_1^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr_1) < xg+GDelta()|!vr_1+A()*ep()<=Vmax();ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr_1>=0)&\exists T (T=-t_+T_1&\exists vr (vr=ar*t_+vr_1&\exists xr (xr=ar/2*t_^2+vr_1*t_+xr_1&<{{{?xr>xg-GDelta();{ar:=-b();++?vr=0;ar:=0;}++?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}}t:=0;}{xr'=vr,vr'=ar,t'=1,T'=-1&t<=ep()&vr>=0}}*>(xg-GDelta() < xr&vr=0)))))`}) ; choiced(2) ; orR(2) ; hideR(3=={`<?vr_1=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr_1>=0)&\exists T (T=-t_+T_1&\exists vr (vr=ar*t_+vr_1&\exists xr (xr=ar/2*t_^2+vr_1*t_+xr_1&<{{{?xr>xg-GDelta();{ar:=-b();++?vr=0;ar:=0;}++?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}}t:=0;}{xr'=vr,vr'=ar,t'=1,T'=-1&t<=ep()&vr>=0}}*>(xg-GDelta() < xr&vr=0)))))`}) ; assignd(2) ; assignd(2) ; existsR({`vr_1/b()`}, 2) ; andR(2) ; <(
                QE,
                andR(2) ; <(
                  QE,
                  existsR({`-vr_1/b()+T_1`}, 2) ; simplify(2) ; existsR({`0`}, 2) ; andR(2) ; <(
                    QE,
                    existsR({`vr_1^2/(2*b())+xr_1`}, 2) ; andR(2) ; <(
                      QE,
                      con({`Vmax()>0&A()>0&b()>0&ep()>0&vr=0&xg-GDelta() < xr`}, 2) ; <(
                        QE,
                        composed(1) ; solve(1.1) ; composed(1) ; andL('L)* ; choiced(1) ; orR(1) ; hideR(2=={`<?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&ar*t_+vr=0&xg-GDelta() < ar/2*t_^2+vr*t_+xr)`}) ; composed(1) ; testd(1) ; simplify(1) ; choiced(1) ; orR(1) ; hideR(1=={`<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&ar*t_+vr=0&xg-GDelta() < ar/2*t_^2+vr*t_+xr)`}) ; composed(1) ; testd(1) ; simplify(1) ; assignd(1) ; assignd(1) ; fullSimplify ; QE,
                        QE
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
End.

End.

Theorem "Theorem 15: Cross intersection with deadline".

/*
 *	Robot must safely cross an intersection.
 *
 *  Robot
 * 	- must cross intersection safely
 *  - can only drive straight and forward
 *  - ensures progress towards intersection
 *
 *  Obstacle
 *  - Drives forward with minimum speed (does not block intersection)
 *
 *  Intersection
 *  - At position 0 (on both the robot's and the obstacle's path)
 *
 *  Liveness property:
 *  - Robot can cross intersection
 *
 *  Safety property:
 *  - Robot always crosses intersection before deadline
 *  - Robot and obstacle are not at the intersection at the same time
 *
 */

Functions.
	R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
	R Vmin().    /* obstacle minimum speed */
	R ixr() = ( 0 ). /* position of intersection on path of robot */
	R ixo() = ( 0 ). /* position of intersection on path of obstacle */
	R D().       /* Deadline */

	R min(R,R).
	R max(R,R).

	R minV() = ( A()*ep() ).

	R stopDist(R v) = ( v^2/(2*b()) ).
	R accComp(R v)  = ( (A()/b() + 1)*(A()/2*ep()^2 + ep()*v) ).

	B OAfterX(R xo) <-> ( xo>ixo() ).
	B RAfterX(R xr) <-> ( xr>ixr() ).

	B bounds() <-> (                                                                     /* Bounds for global constants */
      A() > 0                                                                                       /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & Vmin() > 0
    & D() >= ep() & RAfterX(xr + A()/2*(D() - ep)^2)
  ).
  B initialState() <-> (                                                   /* Somewhere before intersection initially */
    vr = 0
    & vo>=Vmin()
    & xr < ixr()
    & ixr()-xr < A()/2*(D()-ep())^2
    & T = min(0, (xo-ixo())/Vmin()) - ep()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

	B safetyloopinv() <-> (
	  0 <= vr & Vmin()<=vo & (RAfterX(xr) | OAfterX(xo) | xr + stopDist(vr) < ixr() |
	    (vr>0 & ( xo+vo*(ixr()-xr)/vr+A/2*((ixr()-xr)/vr)^2 < ixo()
              | ixo() < xo + Vmin()*(ixr()-xr)/vr))
    )
	).

  B deadlineloopinv() <-> (
    0 <= vr & Vmin()<=vo
    & T <= (xo-ixo())/Vmin()
    & ( T <= 0 & RAfterX(xr + A()/2*(D() - ep)^2)
      | T > 0 & RAfterX(xr + vr*(max(0,D()-T)) + A()/2*(max(0,D()-T))^2) )
  ).

  HP obstacle ::= { ao := *; ?-b()<=ao&ao<=A(); }.

  HP robot ::= {
    if (OAfterX(xo)) {
      ar := A();
    } else { if (RAfterX(xr)) {
      ar := *; ?-b()<=ar&ar<=A();
    } else { if (/*PassFaster*/ vr>0 & ( xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()
                                       | ixo() < xo + Vmin()*(ixr()-xr)/(vr+A()*ep()) ) ) {
      ar := *; ?0<=ar&ar<=A();
    } else { if (/*PassCoast*/ vr>0 & ixo() < xo + Vmin()*(ixr()-xr)/vr) {
      ar := 0;
    } else {         /* 1D Model 3 */
        ar := -b();
     ++ ?vr = 0; ar := 0;
     ++ ?xr + stopDist(vr) + accComp(vr) < ixr(); ar := A();
    }}}}
  }.

  HP dyn ::= { {xr' = vr, vr' = ar, xo'=vo, vo'=ao, t' = 1, T'=1 & t <= ep() & vr >= 0 & vo>=Vmin() } }.

  HP dwcxd ::= {
    {
      obstacle;
      { robot; t := 0; }
      dyn;
    }*@invariant(loopinv())
  }.

End.

ProgramVariables.
	R xr.		/* robot position: x */
	R vr.		/* robot translational velocity */
	R ar.		/* robot translational acceleration */
	R xo.		/* obstacle position */
	R vo.   /* obstacle velocity */
	R ao.   /* obstacle acceleration */
	R t.		/* control cycle time */
	R T.    /* remaining time until robot must start driving (i.e., until obstacle has passed the intersection) */
End.

Problem.
  assumptions()
	  ->
	  /* safety */
	  [ dwcxd; ]( (xr=ixr() -> xo!=ixo()) & (T>=D() -> RAfterX(xr)) )
		&
		/* liveness */
		< dwcxd; >( RAfterX(xr) )
End.

Tactic "Proof Theorem 15: Cross intersection with deadline (single convergence condition)".
/* Some of the QE need QE({`Mathematica`}) */
implyR(1) ; andR(1) ; <(
  boxAnd(1) ; andR(1) ; <(
    loop({`0<=vr&Vmin()<=vo&(xr>0|xo>0|xr+vr^2/(2*b()) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr))`}, 1) ; <(
      QE,
      QE,
      boxAnd(1) ; andR(1) ; <(
        composeb(1) ; composeb(1.1) ; GV(1) ; GV(1.0) ; unfold ; dW(1) ; QE,
        boxAnd(1) ; andR(1) ; <(
          composeb(1) ; composeb(1.1) ; GV(1) ; GV(1.0) ; unfold ; dW(1) ; QE,
          notGreater(1.0.1.0.0.1.0.0) ; notGreater(1.0.1.0.0.1.1.1.0.0) ; notAnd(1.0.1.0.0.1.1.1.1.1.0.0) ; notAnd(1.0.1.0.0.1.1.1.1.1.1.1.0.0) ; notGreater(1.0.1.0.0.1.1.1.1.1.0.0.0) ; notOr(1.0.1.0.0.1.1.1.1.1.0.0.1) ; notLess(1.0.1.0.0.1.1.1.1.1.0.0.1.0) ; notLess(1.0.1.0.0.1.1.1.1.1.0.0.1.1) ; notGreater(1.0.1.0.0.1.1.1.1.1.1.1.0.0.0) ; notLess(1.0.1.0.0.1.1.1.1.1.1.1.0.0.1) ; unfold ; <(
            dC({`xo>=old(xo)`}, 1) ; <(
              dW(1) ; QE,
              dI(1)
              ),
            dC({`xr>=old(xr)`}, 1) ; <(
              dW(1) ; QE,
              dI(1)
              ),
            fullSimplify ; hideL(-5) ; dC({`t>=0&vr=old(vr)+ar*t&vo=old(vo)+ao*t`}, 1) ; <(
              dC({`xr=old(xr)+old(vr)*t+ar*t^2/2&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                dW(1) ; implyR(1) ; orR(1) ; orR(2) ; orR(3) ; hideL(-6) ; andR(4) ; <(
                  QE,
                  orR(4) ; andL('L)* ; orL(-11) ; <(
                    hideL(-16) ; hideL(-3) ; hideR(3) ; hideR(4) ; edit({`vr_0<=vr&vr<=vr_0+A()*t`}, -18) ; edit({`xr_0+vr_0*t<=xr&xr<=xr_0+vr_0*t+A()*t^2/2`}, -13) ; edit({`xo_0+Vmin()*t<=xo&xo<=xo_0+vo_0*t+A()*t^2/2`}, -14) ; edit({`vo<=vo_0+A()*t`}, -19) ; hideL(-5) ; hideL(-5) ; hideL(-9) ; hideL(-9) ; hideL(-2) ; andL('L)* ; hideL(-14) ; edit({`vo>0`}, -10) ; edit({`vo_0>0`}, -3) ; hideL(-2) ; hideL(-15) ; hideL(-12) ; QE,
                    edit({`0 < xo_0+Vmin()*(-xr_0)/(vr_0+A()*t)`}, -11) ; hideL(-3) ; hideL(-15) ; hideR(4) ; hideR(3) ; hideL(-5) ; hideL(-2) ; edit({`!xr<=0`}, 1) ; edit({`!xo<=0`}, 2) ; notR(1) ; notR(1) ; edit({`vr_0<=vr&vr<=vr_0+A()*t`}, -16) ; edit({`xr_0+vr_0*t<=xr&xr<=xr_0+vr_0*t+A()*t^2/2`}, -11) ; edit({`xo_0+Vmin()*t<=xo&xo<=xo_0+vo_0*t+A()*t^2/2`}, -12) ; edit({`vo<=vo_0+A()*t`}, -17) ; hideL(-4) ; hideL(-8) ; hideL(-8) ; andL('L)* ; hideL(-17) ; edit({`0 < vr`}, -17) ; hideL(-14) ; hideL(-10) ; hideL(-10) ; hideL(-3) ; QE
                    )
                  ),
                dI(1)
                ),
              dI(1)
              ),
            fullSimplify ; andL(-12) ; fullSimplify ; dC({`t>=0&vr=old(vr)&vo=old(vo)+ao*t`}, 1) ; <(
              dC({`xr=old(xr)+old(vr)*t&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                dW(1) ; implyR(1) ; orR(1) ; orR(2) ; orR(3) ; hideR(1) ; hideR(1) ; hideR(1) ; andR(1) ; <(
                  QE,
                  orR(1) ; hideR(1) ; hideL(-13) ; QE
                  ),
                dI(1)
                ),
              dI(1)
              ),
            fullSimplify ; orL(-8) ; <(
              dC({`t>=0&vr=old(vr)-b()*t`}, 1) ; <(
                dC({`xr=old(xr)+old(vr)*t-b()*t^2/2`}, 1) ; <(
                  dW(1) ; QE,
                  dI(1)
                  ),
                dI(1)
                ),
              andL(-8) ; fullSimplify ; hideR(1) ; QE
              ),
            hideL(-14) ; hideL(-13) ; dC({`vr=old(vr)`}, 1) ; <(
              dC({`xr=old(xr)`}, 1) ; <(
                orL(-8) ; <(
                  hideR(1) ; QE,
                  orL(-8) ; <(
                    hideR(1) ; QE,
                    orL(-8) ; <(
                      dW(1) ; QE,
                      hideR(1) ; QE
                      )
                    )
                  ),
                dI(1)
                ),
              dI(1)
              ),
            hideL(-13) ; hideL(-13) ; hideL(-8) ; dC({`t>=0&vr=old(vr)+A()*t`}, 1) ; <(
              dC({`xr=old(xr)+old(vr)*t+A()*t^2/2`}, 1) ; <(
                dW(1) ; implyR(1) ; orR(1) ; orR(2) ; orR(3) ; hideR(4) ; hideR(1) ; hideR(1) ; smartQE,
                dI(1)
                ),
              dI(1)
              )
            )
          )
        )
      ),
    loop({`0<=vr&Vmin()<=vo&T<=(xo-0)/Vmin()&(T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max((0,D()-T))+A()/2*max((0,D()-T))^2>0)`}, 1) ; <(
      QE,
      QE,
      notAnd(1.0.1.0.0.1.1.1.1.1.0.0) ; notGreater(1.0.1.0.0.1.1.1.1.1.0.0.0) ; notGreater(1.0.1.0.0.1.0.0) ; notGreater(1.0.1.0.0.1.1.1.0.0) ; notOr(1.0.1.0.0.1.1.1.1.1.0.0.1) ; notLess(1.0.1.0.0.1.1.1.1.1.0.0.1.0) ; notLess(1.0.1.0.0.1.1.1.1.1.0.0.1.1) ; notAnd(1.0.1.0.0.1.1.1.1.1.1.1.0.0) ; notGreater(1.0.1.0.0.1.1.1.1.1.1.1.0.0.0) ; notLess(1.0.1.0.0.1.1.1.1.1.1.1.0.0.1) ; boxAnd(1) ; andR(1) ; <(
        composeb(1) ; composeb(1.1) ; GV(1) ; GV(1.0) ; allR(1) ; allR(1) ; allR(1) ; dW(1) ; QE,
        boxAnd(1) ; andR(1) ; <(
          composeb(1) ; composeb(1.1) ; GV(1) ; GV(1.0) ; allR(1) ; allR(1) ; allR(1) ; dW(1) ; QE,
          boxAnd(1) ; andR(1) ; <(
            composeb(1) ; composeb(1.1) ; composeb(1.1) ; GV(1.1) ; unfold ; dC({`t>=0&T=old(T)+t&vo=old(vo)+ao*t`}, 1) ; <(
              dC({`xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                dW(1) ; QE,
                dI(1)
                ),
              dI(1)
              ),
            unfold ; <(
              dC({`t>=0&T=old(T)+t&vr=old(vr)+A()*t`}, 1) ; <(
                dC({`xr=old(xr)+old(vr)*t+A()*t^2/2`}, 1) ; <(
                  dW(1) ; implyR(1) ; orR(1) ; QE,
                  dI(1)
                  ),
                dI(1)
                ),
              orL(-9) ; <(
                dC({`t>=0&T=old(T)+t&vr=old(vr)+ar*t&vo=old(vo)+ao*t`}, 1) ; <(
                  dC({`xr=old(xr)+old(vr)*t+ar*t^2/2&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                    dW(1) ; implyR(1) ; orR(1) ; edit({`T>0&xr+vr*abbrv(max((0,D()-T)))+A()/2*max((0,D()-T))^2>0`}, 2) ; edit({`abbrv=expand(max((0,D()-T)))`}, -17) ; orL(-18) ; <(
                      andR(1) ; <(
                        andR(2) ; <(
                          QE,
                          smartQE
                          ),
                        andR(2) ; <(
                          smartQE,
                          smartQE
                          )
                        ),
                      andR(1) ; <(
                        andR(2) ; <(
                          QE,
                          smartQE
                          ),
                        andR(2) ; <(
                          smartQE,
                          smartQE
                          )
                        )
                      ),
                    dI(1)
                    ),
                  dI(1)
                  ),
                hideR(1) ; QE
                ),
              dC({`t>=0&T=old(T)+t&vr>=old(vr)&vo=old(vo)+ao*t`}, 1) ; <(
                dC({`xr>=old(xr)+old(vr)*t&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                  dW(1) ; hideL(-15) ; implyR(1) ; orR(1) ; edit({`T>0&xr+vr*abbrv(max((0,D()-T)))+A()/2*max((0,D()-T))^2>0`}, 2) ; edit({`abbrv=expand(max((0,D()-T)))`}, -18) ; andR(1) ; <(
                    andR(2) ; <(
                      QE,
                      orL(-9) ; <(
                        orL(-19) ; <(
                          smartQE,
                          smartQE
                          ),
                        hideR(1) ; hideR(1) ; QE
                        )
                      ),
                    orL(-9) ; <(
                      andR(2) ; <(
                        orL(-19) ; <(
                          smartQE,
                          smartQE
                          ),
                        orL(-19) ; <(
                          smartQE,
                          smartQE
                          )
                        ),
                      hideR(1) ; hideR(1) ; QE
                      )
                    ),
                  dI(1)
                  ),
                dI(1)
                ),
              dC({`t>=0&T=old(T)+t&vr=old(vr)&vo=old(vo)+ao*t`}, 1) ; <(
                dC({`xr=old(xr)+old(vr)*t&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                  dW(1) ; implyR(1) ; orR(1) ; andR(1) ; <(
                    andR(2) ; <(
                      QE,
                      edit({`xr+vr*abbrv(max((0,D()-T)))+A()/2*max((0,D()-T))^2>0`}, 2) ; edit({`abbrv=expand(max((0,D()-T)))`}, -18) ; orL(-19) ; <(
                        orL(-9) ; <(
                          hideL(-14) ; smartQE,
                          hideL(-14) ; smartQE
                          ),
                        hideL(-14) ; orL(-9) ; <(
                          smartQE,
                          smartQE
                          )
                        )
                      ),
                    andR(2) ; <(
                      smartQE,
                      smartQE
                      )
                    ),
                  dI(1)
                  ),
                dI(1)
                ),
              dC({`t>=0&T=old(T)+t&vr=old(vr)-b()*t&vo=old(vo)+ao*t`}, 1) ; <(
                dC({`xr=old(xr)+old(vr)*t-b()*t^2/2&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                  dW(1) ; implyR(1) ; orR(1) ; hideL(-15) ; hideL(-14) ; orL(-9) ; <(
                    andR(1) ; <(
                      andR(2) ; <(
                        QE,
                        edit({`xr+vr*abbrv(max((0,D()-T)))+A()/2*max((0,D()-T))^2>0`}, 2) ; edit({`abbrv=expand(max((0,D()-T)))`}, -15) ; orL(-16) ; <(
                          QE,
                          QE
                          )
                        ),
                      edit({`T>0&xr+vr*abbrv(max((0,D()-T)))+A()/2*max((0,D()-T))^2>0`}, 2) ; edit({`abbrv=expand(max((0,D()-T)))`}, -15) ; orL(-16) ; <(
                        QE,
                        andR(2) ; <(
                          smartQE,
                          smartQE
                          )
                        )
                      ),
                    hideR(1) ; andR(1) ; <(
                      QE,
                      QE
                      )
                    ),
                  dI(1)
                  ),
                dI(1)
                ),
              dC({`t>=0&T=old(T)+t&vr=old(vr)`}, 1) ; <(
                dC({`xr=old(xr)+old(vr)*t`}, 1) ; <(
                  dC({`vo=old(vo)+ao*t`}, 1) ; <(
                    dC({`xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                      dW(1) ; implyR(1) ; orR(1) ; QE,
                      dI(1)
                      ),
                    dI(1)
                    ),
                  dI(1)
                  ),
                dI(1)
                ),
              dC({`t>=0&T=old(T)+t&vr=old(vr)+A()*t`}, 1) ; <(
                dC({`xr=old(xr)+old(vr)*t+A()*t^2/2`}, 1) ; <(
                  dW(1) ; hideL(-11) ; QE,
                  dI(1)
                  ),
                dI(1)
                )
              )
            )
          )
        )
      )
    ),
  con({`A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo<=0->vr=0|xr>0)&\exists n (n>=2&xo+(v-n)*ep()*Vmin()>0&vr+(min((v,n-1))-(n-2))*ep()*A()>=A()*ep()&xr+min((v,n-2))*ep()*(A()*ep())>0)`}, 1) ; <(
    QE,
    composed(1) ; composed(1.1) ; solve(1.1.1) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
      QE,
      composed(1) ; choiced(1) ; orR(1) ; andL('L)* ; existsL(-9) ; andL('L)* ; implyL(-8) ; <(
        edit({`!xo>0`}, 3) ; notR(3) ; composed(1) ; testd(1) ; simplify(1) ; hideR(2) ; assignd(1) ; assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            existsR({`n`}, 1) ; simplify(1) ; andR(1) ; <(
              QE,
              QE
              )
            )
          ),
        composed(1) ; testd(1) ; andR(1) ; <(
          composed(2) ; testd(2) ; andR(2) ; <(
            QE,
            choiced(2) ; orR(2) ; composed(2) ; testd(2) ; orL(-8) ; <(
              composed(3) ; testd(3) ; andR(2) ; <(
                andR(3) ; <(
                  QE,
                  choiced(3) ; orR(3) ; hideR(3) ; composed(3) ; testd(3) ; fullSimplify ; choiced(3) ; orR(3) ; hideR(3) ; composed(3) ; testd(3) ; fullSimplify ; choiced(3) ; orR(3) ; choiced(4) ; orR(4) ; composed(4) ; testd(4) ; hideR(3) ; hideR(4) ; simplify(3) ; assignd(3) ; assignd(3) ; existsR({`ep()`}, 3) ; fullSimplify ; existsR({`n`}, 3) ; simplify(3) ; QE
                  ),
                andR(3) ; <(
                  composed(2) ; randomd(2) ; existsR({`0`}, 2) ; testd(2) ; andR(2) ; <(
                    QE,
                    assignd(2) ; existsR({`ep()`}, 2) ; fullSimplify ; existsR({`n`}, 2) ; fullSimplify ; QE
                    ),
                  choiced(3) ; orR(3) ; hideR(3) ; composed(3) ; testd(3) ; fullSimplify ; choiced(3) ; orR(3) ; hideR(3) ; composed(3) ; testd(3) ; fullSimplify ; choiced(3) ; orR(3) ; choiced(4) ; orR(4) ; hideR(5) ; hideR(3) ; composed(3) ; testd(3) ; fullSimplify ; assignd(3) ; assignd(3) ; existsR({`ep()`}, 3) ; hideR(2) ; fullSimplify ; existsR({`n`}, 2) ; fullSimplify ; QE
                  )
                ),
              simplify(2) ; hideR(3) ; fullSimplify ; composed(2) ; randomd(2) ; existsR({`0`}, 2) ; testd(2) ; andR(2) ; <(
                QE,
                assignd(2) ; existsR({`ep()`}, 2) ; simplify(2) ; andR(2) ; <(
                  QE,
                  existsR({`n`}, 2) ; simplify(2) ; QE
                  )
                )
              )
            ),
          orL(-8) ; <(
            composed(2) ; testd(2) ; andR(2) ; <(
              assignd(1) ; assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; andR(1) ; <(
                QE,
                andR(1) ; <(
                  QE,
                  existsR({`n`}, 1) ; simplify(1) ; QE
                  )
                ),
              choiced(2) ; orR(2) ; composed(2) ; testd(2) ; andR(2) ; <(
                composed(3) ; testd(3) ; andR(3) ; <(
                  hideR(1) ; QE,
                  choiced(3) ; orR(3) ; hideR(3) ; composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ; hideR(3) ; composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ; hideR(3) ; choiced(3) ; orR(3) ; hideR(4) ; composed(3) ; testd(3) ; simplify(3) ; assignd(3) ; assignd(3) ; existsR({`ep()`}, 3) ; simplify(3) ; existsR({`n`}, 3) ; assignd(1) ; assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; simplify(3) ; andR(1) ; <(
                    hideR(3) ; QE,
                    andR(1) ; <(
                      QE,
                      existsR({`n`}, 1) ; hideR(3) ; simplify(1) ; QE
                      )
                    )
                  ),
                hideR(1) ; composed(1) ; randomd(1) ; composed(2) ; testd(2) ; andR(2) ; <(
                  existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
                    QE,
                    assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; andR(1) ; <(
                      QE,
                      andR(1) ; <(
                        QE,
                        existsR({`n`}, 1) ; simplify(1) ; QE
                        )
                      )
                    ),
                  choiced(2) ; existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
                    hideR(2) ; QE,
                    assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; andR(1) ; <(
                      hideR(2) ; QE,
                      andR(1) ; <(
                        orR(2) ; hideR(2) ; composed(2) ; testd(2) ; simplify(2) ; choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; simplify(2) ; choiced(2) ; orR(2) ; hideR(2) ; choiced(2) ; orR(2) ; hideR(3) ; composed(2) ; testd(2) ; simplify(2) ; assignd(2) ; assignd(2) ; existsR({`ep()`}, 2) ; simplify(2) ; existsR({`n`}, 2) ; simplify(2) ; QE,
                        hideR(2) ; existsR({`n`}, 1) ; simplify(1) ; QE
                        )
                      )
                    )
                  )
                )
              ),
            hideR(2) ; assignd(1) ; assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; andR(1) ; <(
              QE,
              andR(1) ; <(
                QE,
                existsR({`n`}, 1) ; simplify(1) ; QE
                )
              )
            )
          )
        )
      ),
    QE
    )
  )
End.

Tactic "Proof Theorem 15: Cross intersection with deadline (loop split and unroll)".
/* Some of the QE need QE({`Mathematica`}) */
implyR(1) ; andL('L)* ; andR(1) ; <(
  boxAnd(1) ; andR(1) ; <(
    loop({`0<=vr&Vmin()<=vo&(xr>0|xo>0|xr+vr^2/(2*b()) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr))`}, 1) ; <(
      QE,
      QE,
      boxAnd(1) ; andR(1) ; <(
        composeb(1) ; composeb(1.1) ; GV(1) ; GV(1.0) ; unfold ; dW(1) ; QE,
        boxAnd(1) ; andR(1) ; <(
          composeb(1) ; composeb(1.1) ; GV(1) ; GV(1.0) ; unfold ; dW(1) ; QE,
          notGreater(1.0.1.0.0.1.0.0) ; notGreater(1.0.1.0.0.1.1.1.0.0) ; notAnd(1.0.1.0.0.1.1.1.1.1.0.0) ; notAnd(1.0.1.0.0.1.1.1.1.1.1.1.0.0) ; notGreater(1.0.1.0.0.1.1.1.1.1.0.0.0) ; notOr(1.0.1.0.0.1.1.1.1.1.0.0.1) ; notLess(1.0.1.0.0.1.1.1.1.1.0.0.1.0) ; notLess(1.0.1.0.0.1.1.1.1.1.0.0.1.1) ; notGreater(1.0.1.0.0.1.1.1.1.1.1.1.0.0.0) ; notLess(1.0.1.0.0.1.1.1.1.1.1.1.0.0.1) ; unfold ; <(
            dC({`xo>=old(xo)`}, 1) ; <(
              dW(1) ; QE,
              dI(1)
              ),
            dC({`xr>=old(xr)`}, 1) ; <(
              dW(1) ; QE,
              dI(1)
              ),
            fullSimplify ; hideL(-5) ; dC({`t>=0&vr=old(vr)+ar*t&vo=old(vo)+ao*t`}, 1) ; <(
              dC({`xr=old(xr)+old(vr)*t+ar*t^2/2&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                dW(1) ; implyR(1) ; orR(1) ; orR(2) ; orR(3) ; hideL(-6) ; andR(4) ; <(
                  QE,
                  orR(4) ; andL('L)* ; orL(-11) ; <(
                    hideL(-16) ; hideL(-3) ; hideR(3) ; hideR(4) ; edit({`vr_0<=vr&vr<=vr_0+A()*t`}, -18) ; edit({`xr_0+vr_0*t<=xr&xr<=xr_0+vr_0*t+A()*t^2/2`}, -13) ; edit({`xo_0+Vmin()*t<=xo&xo<=xo_0+vo_0*t+A()*t^2/2`}, -14) ; edit({`vo<=vo_0+A()*t`}, -19) ; hideL(-5) ; hideL(-5) ; hideL(-9) ; hideL(-9) ; hideL(-2) ; andL('L)* ; hideL(-14) ; edit({`vo>0`}, -10) ; edit({`vo_0>0`}, -3) ; hideL(-2) ; hideL(-15) ; hideL(-12) ; QE,
                    edit({`0 < xo_0+Vmin()*(-xr_0)/(vr_0+A()*t)`}, -11) ; hideL(-3) ; hideL(-15) ; hideR(4) ; hideR(3) ; hideL(-5) ; hideL(-2) ; edit({`!xr<=0`}, 1) ; edit({`!xo<=0`}, 2) ; notR(1) ; notR(1) ; edit({`vr_0<=vr&vr<=vr_0+A()*t`}, -16) ; edit({`xr_0+vr_0*t<=xr&xr<=xr_0+vr_0*t+A()*t^2/2`}, -11) ; edit({`xo_0+Vmin()*t<=xo&xo<=xo_0+vo_0*t+A()*t^2/2`}, -12) ; edit({`vo<=vo_0+A()*t`}, -17) ; hideL(-4) ; hideL(-8) ; hideL(-8) ; andL('L)* ; hideL(-17) ; edit({`0 < vr`}, -17) ; hideL(-14) ; hideL(-10) ; hideL(-10) ; hideL(-3) ; QE
                    )
                  ),
                dI(1)
                ),
              dI(1)
              ),
            fullSimplify ; andL(-12) ; fullSimplify ; dC({`t>=0&vr=old(vr)&vo=old(vo)+ao*t`}, 1) ; <(
              dC({`xr=old(xr)+old(vr)*t&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                dW(1) ; implyR(1) ; orR(1) ; orR(2) ; orR(3) ; hideR(1) ; hideR(1) ; hideR(1) ; andR(1) ; <(
                  QE,
                  orR(1) ; hideR(1) ; hideL(-13) ; QE
                  ),
                dI(1)
                ),
              dI(1)
              ),
            fullSimplify ; orL(-8) ; <(
              dC({`t>=0&vr=old(vr)-b()*t`}, 1) ; <(
                dC({`xr=old(xr)+old(vr)*t-b()*t^2/2`}, 1) ; <(
                  dW(1) ; QE,
                  dI(1)
                  ),
                dI(1)
                ),
              andL(-8) ; fullSimplify ; hideR(1) ; QE
              ),
            hideL(-14) ; hideL(-13) ; dC({`vr=old(vr)`}, 1) ; <(
              dC({`xr=old(xr)`}, 1) ; <(
                orL(-8) ; <(
                  hideR(1) ; QE,
                  orL(-8) ; <(
                    hideR(1) ; QE,
                    orL(-8) ; <(
                      dW(1) ; QE,
                      hideR(1) ; QE
                      )
                    )
                  ),
                dI(1)
                ),
              dI(1)
              ),
            hideL(-13) ; hideL(-13) ; hideL(-8) ; dC({`t>=0&vr=old(vr)+A()*t`}, 1) ; <(
              dC({`xr=old(xr)+old(vr)*t+A()*t^2/2`}, 1) ; <(
                dW(1) ; implyR(1) ; orR(1) ; orR(2) ; orR(3) ; hideR(4) ; hideR(1) ; hideR(1) ; smartQE,
                dI(1)
                ),
              dI(1)
              )
            )
          )
        )
      ),
    loop({`0<=vr&Vmin()<=vo&T<=(xo-0)/Vmin()&(T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max((0,D()-T))+A()/2*max((0,D()-T))^2>0)`}, 1) ; <(
      QE,
      QE,
      notAnd(1.0.1.0.0.1.1.1.1.1.0.0) ; notGreater(1.0.1.0.0.1.1.1.1.1.0.0.0) ; notGreater(1.0.1.0.0.1.0.0) ; notGreater(1.0.1.0.0.1.1.1.0.0) ; notOr(1.0.1.0.0.1.1.1.1.1.0.0.1) ; notLess(1.0.1.0.0.1.1.1.1.1.0.0.1.0) ; notLess(1.0.1.0.0.1.1.1.1.1.0.0.1.1) ; notAnd(1.0.1.0.0.1.1.1.1.1.1.1.0.0) ; notGreater(1.0.1.0.0.1.1.1.1.1.1.1.0.0.0) ; notLess(1.0.1.0.0.1.1.1.1.1.1.1.0.0.1) ; boxAnd(1) ; andR(1) ; <(
        composeb(1) ; composeb(1.1) ; GV(1) ; GV(1.0) ; allR(1) ; allR(1) ; allR(1) ; dW(1) ; QE,
        boxAnd(1) ; andR(1) ; <(
          composeb(1) ; composeb(1.1) ; GV(1) ; GV(1.0) ; allR(1) ; allR(1) ; allR(1) ; dW(1) ; QE,
          boxAnd(1) ; andR(1) ; <(
            composeb(1) ; composeb(1.1) ; composeb(1.1) ; GV(1.1) ; unfold ; dC({`t>=0&T=old(T)+t&vo=old(vo)+ao*t`}, 1) ; <(
              dC({`xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                dW(1) ; QE,
                dI(1)
                ),
              dI(1)
              ),
            unfold ; <(
              dC({`t>=0&T=old(T)+t&vr=old(vr)+A()*t`}, 1) ; <(
                dC({`xr=old(xr)+old(vr)*t+A()*t^2/2`}, 1) ; <(
                  dW(1) ; implyR(1) ; orR(1) ; QE,
                  dI(1)
                  ),
                dI(1)
                ),
              orL(-9) ; <(
                dC({`t>=0&T=old(T)+t&vr=old(vr)+ar*t&vo=old(vo)+ao*t`}, 1) ; <(
                  dC({`xr=old(xr)+old(vr)*t+ar*t^2/2&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                    dW(1) ; implyR(1) ; orR(1) ; edit({`T>0&xr+vr*abbrv(max((0,D()-T)))+A()/2*max((0,D()-T))^2>0`}, 2) ; edit({`abbrv=expand(max((0,D()-T)))`}, -17) ; orL(-18) ; <(
                      andR(1) ; <(
                        andR(2) ; <(
                          QE,
                          smartQE
                          ),
                        andR(2) ; <(
                          smartQE,
                          smartQE
                          )
                        ),
                      andR(1) ; <(
                        andR(2) ; <(
                          QE,
                          smartQE
                          ),
                        andR(2) ; <(
                          smartQE,
                          smartQE
                          )
                        )
                      ),
                    dI(1)
                    ),
                  dI(1)
                  ),
                hideR(1) ; QE
                ),
              dC({`t>=0&T=old(T)+t&vr>=old(vr)&vo=old(vo)+ao*t`}, 1) ; <(
                dC({`xr>=old(xr)+old(vr)*t&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                  dW(1) ; hideL(-15) ; implyR(1) ; orR(1) ; edit({`T>0&xr+vr*abbrv(max((0,D()-T)))+A()/2*max((0,D()-T))^2>0`}, 2) ; edit({`abbrv=expand(max((0,D()-T)))`}, -18) ; andR(1) ; <(
                    andR(2) ; <(
                      QE,
                      orL(-9) ; <(
                        orL(-19) ; <(
                          smartQE,
                          smartQE
                          ),
                        hideR(1) ; hideR(1) ; QE
                        )
                      ),
                    orL(-9) ; <(
                      andR(2) ; <(
                        orL(-19) ; <(
                          smartQE,
                          smartQE
                          ),
                        orL(-19) ; <(
                          smartQE,
                          smartQE
                          )
                        ),
                      hideR(1) ; hideR(1) ; QE
                      )
                    ),
                  dI(1)
                  ),
                dI(1)
                ),
              dC({`t>=0&T=old(T)+t&vr=old(vr)&vo=old(vo)+ao*t`}, 1) ; <(
                dC({`xr=old(xr)+old(vr)*t&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                  dW(1) ; implyR(1) ; orR(1) ; andR(1) ; <(
                    andR(2) ; <(
                      QE,
                      edit({`xr+vr*abbrv(max((0,D()-T)))+A()/2*max((0,D()-T))^2>0`}, 2) ; edit({`abbrv=expand(max((0,D()-T)))`}, -18) ; orL(-19) ; <(
                        orL(-9) ; <(
                          hideL(-14) ; smartQE,
                          hideL(-14) ; smartQE
                          ),
                        hideL(-14) ; orL(-9) ; <(
                          smartQE,
                          smartQE
                          )
                        )
                      ),
                    andR(2) ; <(
                      smartQE,
                      smartQE
                      )
                    ),
                  dI(1)
                  ),
                dI(1)
                ),
              dC({`t>=0&T=old(T)+t&vr=old(vr)-b()*t&vo=old(vo)+ao*t`}, 1) ; <(
                dC({`xr=old(xr)+old(vr)*t-b()*t^2/2&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                  dW(1) ; implyR(1) ; orR(1) ; hideL(-15) ; hideL(-14) ; orL(-9) ; <(
                    andR(1) ; <(
                      andR(2) ; <(
                        QE,
                        edit({`xr+vr*abbrv(max((0,D()-T)))+A()/2*max((0,D()-T))^2>0`}, 2) ; edit({`abbrv=expand(max((0,D()-T)))`}, -15) ; orL(-16) ; <(
                          QE,
                          QE
                          )
                        ),
                      edit({`T>0&xr+vr*abbrv(max((0,D()-T)))+A()/2*max((0,D()-T))^2>0`}, 2) ; edit({`abbrv=expand(max((0,D()-T)))`}, -15) ; orL(-16) ; <(
                        QE,
                        andR(2) ; <(
                          smartQE,
                          smartQE
                          )
                        )
                      ),
                    hideR(1) ; andR(1) ; <(
                      QE,
                      QE
                      )
                    ),
                  dI(1)
                  ),
                dI(1)
                ),
              dC({`t>=0&T=old(T)+t&vr=old(vr)`}, 1) ; <(
                dC({`xr=old(xr)+old(vr)*t`}, 1) ; <(
                  dC({`vo=old(vo)+ao*t`}, 1) ; <(
                    dC({`xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ; <(
                      dW(1) ; implyR(1) ; orR(1) ; QE,
                      dI(1)
                      ),
                    dI(1)
                    ),
                  dI(1)
                  ),
                dI(1)
                ),
              dC({`t>=0&T=old(T)+t&vr=old(vr)+A()*t`}, 1) ; <(
                dC({`xr=old(xr)+old(vr)*t+A()*t^2/2`}, 1) ; <(
                  dW(1) ; hideL(-11) ; QE,
                  dI(1)
                  ),
                dI(1)
                )
              )
            )
          )
        )
      )
    ),
  useAt({`<*> merge`}, {`1`}, 1) ; con({`A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+v*ep()*Vmin()>0`}, 1) ; <(
    QE,
    composed(1) ; composed(1.1) ; solve(1.1.1) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
      QE,
      composed(1) ; andL('L)* ; choiced(1) ; orR(1) ; composed(1) ; testd(1) ; orL(-8) ; <(
        simplify(1) ; hideR(2) ; assignd(1) ; assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; QE,
        composed(2) ; testd(2) ; andR(1) ; <(
          andR(2) ; <(
            QE,
            choiced(2) ; orR(2) ; composed(3) ; testd(3) ; composed(2) ; testd(2) ; andR(2) ; <(
              andR(3) ; <(
                QE,
                choiced(3) ; orR(3) ; hideR(3) ; composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ; hideR(3) ; composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ; hideR(3) ; choiced(3) ; orR(3) ; hideR(4) ; composed(3) ; testd(3) ; simplify(3) ; assignd(3) ; assignd(3) ; existsR({`ep()`}, 3) ; simplify(3) ; QE
                ),
              hideR(3) ; composed(2) ; randomd(2) ; existsR({`0`}, 2) ; testd(2) ; andR(2) ; <(
                QE,
                assignd(2) ; existsR({`ep()`}, 2) ; simplify(2) ; QE
                )
              )
            ),
          andR(2) ; <(
            notR(2) ; assignd(1) ; assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; QE,
            choiced(2) ; orR(2) ; composed(2) ; testd(2) ; andR(2) ; <(
              composed(3) ; hideR(1) ; testd(2) ; andR(2) ; <(
                prop,
                choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; simplify(2) ; choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; simplify(2) ; choiced(2) ; orR(2) ; hideR(2) ; choiced(2) ; orR(2) ; hideR(3) ; composed(2) ; testd(2) ; simplify(2) ; assignd(2) ; assignd(2) ; existsR({`ep()`}, 2) ; simplify(2) ; QE
                ),
              hideR(1) ; hideR(2) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
                QE,
                assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; QE
                )
              )
            )
          )
        )
      ),
    andL('L)* ; iterated(1) ; orR(1) ; edit({`xo>0`}, -9) ; fullSimplify ; composed(2) ; composed(2) ; randomd(2) ; existsR({`0`}, 2) ; testd(2) ; hideL(-1) ; andR(2) ; <(
      QE,
      composed(2) ; composed(2) ; choiced(2) ; orR(2) ; hideR(3) ; composed(2) ; testd(2) ; simplify(2) ; assignd(2) ; assignd(2) ; allR(2) ; implyR(2) ; solve(2) ; existsR({`ep()`}, 2) ; simplify(2) ; andR(2) ; <(
        QE,
        print({`Solved`}); existsR({`ep()+T_1`}, 2) ; simplify(2) ; existsR({`vo_1+0`}, 2) ; fullSimplify ; existsR({`A()*ep()+vr_1`}, 2) ; simplify(2) ; existsR({`vo_1*ep()+xo_1`}, 2) ; simplify(2) ; existsR({`A()/2*ep()^2+vr_1*ep()+xr_1`}, 2) ; simplify(2) ; hideL('L=={`T=ep()+T_1`}) ; edit({`vr>=A()*ep()`}, 'L=={`vr=A()*ep()+vr_1`}) ; edit({`xo>0`}, 'L=={`xo=vo_1*ep()+xo_1`}) ; edit({`xr>=xr_1`}, 'L=={`xr=A()/2*ep()^2+vr_1*ep()+xr_1`}) ; hideL('L=={`vr_1>=0`}) ; con({`A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&xo>0&vr>=A()*ep()&xr+v*ep()*(A()*ep())>0`}, 2) ; <(
          QE,
          andL('L)* ; composed(1) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
            QE,
            composed(1) ; solve(1.1) ; composed(1) ; choiced(1) ; orR(1) ; hideR(2) ; composed(1) ; testd(1) ; simplify(1) ; assignd(1) ; assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; QE
            ),
          QE
          )
        )
      )
    )
  )
End.

End.

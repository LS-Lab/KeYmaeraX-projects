Theorem "IJRR17/Theorem 1: Static safety".

Definitions
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real W;       /* maximum steering */

  Real stopDist(Real v) = v^2 / (2*b);             /* The straight-line stopping distance from brake start to full stop. */
  Real accelComp(Real v) = ((A/b + 1) * (A/2 * ep^2 + ep*v));       /* Straight-line distance to compensate acceleration */
  Real admissibleSeparation(Real v) = stopDist(v) + accelComp(v);  /* Separation that allows accelerating on a new curve */

  Bool isWellformedDir(Real dx, Real dy) <-> dx^2 + dy^2 = 1;          /* The orientation of the robot is a unit vector. */

  Bool bounds() <-> (                                                                     /* Bounds for global constants */
      A >= 0                                                                                           /* Working engine */
    & b > 0                                                                                            /* Working brakes */
    & ep > 0                                                                                 /* Controller reaction time */
  );
  Bool initialState(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (          /* Stopped safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir(dx, dy)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <->
    bounds() & initialState(x, y, v, dx, dy, xo, yo);

  /* Conditions that are true on each loop iteration */
  Bool loopinv(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v >= 0
    & isWellformedDir(dx, dy)
    & (abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  );
End.

ProgramVariables
  Real x;    /* robot position: x */
  Real y;    /* robot position: y */
  Real v;    /* robot translational velocity */
  Real a;    /* robot translational acceleration */
  Real dx;   /* robot orientation: x */
  Real dy;   /* robot orientation: y */
  Real w;    /* robot rotational velocity */
  Real r;    /* robot curve radius */
  Real xo;   /* position of closest obstacle on curve */
  Real yo;
  Real t;    /* time */
End.

Problem
assumptions(x, y, v, dx, dy, xo, yo) ->
  [
    {
      {
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
          ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
        t := 0;
      }

      /* dynamics */
      {
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        t' = 1 & t <= ep & v >= 0
      }@invariant(t>=0, isWellformedDir(dx, dy),
         (v'=-b -> v = old(v) - b*t),
         (v'=-b -> (-t * (old(v) - b/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - b/2*t))),
         (v'=-b -> (-t * (old(v) - b/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - b/2*t))),
         (v'=0 -> v = old(v)),
         (v'=0 -> x = old(x)),
         (v'=0 -> y = old(y)),
         (v'=A -> v = old(v) + A*t),
         (v'=A -> (-t * (old(v) + A/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A/2*t))),
         (v'=A -> (-t * (old(v) + A/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A/2*t)))
       )
      }
    }*@invariant(loopinv(x, y, v, dx, dy, xo, yo))
  ](x - xo)^2 + (y - yo)^2 > 0
End.

Tactic "Proof Theorem 1: Static safety"
  tactic diall as (
    diffInvariant("t>=0", 1);
    diffInvariant("isWellformedDir(dx, dy)", 1)
  );

  tactic dib as (
    diall;
    diffInvariant("v = old(v) - b*t", 1);
    diffInvariant("-t * (v + b/2*t) <= x - old(x) & x - old(x) <= t * (v + b/2*t)", 1);
    diffInvariant("-t * (v + b/2*t) <= y - old(y) & y - old(y) <= t * (v + b/2*t)", 1)
  );

  tactic di0 as (
    diall;
    diffInvariant("v = old(v)", 1);
    diffInvariant("x = old(x)", 1);
    diffInvariant("y = old(y)", 1)
  );

  tactic dia as (
    diall;
    diffInvariant("v = old(v) + A*t", 1);
    diffInvariant("-t * (v - A/2*t) <= x - old(x) & x - old(x) <= t * (v - A/2*t)", 1);
    diffInvariant("-t * (v - A/2*t) <= y - old(y) & y - old(y) <= t * (v - A/2*t)", 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print("Transforming...");
    transform("abs(x_0-xo)>v_0^2/(2*b)+(A/b+1)*(A/2*t^2+t*v_0)", 'L=="abs(x_0-xo)>admissibleSeparation(v_0)");
    hideR('R=="abs(y-yo)>stopDist(v)");
    smartQE;
    print("Proved acc arithmetic")
  );

  tactic yAccArith as (
    andL('L)*;
    print("Transforming...");
    transform("abs(y_0-yo)>v_0^2/(2*b)+(A/b+1)*(A/2*t^2+t*v_0)", 'L=="abs(y_0-yo)>admissibleSeparation(v_0)");
    hideR('R=="abs(x-xo)>stopDist(v)");
    smartQE;
    print("Proved acc arithmetic")
  );

  implyR(1); andL('L)*; loop("loopinv(x, y, v, dx, dy, xo, yo)", 1); <(
    "Init": print("Base case..."); smartQE; print("Base case done")
    ,
    "Post": print("Use case..."); smartQE; print("Use case done")
    ,
    "Step": print("Induction step"); unfold; <(
      "[a:=-b();][t:=0;][{x'=v*dx,y'=v*dy,v'=a,dx'=-w*dy,dy'=w*dx,w'=a/r,t'=1&t<=ep()&v>=0}]loopinv(x,y,v,dx,dy,xo,yo)":
        print("Braking branch"); dib; dw; prop; doall(smartQE); print("Braking branch done")
      ,
      "[?v=0;a:=0;w:=0;][t:=0;][{x'=v*dx,y'=v*dy,v'=a,dx'=-w*dy,dy'=w*dx,w'=a/r,t'=1&t<=ep()&v>=0}]loopinv(x,y,v,dx,dy,xo,yo)":
        print("Stopped branch"); di0; dw; prop; doall(smartQE); print("Stopped branch done")
      ,
      "[a:=A();w:=*;?-W()<=w&w<=W();r:=*;xo:=*;yo:=*;?r!=0&r*w=v;?abs(x-xo)>admissibleSeparation(v)|abs(y-yo)>admissibleSeparation(v);][t:=0;][{x'=v*dx,y'=v*dy,v'=a,dx'=-w*dy,dy'=w*dx,w'=a/r,t'=1&t<=ep()&v>=0}]loopinv(x,y,v,dx,dy,xo,yo)":
        expand "loopinv";
        andL('L)*;
        hideL('L == "abs(x-xo_0)>stopDist(v)|abs(y-yo_0)>stopDist(v)");
        dia; dw;
        prop; <(
          xAccArith,
          yAccArith
        );
        print("Acceleration branch done")
    );
    print("Induction step done")
  );
  done;
  print("Proof done")

End.

Tactic "Proof Theorem 1: Static safety from annotations"
  auto
End.

End.

ArchiveEntry "IJRR17/Corollary 1.1: Velocity-controlled passive safety".

Definitions
  Real ep;      /* time limit for control decisions */
  Real W;       /* maximum steering */
  Real V;       /* maximum obstacle velocity */

  Real stopDist(Real v) = 0;
  Real accelComp(Real v) = ep*(v+V);
  Real admissibleSeparation(Real v) = stopDist(v) + accelComp(v);

  Bool isWellformedDir(Real dx, Real dy) <-> dx^2 + dy^2 = 1;                        /* The orientation of the robot is a unit vector. */

  Bool bounds() <-> (                                                                     /* Bounds for global constants */
      ep > 0                                                                            /* Controller reaction time */
    & V >= 0
  );

  /* Stopped somewhere safe initially */
  Bool initialState(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir(dx,dy)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <->
    bounds() & initialState(x,y,v,dx,dy,xo,yo);

  /* Conditions that are true on each loop iteration */
  Bool loopinv(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v >= 0
    & isWellformedDir(dx,dy)
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  );
End.

ProgramVariables
  Real x;    /* robot position: x */
  Real y;    /* robot position: y */
  Real v;    /* robot translational velocity */
  Real a;    /* robot translational acceleration */
  Real dx;   /* robot orientation: x */
  Real dy;   /* robot orientation: y */
  Real w;    /* robot rotational velocity */
  Real r;    /* robot curve radius */
  Real xo;   /* position of closest obstacle on curve */
  Real yo;
  Real vxo;  /* velocity vector of obstacle */
  Real vyo;
  Real t;    /* time */
End.

Problem
assumptions(x, y, v, dx, dy, xo, yo) ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { v := 0; w := 0; }
          ++
          /* or choose a new safe curve */
          { v := *; ?0<=v;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
        t := 0;
      }

      /* dynamics */
      {
      { x' = v * dx, y' = v * dy,                /* move */
        dx' = -w * dy, dy' = w * dx,             /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }@invariant(t>=0, isWellformedDir(dx,dy),
        (-t*V <= xo - old(xo) & xo - old(xo) <= t*V),
        (-t*V <= yo - old(yo) & yo - old(yo) <= t*V),
        (x'=0*dx -> x = old(x)),
        (x'=0*dx -> y = old(y)),
        (x'=v*dx -> -t * v <= x - old(x) & x - old(x) <= t * v),
        (x'=v*dx -> -t * v <= y - old(y) & y - old(y) <= t * v)
      )
      }
    }*@invariant(loopinv(x, y, v, dx, dy, xo, yo))
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Corollary 1: Velocity-controlled passive safety".
  tactic diall as (
    diffInvariant("t>=0", 1);
    diffInvariant("isWellformedDir(dx,dy)", 1);
    diffInvariant("-t*V <= xo - old(xo) & xo - old(xo) <= t*V", 1);
    diffInvariant("-t*V <= yo - old(yo) & yo - old(yo) <= t*V", 1)
  );

  tactic di0 as (
    diall;
    diffInvariant("x = old(x)", 1);
    diffInvariant("y = old(y)", 1)
  );

  tactic dia as (
    diall;
    diffInvariant("-t * v <= x - old(x) & x - old(x) <= t * v", 1);
    diffInvariant("-t * v <= y - old(y) & y - old(y) <= t * v", 1)
  );

  tactic dw as (andL('L)*; dW(1));

  implyR(1); andL('L)*; loop("loopinv(x, y, v, dx, dy, xo, yo)", 1); <(
    print("Base case..."); smartQE; print("Base case done")
    ,
    print("Use case..."); smartQE; print("Use case done")
    ,
    print("Induction step"); unfold; <(
      print("Stopped branch"); di0; dw; prop; doall(smartQE); print("Stopped branch done")
      ,
      print("Acceleration branch");
      hideL('L == "v_0>0 -> abs(x-xo_0)>stopDist(v_0) | abs(y-yo_0)>stopDist(v_0)");
      dia; dw; prop; doall(smartQE); print("Acceleration branch done")
    );
    print("Induction step done")
  );
  done;
  print("Proof done")

End.

End.

Theorem "IJRR17/Corollary 1.2: Static safety with margin for imperfect trajectories".

Definitions
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real W;       /* maximum steering */
  Real Ud;      /* direction uncertainty */

  Real stopDist(Real v) = ((1+Ud) * v^2 / (2*b));     /* The straight-line stopping distance from brake start to full stop. */
  Real accelComp(Real v) = ((1+Ud) * (A/b + 1) * (A/2 * ep^2 + ep*v)); /* Straight-line distance to compensate acceleration */
  Real admissibleSeparation(Real v) = stopDist(v) + accelComp(v);     /* Separation that allows accelerating on a new curve */

  /* The orientation of the robot is approximately a unit vector. */
  Bool isWellformedDir(Real dx, Real dy) <-> (1-Ud <= dx^2+dy^2 & dx^2 + dy^2 <= 1+Ud);

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A >= 0                                                                                        /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & 0<=Ud & Ud <= 1
  );

  /* Stopped somewhere safe initially */
  Bool initialState(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir(dx,dy)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <->
    bounds() & initialState(x, y, v, dx, dy, xo, yo);

  /* Conditions that are true on each loop iteration */
  Bool loopinv(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v >= 0
    & isWellformedDir(dx,dy)
    & (abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  );
End.

ProgramVariables
  Real x;    /* robot position: x */
  Real y;    /* robot position: y */
  Real v;    /* robot translational velocity */
  Real a;    /* robot translational acceleration */
  Real dx;   /* robot orientation: x */
  Real dy;   /* robot orientation: y */
  Real w;    /* robot rotational velocity */
  Real r;    /* robot curve radius */
  Real xo;   /* position of closest obstacle on curve */
  Real yo;
  Real t;    /* time */
End.

Problem
assumptions(x, y, v, dx, dy, xo, yo) ->
  [
    {
      {
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
          ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
        t := 0;
      }

      /* dynamics */
      {
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        t' = 1 & t <= ep & v >= 0
      }@invariant(t>=0, isWellformedDir(dx,dy),
         (v'=-b -> v <= old(v) - b*t),
         (v'=-b -> (-t * (old(v) - b/2*t) * (1+Ud) <= x - old(x) & x - old(x) <= t * (old(v) - b/2*t) * (1+Ud))),
         (v'=-b -> (-t * (old(v) - b/2*t) * (1+Ud) <= y - old(y) & y - old(y) <= t * (old(v) - b/2*t) * (1+Ud))),
         (v'=0 -> v = old(v)),
         (v'=0 -> x = old(x)),
         (v'=0 -> y = old(y)),
         (v'=A -> v <= old(v) + A*t),
         (v'=A -> (-t * (old(v) + A/2*t) * (1+Ud) <= x - old(x) & x - old(x) <= t * (old(v) + A/2*t) * (1+Ud))),
         (v'=A -> (-t * (old(v) + A/2*t) * (1+Ud) <= y - old(y) & y - old(y) <= t * (old(v) + A/2*t) * (1+Ud)))
       )
      }
    }*@invariant(loopinv(x, y, v, dx, dy, xo, yo))
  ](x - xo)^2 + (y - yo)^2 > 0
End.

Tactic "Proof Theorem 1: Static safety"
  tactic diall as (
    diffInvariant("t>=0", 1);
    diffInvariant("isWellformedDir(dx,dy)", 1)
  );

  tactic diHide as (
    hideL('L~="abs(x-xo)>stopDist(v)|abs(y-yo)>stopDist(v)");
    hideL('L~="1-Ud<=dx^2+dy^2");
    hideL('L~="dx^2+dy^2<=1+Ud")
  );

  tactic dib as (
    diall;
    dC("v <= old(v) - b*t", 1); <(nil, diHide; dI(1));
    dC("(-t * (old(v) - b/2*t) * (1+Ud) <= x - old(x) & x - old(x) <= t * (old(v) - b/2*t) * (1+Ud))
       & (-t * (old(v) - b/2*t) * (1+Ud) <= y - old(y) & y - old(y) <= t * (old(v) - b/2*t) * (1+Ud))", 1); <(nil, diHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic di0 as (
    diall;
    dC("v = old(v)", 1); <(nil, diHide; dI(1));
    dC("x = old(x)", 1); <(nil, diHide; dI(1));
    dC("y = old(y)", 1); <(nil, diHide; dI(1))
  );

  tactic diaHide as (
    hideL('L~="abs(x-xo)>admissibleSeparation(v)|abs(y-yo)>admissibleSeparation(v)");
    hideL('L~="1-Ud<=dx^2+dy^2");
    hideL('L~="dx^2+dy^2<=1+Ud")
  );

  tactic dia as (
    diall;
    dC("v <= old(v) + A*t", 1); <(nil, diaHide; dI(1));
    dC("(-t * (old(v) + A/2*t) * (1+Ud) <= x - old(x) & x - old(x) <= t * (old(v) + A/2*t) * (1+Ud))
       & (-t * (old(v) + A/2*t) * (1+Ud) <= y - old(y) & y - old(y) <= t * (old(v) + A/2*t) * (1+Ud))", 1); <(nil, diaHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic dw as (andL('L)*; dW(1));

  tactic qeHide as (
    hideL('L~="1-Ud<=dx^2+dy^2")*;
    hideL('L~="dx^2+dy^2<=1+Ud")*
  );

  tactic xAccArith as (
    andL('L)*;
    print("Transforming...");
    transform("abs(x_0-xo)>(1+Ud)*(v_0^2/(2*b)+(A/b+1)*(A/2*t^2+t*v_0))", 'L=="abs(x_0-xo)>admissibleSeparation(v_0)");
    hideR('R=="abs(y-yo)>stopDist(v)");
    qeHide;
    smartQE;
    print("Proved acc arithmetic")
  );

  tactic yAccArith as (
    andL('L)*;
    print("Transforming...");
    transform("abs(y_0-yo)>(1+Ud)*(v_0^2/(2*b)+(A/b+1)*(A/2*t^2+t*v_0))", 'L=="abs(y_0-yo)>admissibleSeparation(v_0)");
    hideR('R=="abs(x-xo)>stopDist(v)");
    qeHide;
    smartQE;
    print("Proved acc arithmetic")
  );

  implyR(1); andL('L)*; loop("loopinv(x, y, v, dx, dy, xo, yo)", 1); <(
    print("Base case..."); smartQE; print("Base case done")
    ,
    print("Use case..."); smartQE; print("Use case done")
    ,
    print("Induction step"); unfold; <(
      print("Braking branch"); dib; dw; prop; doall(qeHide; smartQE); print("Braking branch done")
      ,
      print("Stopped branch"); di0; dw; prop; doall(qeHide; smartQE); print("Stopped branch done")
      ,
      print("Acceleration branch");
      hideL('L == "abs(x-xo_0)>stopDist(v)|abs(y-yo_0)>stopDist(v)");
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print("Acceleration branch done")
    );
    print("Induction step done")
  );
  done;
  print("Proof done")

End.

End.

Theorem "IJRR17/Corollary 1.3: Static safety with margin for imperfect trajectories (no division)".

Definitions
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real W;       /* maximum steering */
  Real Ud;      /* direction uncertainty */

  Real stopDist(Real v) = ((1+Ud) * v^2);            /* The straight-line stopping distance from brake start to full stop. */
  Real accelComp(Real v, Real t) = ((1+Ud) * (A + b) * (A * t^2 + 2*t*v)); /* Straight-line distance to compensate acceleration */
  Real admissibleSeparation(Real v, Real t) = (stopDist(v) + accelComp(v,t));   /* Separation that allows accelerating on a new curve */

  /* The orientation of the robot is approximately a unit vector. */
  Bool isWellformedDir(Real dx, Real dy) <-> 1-Ud <= dx^2+dy^2 & dx^2 + dy^2 <= 1+Ud;

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A >= 0                                                                                        /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & 0<=Ud & Ud <= 1
  );
  Bool initialState(Real x, Real y, Real v, Real a, Real w, Real r, Real dx, Real dy, Real t, Real xo, Real yo) <-> (                                                       /* Stopped somewhere safe initially */
    v = 0 & a = 0 & w = 0 & r = 1 & t = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir(dx,dy)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real a, Real w, Real r, Real dx, Real dy, Real t, Real xo, Real yo) <->
    bounds() & initialState(x, y, v, a, w, r, dx, dy, t, xo, yo);

  /* Conditions that are true on each loop iteration */
  Bool loopinv(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v >= 0
    & isWellformedDir(dx,dy)
    & (2*b*abs(x-xo) > stopDist(v) | 2*b*abs(y-yo) > stopDist(v))
  );
End.

ProgramVariables
  Real x;    /* robot position: x */
  Real y;    /* robot position: y */
  Real v;    /* robot translational velocity */
  Real a;    /* robot translational acceleration */
  Real dx;   /* robot orientation: x */
  Real dy;   /* robot orientation: y */
  Real w;    /* robot rotational velocity */
  Real r;    /* robot curve radius */
  Real xo;   /* position of closest obstacle on curve */
  Real yo;
  Real t;    /* time */
End.

Problem
assumptions(x, y, v, a, w, r, dx, dy, t, xo, yo) ->
  [
    {
      {
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
          ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? 2*b*abs(x-xo) > admissibleSeparation(v,ep)
            | 2*b*abs(y-yo) > admissibleSeparation(v,ep);
          }
        };
        t := 0;
      }

      /* dynamics */
      {
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        t' = 1 & t <= ep & v >= 0
      }@invariant(t>=0, isWellformedDir(dx,dy),
         (v'=-b -> v <= old(v) - b*(t-old(t))),
         (v'=-b -> (-(t-old(t)) * (2*old(v) - b*(t-old(t))) * (1+Ud) <= 2*(x - old(x)) & 2*(x - old(x)) <= (t-old(t)) * (2*old(v) - b*(t-old(t))) * (1+Ud))),
         (v'=-b -> (-(t-old(t)) * (2*old(v) - b*(t-old(t))) * (1+Ud) <= 2*(y - old(y)) & 2*(y - old(y)) <= (t-old(t)) * (2*old(v) - b*(t-old(t))) * (1+Ud))),
         (v'=0 -> v = old(v)),
         (v'=0 -> x = old(x)),
         (v'=0 -> y = old(y)),
         (v'=0 -> w = old(w)), /* may not be necessary if we remove w=0 from throughout inv */
         (v'=A -> v <= old(v) + A*(t-old(t))),
         (v'=A -> (-(t-old(t)) * (2*old(v) + A*(t-old(t))) * (1+Ud) <= 2*(x - old(x)) & 2*(x - old(x)) <= (t-old(t)) * (2*old(v) + A*(t-old(t))) * (1+Ud))),
         (v'=A -> (-(t-old(t)) * (2*old(v) + A*(t-old(t))) * (1+Ud) <= 2*(y - old(y)) & 2*(y - old(y)) <= (t-old(t)) * (2*old(v) + A*(t-old(t))) * (1+Ud)))
       )
      }
    }*@invariant(loopinv(x, y, v, dx, dy, xo, yo))
  ](x - xo)^2 + (y - yo)^2 > 0
End.

Tactic "Proof Theorem 1: Static safety".
  tactic diall as (
    diffInvariant("t>=0", 1);
    diffInvariant("isWellformedDir(dx,dy)", 1)
  );

  tactic diHide as (
    hideL('L~="2*b*abs(x-xo)>stopDist(v)|2*b*abs(y-yo)>stopDist(v)");
    hideL('L~="1-Ud<=dx^2+dy^2");
    hideL('L~="dx^2+dy^2<=1+Ud")
  );

  tactic dib as (
    diall;
    dC("v <= old(v) - b*t", 1); <(nil, diHide; dI(1));
    dC("(-t * (2*old(v) - b*t) * (1+Ud) <= 2*(x - old(x)) & 2*(x - old(x)) <= t * (2*old(v) - b*t) * (1+Ud))
       & (-t * (2*old(v) - b*t) * (1+Ud) <= 2*(y - old(y)) & 2*(y - old(y)) <= t * (2*old(v) - b*t) * (1+Ud))", 1); <(nil, diHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic di0 as (
    diall;
    diffInvariant("v = old(v)", 1);
    diffInvariant("x = old(x)", 1);
    diffInvariant("y = old(y)", 1)
  );

  tactic diaHide as (
    hideL('L~="2*b*abs(x-xo)>admissibleSeparation(v)|2*b*abs(y-yo)>admissibleSeparation(v)");
    hideL('L~="1-Ud<=dx^2+dy^2");
    hideL('L~="dx^2+dy^2<=1+Ud");
    hideL('L=="r*w=v_0"); hideL('L=="-W<=w"); hideL('L=="w<=W"); hideL('L=="r!=0")
  );

  tactic dia as (
    diall;
    dC("v <= old(v) + A*t", 1); <(nil, diaHide; dI(1));
    dC("(-t * (2*old(v) + A*t) * (1+Ud) <= 2*(x - old(x)) & 2*(x - old(x)) <= t * (2*old(v) + A*t) * (1+Ud))
       & (-t * (2*old(v) + A*t) * (1+Ud) <= 2*(y - old(y)) & 2*(y - old(y)) <= t * (2*old(v) + A*t) * (1+Ud))", 1); <(nil, diaHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic dw as (andL('L)*; dW(1));

  tactic qeHide as (
    hideL('L~="1-Ud<=dx^2+dy^2")*;
    hideL('L~="dx^2+dy^2<=1+Ud")*
  );

  tactic xAccArith as (
    andL('L)*;
    hideR('R=="2*b*abs(y-yo)>stopDist(v)");
    hideL('L=="1-Ud<=dx^2+dy^2");
    hideL('L=="dx^2+dy^2<=1+Ud");
    hideL('L=="r!=0");
    print("Transforming...");
    transform("2*b*abs(x_0-xo)>(1+Ud)*(v_0^2+(A+b)*(A*t^2+2*t*v_0))", 'L=="2*b*abs(x_0-xo)>admissibleSeparation(v_0,ep)");
    hideL('L=="t<=ep");
    hideL('L=="ep>0");
    print("Transformed");
    smartQE;
    print("Proved acc arithmetic")
  );

  tactic yAccArith as (
    andL('L)*;
    hideR('R=="2*b*abs(x-xo)>stopDist(v)");
    hideL('L=="1-Ud<=dx^2+dy^2");
    hideL('L=="dx^2+dy^2<=1+Ud");
    hideL('L=="r!=0");
    print("Transforming...");
    transform("2*b*abs(y_0-yo)>(1+Ud)*(v_0^2+(A+b)*(A*t^2+2*t*v_0))", 'L=="2*b*abs(y_0-yo)>admissibleSeparation(v_0,ep)");
    hideL('L=="t<=ep");
    hideL('L=="ep>0");
    print("Transformed");
    smartQE;
    print("Proved acc arithmetic")
  );

  implyR(1); andL('L)*; loop("loopinv(x, y, v, dx, dy, xo, yo)", 1); <(
    print("Base case..."); smartQE; print("Base case done")
    ,
    print("Use case..."); smartQE; print("Use case done")
    ,
    print("Induction step"); unfold; <(
      print("Braking branch"); dib; dw; prop; doall(qeHide; smartQE); print("Braking branch done")
      ,
      print("Stopped branch"); di0; dw; prop; doall(qeHide; smartQE); print("Stopped branch done")
      ,
      print("Acceleration branch");
      hideL('L=="2*b*abs(x-xo_0)>(1+Ud)*v^2|2*b*abs(y-yo_0)>(1+Ud)*v^2");
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print("Acceleration branch done")
    );
    print("Induction step done")
  );
  done;
  print("Proof done")

End.

Tactic "Proof with throughout invariant".
implyR(1) ; throughout("(v>=0&(1-Ud<=dx^2+dy^2&dx^2+dy^2<=1+Ud)&(2*b*abs(x-xo)>(1+Ud)*v^2|2*b*abs(y-yo)>(1+Ud)*v^2))&t>=0&(a=-b|v=0&a=0|a=A&(2*b*abs(x-xo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)|2*b*abs(y-yo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)))", 1) ; <(
  simplify(1) ; smartQE,
  andL(-1) ; hideL(-7=="t>=0&(a=-b|v=0&a=0|a=A&(2*b*abs(x-xo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)|2*b*abs(y-yo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)))") ; andL(-6) ; andL(-7) ; hideL(-7=="1-Ud<=dx^2+dy^2&dx^2+dy^2<=1+Ud") ; QE,
  chase(1) ; simplify(1) ; andR(1) ; <(
    prop,
    (allR(1) | implyR(1))* ; orR(1) ; andL(-1) ; andL(-9) ; hideL(-11=="(1-Ud<=dx^2+dy^2&dx^2+dy^2<=1+Ud)&(2*b*abs(x-xo_0)>(1+Ud)*v^2|2*b*abs(y-yo_0)>(1+Ud)*v^2)") ; hideL(-9=="t>=0&(a=-b|v=0&a=0|a=A&(2*b*abs(x-xo_0)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)|2*b*abs(y-yo_0)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)))") ; smartQE
    ),
  andL('L)* ; orL(-5) ; <(
    allL2R(-5) ; hideL(-5=="a=-b") ; dC("t>=old(t)", 1) ; <(
      dC("1-Ud<=dx^2+dy^2&dx^2+dy^2<=1+Ud", 1) ; <(
        dC("v<=old(v)-b*(t-old(t))", 1) ; <(
          dC("-(t-old(t))*(2*old(v)-b*(t-old(t)))*(1+Ud)<=2*(x-old(x))&2*(x-old(x))<=(t-old(t))*(2*old(v)-b*(t-old(t)))*(1+Ud)", 1) ; <(
            dC("-(t-old(t))*(2*old(v)-b*(t-old(t)))*(1+Ud)<=2*(y-old(y))&2*(y-old(y))<=(t-old(t))*(2*old(v)-b*(t-old(t)))*(1+Ud)", 1) ; <(
              dW(1) ; simplify(1) ; andR(1) ; <(
                andL('L)*; simplify(1) ; orR(1) ; hideL(-14=="t<=ep()") ; hideL(-12=="dx^2+dy^2<=1+Ud()") ;
                hideL(-11=="1-Ud()<=dx^2+dy^2") ; hideL(-14=="ep()>0") ; hideL(-11=="A()>=0") ; hideL(-4=="v_0>=0") ;
                orL(-8) ; <(
                  hideR(2=="2*b()*abs(y-yo)>(1+Ud())*v^2") ; hideL(-3=="2*(y-y_0)<=(t-t_0)*(2*v_0-b()*(t-t_0))*(1+Ud())") ; hideL(-2=="-(t-t_0)*(2*v_0-b()*(t-t_0))*(1+Ud())<=2*(y-y_0)") ; smartQE,
                  hideR(1=="2*b()*abs(x-xo)>(1+Ud())*v^2") ; hideL(-6=="2*(x-x_0)<=(t-t_0)*(2*v_0-b()*(t-t_0))*(1+Ud())") ; hideL(-5=="-(t-t_0)*(2*v_0-b()*(t-t_0))*(1+Ud())<=2*(x-x_0)") ; smartQE
                  ),
                QE
                ),
              hideL('L~="2*b*abs(x-xo)>(1+Ud)*v^2|2*b*abs(y-yo)>(1+Ud)*v^2") ; dI(1)
              ),
            hideL('L~="2*b*abs(x-xo)>(1+Ud)*v^2|2*b*abs(y-yo)>(1+Ud)*v^2") ; dI(1)
            ),
          hideL('L~="2*b*abs(x-xo)>(1+Ud)*v^2|2*b*abs(y-yo)>(1+Ud)*v^2") ; dI(1)
          ),
        hideL('L~="2*b*abs(x-xo)>(1+Ud)*v^2|2*b*abs(y-yo)>(1+Ud)*v^2") ; dI(1)
        ),
      hideL('L~="2*b*abs(x-xo)>(1+Ud)*v^2|2*b*abs(y-yo)>(1+Ud)*v^2") ; dI(1)
      ),
    orL(-5) ; <(
      andL(-5) ; allL2R(-15=="a=0") ; hideL(-15=="a=0") ; dC("t>=old(t)", 1) ; <(
        dC("1-Ud<=dx^2+dy^2&dx^2+dy^2<=1+Ud", 1) ; <(
          dC("v=old(v)", 1) ; <(
            dC("x=old(x)", 1) ; <(
              dC("y=old(y)", 1) ; <(
                dW(1) ; andR(1) ; <(
                  andL('L)* ; allL2R(-5=="v=v_0") ; hideL(-5=="v=v_0") ; allL2R(-3=="x=x_0") ; hideL(-3=="x=x_0") ; allL2R(-1=="y=y_0") ; hideL(-1=="y=y_0") ; simplify(1) ; closeT,
                  andR(1) ; <(
                    QE,
                    orR(1) ; orR(2) ; hideR(3=="0=A&(2*b*abs(x-xo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)|2*b*abs(y-yo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v))") ; hideR(1=="0=-b") ; simplify(1) ; QE
                    )
                  ),
                hideL('L~="2*b*abs(x-xo)>(1+Ud)*v^2|2*b*abs(y-yo)>(1+Ud)*v^2") ; dI(1)
                ),
              hideL('L~="2*b*abs(x-xo)>(1+Ud)*v^2|2*b*abs(y-yo)>(1+Ud)*v^2") ; dI(1)
              ),
            hideL('L~="2*b*abs(x-xo)>(1+Ud)*v^2|2*b*abs(y-yo)>(1+Ud)*v^2") ; dI(1)
            ),
          hideL('L~="2*b*abs(x-xo)>(1+Ud)*v^2|2*b*abs(y-yo)>(1+Ud)*v^2") ; dI(1)
          ),
        hideL('L~="2*b*abs(x-xo)>(1+Ud)*v^2|2*b*abs(y-yo)>(1+Ud)*v^2") ; dI(1)
        ),
      andL(-5) ; allL2R(-14=="a=A") ; hideL(-14=="a=A") ; hideL(-6=="2*b*abs(x-xo)>(1+Ud)*v^2|2*b*abs(y-yo)>(1+Ud)*v^2") ; dC("t>=old(t)", 1) ; <(
        dC("1-Ud<=dx^2+dy^2&dx^2+dy^2<=1+Ud", 1) ; <(
          dC("v<=old(v)+A*(t-old(t))", 1) ; <(
            dC("-(t-old(t))*(2*old(v)+A*(t-old(t)))*(1+Ud)<=2*(x-old(x))&2*(x-old(x))<=(t-old(t))*(2*old(v)+A*(t-old(t)))*(1+Ud)", 1) ; <(
              dC("-(t-old(t))*(2*old(v)+A*(t-old(t)))*(1+Ud)<=2*(y-old(y))&2*(y-old(y))<=(t-old(t))*(2*old(v)+A*(t-old(t)))*(1+Ud)", 1) ; <(
                dW(1) ; andL('L)* ; andR(1) ; <(
                  andR(1) ; <(
                    hideL(-19=="2*b*abs(x_0-xo)>(1+Ud)*v_0^2+(1+Ud)*(A+b)*(A*(ep-t_0)^2+2*(ep-t_0)*v_0)|2*b*abs(y_0-yo)>(1+Ud)*v_0^2+(1+Ud)*(A+b)*(A*(ep-t_0)^2+2*(ep-t_0)*v_0)") ; QE,
                    andR(1) ; <(
                      prop,
                      orR(1) ;

                      hideL('L=="dx^2+dy^2<=1+Ud") ; hideL('L=="1-Ud<=dx^2+dy^2") ; hideL('L=="v_0>=0") ; orL(-16) ; <(
                        hideL('L=="-(t-t_0)*(2*v_0+A*(t-t_0))*(1+Ud)<=2*(y-y_0)") ; hideL('L=="2*(y-y_0)<=(t-t_0)*(2*v_0+A*(t-t_0))*(1+Ud)") ;
                        edit("2*b*abs(x_0-xo)>(1+Ud)*v_0^2+(1+Ud)*(A+b)*(A*(t-t_0)^2+2*(t-t_0)*v_0)", 'L=="2*b()*abs(x_0-xo)>(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0)") ;
                        hideR('R=="2*b*abs(y-yo)>(1+Ud)*v^2") ; hideL('L=="t<=ep") ; hideL('L=="ep>0") ;
                        smartQE,
                        hideR('R=="2*b*abs(x-xo)>(1+Ud)*v^2") ;
                        hideL('L=="2*(x-x_0)<=(t-t_0)*(2*v_0+A*(t-t_0))*(1+Ud)") ;
                        hideL('L=="-(t-t_0)*(2*v_0+A*(t-t_0))*(1+Ud)<=2*(x-x_0)") ;
                        edit("2*b*abs(y_0-yo)>(1+Ud)*v_0^2+(1+Ud)*(A+b)*(A*(t-t_0)^2+2*(t-t_0)*v_0)", 'L=="2*b()*abs(y_0-yo)>(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0)") ;
                        hideL('L=="t<=ep") ; hideL('L=="ep>0") ;
                        smartQE
                        )
                      )
                    ),
                  andR(1) ; <(
                    QE,
                    orR(1) ; orR(2) ; hideR(1=="A=-b") ; hideR(1=="v=0&A=0") ; simplify(1) ; orR(1) ;
                    orL(-19) ; <(
                      hideR('R=="2*b*abs(y-yo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)") ;
                      hideL('L=="dx^2+dy^2<=1+Ud") ;
                      hideL('L=="1-Ud<=dx^2+dy^2") ;
                      hideL('L=="v_0>=0") ;
                      hideL('L=="-(t-t_0)*(2*v_0+A*(t-t_0))*(1+Ud)<=2*(y-y_0)") ;
                      hideL('L=="2*(y-y_0)<=(t-t_0)*(2*v_0+A*(t-t_0))*(1+Ud)") ;
                      cut("(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)+b*(t-t_0)*(1+Ud)*(A*(t-t_0)+2*v_0)<=(1+Ud)*v_0^2+(1+Ud)*(A+b)*(A*(ep-t_0)^2+2*(ep-t_0)*v_0)") ; <(
                        edit("(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)+b*(t-t_0)*(1+Ud)*(A*(t-t_0)+2*v_0)<=abbrv((1+Ud)*v_0^2+(1+Ud)*(A+b)*(A*(ep-t_0)^2+2*(ep-t_0)*v_0))", -15) ;
                        edit("abbrv((1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v))+b*(t-t_0)*(1+Ud)*(A*(t-t_0)+2*v_0)<=abbrv", -15) ;
                        hideL('L=="abbrv=(1+Ud)*v_0^2+(1+Ud)*(A+b)*(A*(ep-t_0)^2+2*(ep-t_0)*v_0)") ; hideL('L=="abbrv_0=(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)") ; smartQE,
                        hideR('R=="2*b*abs(x-xo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)") ; hideL('L=="2*b*abs(x_0-xo)>(1+Ud)*v_0^2+(1+Ud)*(A+b)*(A*(ep-t_0)^2+2*(ep-t_0)*v_0)") ; QE
                        ),
                      hideR('R=="2*b*abs(x-xo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)") ;
                      hideL('L=="-(t-t_0)*(2*v_0+A*(t-t_0))*(1+Ud)<=2*(x-x_0)") ;
                      hideL('L=="2*(x-x_0)<=(t-t_0)*(2*v_0+A*(t-t_0))*(1+Ud)") ;
                      hideL('L=="dx^2+dy^2<=1+Ud") ;
                      hideL('L=="1-Ud<=dx^2+dy^2") ; hideL('L=="v_0>=0") ;
                      cut("(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)+b*(t-t_0)*(1+Ud)*(A*(t-t_0)+2*v_0)<=(1+Ud)*v_0^2+(1+Ud)*(A+b)*(A*(ep-t_0)^2+2*(ep-t_0)*v_0)") ; <(
                        edit("(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)+b*(t-t_0)*(1+Ud)*(A*(t-t_0)+2*v_0)<=abbrv((1+Ud)*v_0^2+(1+Ud)*(A+b)*(A*(ep-t_0)^2+2*(ep-t_0)*v_0))", -15) ;
                        edit("abbrv((1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v))+b*(t-t_0)*(1+Ud)*(A*(t-t_0)+2*v_0)<=abbrv", -15) ;
                        hideL('L=="abbrv=(1+Ud)*v_0^2+(1+Ud)*(A+b)*(A*(ep-t_0)^2+2*(ep-t_0)*v_0)") ;
                        hideL('L=="abbrv_0=(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)") ; smartQE,
                        hideR('R=="2*b*abs(y-yo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)") ;
                        hideL('L=="2*b*abs(y_0-yo)>(1+Ud)*v_0^2+(1+Ud)*(A+b)*(A*(ep-t_0)^2+2*(ep-t_0)*v_0)") ;
                        QE
                        )
                      )
                    )
                  ),
                hideL('L~="2*b*abs(x-xo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)|2*b*abs(y-yo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)") ; dI(1)
                ),
              hideL('L~="2*b*abs(x-xo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)|2*b*abs(y-yo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)") ; dI(1)
              ),
            hideL('L~="2*b*abs(x-xo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)|2*b*abs(y-yo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)") ; dI(1)
            ),
          hideL('L~="2*b*abs(x-xo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)|2*b*abs(y-yo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)") ; dI(1)
          ),
        hideL('L~="2*b*abs(x-xo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)|2*b*abs(y-yo)>(1+Ud)*v^2+(1+Ud)*(A+b)*(A*(ep-t)^2+2*(ep-t)*v)") ; dI(1)
        )
      )
    )
  )
End.

End.

Theorem "IJRR17/Theorem 2: Passive safety".

Definitions
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real W;       /* maximum steering */
  Real V;       /* maximum obstacle velocity */

  Real stopDist(Real v) = v^2 / (2*b) + V*v/b;
  Real accelComp(Real v) = ((A/b + 1) * (A/2 * ep^2 + ep*(v+V)));
  Real admissibleSeparation(Real v) = stopDist(v) + accelComp(v);

  Bool isWellformedDir(Real dx, Real dy) <-> dx^2 + dy^2 = 1;       /* The orientation of the robot is a unit vector. */

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A >= 0                                                                                        /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & V >= 0
  );

  /* Stopped somewhere safe initially */
  Bool initialState(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir(dx,dy)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <->
    bounds() & initialState(x, y, v, dx, dy, xo, yo);

  /* Conditions that are true on each loop iteration */
  Bool loopinv(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v >= 0
    & isWellformedDir(dx,dy)
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  );
End.

ProgramVariables
  Real x;    /* robot position: x */
  Real y;    /* robot position: y */
  Real v;    /* robot translational velocity */
  Real a;    /* robot translational acceleration */
  Real dx;   /* robot orientation: x */
  Real dy;   /* robot orientation: y */
  Real w;    /* robot rotational velocity */
  Real r;    /* robot curve radius */
  Real xo;   /* position of closest obstacle on curve */
  Real yo;
  Real vxo;  /* velocity vector of obstacle */
  Real vyo;
  Real t;    /* time */
End.

Problem
assumptions(x, y, v, dx, dy, xo, yo) ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
          ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
        t := 0;
      }

      /* dynamics */
      {
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }@invariant(t>=0, isWellformedDir(dx,dy),
          (-t*V <= xo - old(xo) & xo - old(xo) <= t*V),
          (-t*V <= yo - old(yo) & yo - old(yo) <= t*V),
          (v'=-b -> v = old(v) - b*t),
          (v'=-b -> (-t * (old(v) - b/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - b/2*t))),
          (v'=-b -> (-t * (old(v) - b/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - b/2*t))),
          (v'=0 -> v = old(v)),
          (v'=0 -> x = old(x)),
          (v'=0 -> y = old(y)),
          (v'=A -> v = old(v) + A*t),
          (v'=A -> (-t * (old(v) + A/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A/2*t))),
          (v'=A -> (-t * (old(v) + A/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A/2*t)))
        )
      }
    }*@invariant(loopinv(x, y, v, dx, dy, xo, yo))
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 2: Passive safety".
  tactic diall as (
    diffInvariant("t>=0", 1);
    diffInvariant("isWellformedDir(dx,dy)", 1);
    diffInvariant("-t*V <= xo - old(xo) & xo - old(xo) <= t*V", 1);
    diffInvariant("-t*V <= yo - old(yo) & yo - old(yo) <= t*V", 1)
  );

  tactic dib as (
    diall;
    diffInvariant("v = old(v) - b*t", 1);
    diffInvariant("-t * (v + b/2*t) <= x - old(x) & x - old(x) <= t * (v + b/2*t)", 1);
    diffInvariant("-t * (v + b/2*t) <= y - old(y) & y - old(y) <= t * (v + b/2*t)", 1)
  );

  tactic di0 as (
    diall;
    diffInvariant("v = old(v)", 1);
    diffInvariant("x = old(x)", 1);
    diffInvariant("y = old(y)", 1)
  );

  tactic dia as (
    diall;
    diffInvariant("v = old(v) + A*t", 1);
    diffInvariant("-t * (v - A/2*t) <= x - old(x) & x - old(x) <= t * (v - A/2*t)", 1);
    diffInvariant("-t * (v - A/2*t) <= y - old(y) & y - old(y) <= t * (v - A/2*t)", 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print("Transforming...");
    transform("abs(x_0-xo_0)>v_0^2/(2*b)+V*v_0/b+(A/b+1)*(A/2*t^2+t*(v_0+V))", 'L=="abs(x_0-xo_0)>admissibleSeparation(v_0)");
    hideR('R=="abs(y-yo)>stopDist(v)");
    smartQE;
    print("Proved acc arithmetic")
  );

  tactic yAccArith as (
    andL('L)*;
    print("Transforming...");
    transform("abs(y_0-yo_0)>v_0^2/(2*b)+V*v_0/b+(A/b+1)*(A/2*t^2+t*(v_0+V))", 'L=="abs(y_0-yo_0)>admissibleSeparation(v_0)");
    hideR('R=="abs(x-xo)>stopDist(v)");
    smartQE;
    print("Proved acc arithmetic")
  );

  implyR(1); andL('L)*; loop("loopinv(x, y, v, dx, dy, xo, yo)", 1); <(
    "Init": print("Base case..."); smartQE; print("Base case done")
    ,
    "Post": print("Use case..."); smartQE; print("Use case done")
    ,
    "Step": print("Induction step"); unfold; <(
      "[a:=-b();][t:=0;][{x'=v*dx,y'=v*dy,v'=a,dx'=-w*dy,dy'=w*dx,w'=a/r,xo'=vxo,yo'=vyo,t'=1&t<=ep()&v>=0}]loopinv(x,y,v,dx,dy,xo,yo)":
        print("Braking branch"); dib; dw; prop; doall(smartQE); print("Braking branch done")
      ,
      "[?v=0;a:=0;w:=0;][t:=0;][{x'=v*dx,y'=v*dy,v'=a,dx'=-w*dy,dy'=w*dx,w'=a/r,xo'=vxo,yo'=vyo,t'=1&t<=ep()&v>=0}]loopinv(x,y,v,dx,dy,xo,yo)":
        print("Stopped branch"); di0; dw; prop; doall(smartQE); print("Stopped branch done")
      ,
      "[a:=A();w:=*;?-W()<=w&w<=W();r:=*;xo:=*;yo:=*;?r!=0&r*w=v;?abs(x-xo)>admissibleSeparation(v)|abs(y-yo)>admissibleSeparation(v);][t:=0;][{x'=v*dx,y'=v*dy,v'=a,dx'=-w*dy,dy'=w*dx,w'=a/r,xo'=vxo,yo'=vyo,t'=1&t<=ep()&v>=0}]loopinv(x,y,v,dx,dy,xo,yo)":
        print("Acceleration branch");
        expand "loopinv";
        andL('L)*;
        hideL('L == "v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)");
        dia; dw;
        prop; <(
          xAccArith,
          yAccArith
        );
        print("Acceleration branch done")
    );
    print("Induction step done")
  );
  done;
  print("Proof done")

End.

End.

ArchiveEntry "IJRR17/Corollary 2: Velocity-controlled passive orientation safety".
Definitions
  Real ep;      /* time limit for control decisions */
  Real W;       /* maximum steering */
  Real V;       /* maximum obstacle velocity */
  Real GammA;   /* Sensor range in radian */

  Real stopDist(Real v)   = 0;
  Real stopMargin(Real v) = stopDist(v);
  Real accelComp(Real v)  = ep*v;
  Real accelMargin(Real v)  = accelComp(v) + ep*V;
  Real admissibleSeparation(Real v) = stopMargin(v) + accelMargin(v);
  Real admissibleTurnLength(Real v) = stopDist(v) + accelComp(v);

  Bool isWellformedDir(Real dx, Real dy) <-> dx^2 + dy^2 = 1;       /* The orientation of the robot is a unit vector. */

  Bool isVisible(Real x) <-> x>0;  /* Indicates whether or not the obstacle is visible for the robot at the decision. */

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      ep > 0                                                                              /* Controller reaction time */
    & V >= 0
    & GammA > 0
  );

  /* Stopped somewhere safe initially */
  Bool initialState(Real x, Real y, Real v, Real beta, Real r, Real dx, Real dy, Real xo, Real yo) <-> (
    v = 0
    & beta = 0
    & r != 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir(dx,dy)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real beta, Real r, Real dx, Real dy, Real xo, Real yo) <->
    bounds() & initialState(x, y, v, beta, r, dx, dy, xo, yo);

  Bool loopinv(Real x, Real y, Real v, Real beta, Real visDeg, Real r, Real dx, Real dy, Real xo, Real yo) <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir(dx,dy)
    & r != 0
    & (v>0 -> ( (abs(x-xo) > stopMargin(v) | abs(y-yo) > stopMargin(v))
              | (!isVisible(visDeg) & abs(beta) + stopDist(v)/abs(r) < GammA )) )
  );
End.

ProgramVariables
  Real x;    /* robot position: x */
  Real y;    /* robot position: y */
  Real v;    /* robot translational velocity */
  Real a;    /* robot translational acceleration */
  Real dx;   /* robot orientation: x */
  Real dy;   /* robot orientation: y */
  Real w;    /* robot rotational velocity */
  Real r;    /* robot curve radius */
  Real xo;   /* position of closest obstacle on curve */
  Real yo;
  Real vxo;  /* velocity vector of obstacle */
  Real vyo;
  Real t;    /* time */
  Real beta; /* Angle that the robot traveled since it last chose a new curve */
  Real visDeg; /* Indicates the "degree" to which the obstacle is visible to the robot (input to isVisible) */
End.

Problem
  assumptions(x, y, v, beta, r, dx, dy, xo, yo) -> [
      {
        {
        /* obstacle control */
        {
          vxo := *;
          vyo := *;
          ?vxo^2+vyo^2 <= V^2;
        }

        /* robot control */
        {
           /* brake on current curve. If the velocity is zero this just means that the robot remains stopped */
           {v := 0; w := 0;}
        ++ /* or choose a new safe curve */
           {v := *;
            beta := 0;
            r :=*; ?r!=0;

            /* measure obstacle position and whether or not it is visible to the robot */
            xo := *; yo := *; visDeg := *;
            ?(isVisible(visDeg) ->
               ( abs(x-xo) > admissibleSeparation(v)
               | abs(y-yo) > admissibleSeparation(v)) );
            ?admissibleTurnLength(v) < GammA*abs(r);
            }
        }

        /* Reset the clocks */
        t := 0;
        /* Set w according to physics (rigid body motion) */
        w :=*; ?w*r = v;
        }

        {x' = v * dx, y' = v * dy, dx' = -w * dy, dy' = w * dx, beta'=w,
                      xo' = vxo, yo' = vyo, t' = 1 & (t <= ep & v >= 0)}
      }*
    ] (v > 0 -> ((x - xo)^2 + (y - yo)^2 > 0 | (!isVisible(visDeg) & (abs(beta) < GammA))) )
End.

Tactic "Proof Corollary 2: Velocity-controlled passive orientation safety".
  tactic diHide as (
    hideL('L~="visDeg>0->abs(x-xo)>0+(ep*v+ep*V)|abs(y-yo)>0+(ep*v+ep*V)")*;
    hideL('L~="v>0->(abs(x-xo_0)>0|abs(y-yo)>0)|!visDeg>0&abs(beta)+0/abs(r) < GammA")*
  );

  tactic diall as (
    diffInvariant("t>=0", 1);
    diffInvariant("isWellformedDir(dx,dy)", 1);
    dC("(-t*V <= xo - old(xo) & xo - old(xo) <= t*V)
       & (-t*V <= yo - old(yo) & yo - old(yo) <= t*V)", 1); <(nil, diHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic di0 as (
    diall;
    diffInvariant("beta = old(beta)", 1);
    diffInvariant("x = old(x)", 1);
    diffInvariant("y = old(y)", 1)
  );

  tactic dia as (
    diall;
    diffInvariant("beta = old(beta) + t*v/r", 1);
    dC("(-t * v <= x - old(x) & x - old(x) <= t * v)
       & (-t * v <= y - old(y) & y - old(y) <= t * v)", 1); <(nil, diHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic dw as (andL('L)*; dW(1));

  implyR(1); andL('L)*; loop("loopinv(x, y, v, beta, visDeg, r, dx, dy, xo, yo)", 1); <(
    print("Base case..."); smartQE; print("Base case done")
    ,
    print("Use case..."); smartQE; print("Use case done")
    ,
    print("Induction step"); unfold; <(
      print("Stopped branch"); di0; dw; prop; doall(smartQE); print("Stopped branch done")
      ,
      print("Acceleration branch");
      hideL('L == "v_0>0->((abs(x-xo_0)>stopMargin(v_0)|abs(y-yo_0)>stopMargin(v_0))|!isVisible(visDeg_0)&abs(beta_0)+stopDist(v_0)/abs(r_0) < GammA)");
      unfold;
      dia; dw;
      print("Acceleration arithmetic");
      andL('L)* ; simplify(1); implyR(1) ; orR(1) ; orR(1) ;
      implyL('L=="isVisible(visDeg) -> ( abs(x_0-xo_0) > admissibleSeparation(v) | abs(y_0-yo_0) > admissibleSeparation(v))") ; <(
        hideR('R=="abs(x-xo)>stopMargin(v)") ; hideR('R=="abs(y-yo)>stopMargin(v)") ; fullSimplify ; andR(1) ; doall(smartQE)
        ,
        print("Acc Distance");
        hideL('L=="admissibleTurnLength(v) < GammA*abs(r)") ;
        hideR('R=="visDeg<=0 & abs(beta) + stopDist(v)/abs(r) < GammA");
        hideL('L=="r_0!=0");
        hideL('L=="vxo^2+vyo^2<=V^2");
        hideL('L=="dx^2+dy^2=1");
        hideL('L=="GammA>0");
        hideL('L=="beta_0=0");
        hideL('L=="w*r=v");
        hideL('L=="beta=beta_0+t*v/r");
        orL('L=="abs(x_0-xo_0)>admissibleSeparation(v) | abs(y_0-yo_0)>admissibleSeparation(v)"); <(
          fullSimplify ; smartQE
          ,
          fullSimplify ; smartQE
        )
      );
      print("Acceleration branch done")
    );
    print("Induction step done")
  );
  done;
  print("Proof done")

End.

End.

Theorem "IJRR17/Theorem 3: Passive Friendly Safety".
Definitions
  Real ep;      /* time limit for control decisions */
  Real tau;     /* time limit for obstacle reaction */
  Real b;       /* minimum braking capability of the robot */
  Real bo;      /* obstacle brakes */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real W;       /* maximum steering */
  Real V;       /* maximum obstacle velocity */

  Real friendlyMargin(Real v) = v^2/(2*bo) + tau*v;
  Real stopDist(Real v) = v^2 / (2*b) + V*v/b;
  Real accelComp(Real v) = ((A/b + 1) * (A/2 * ep^2 + ep*(v+V)));
  Real admissibleSeparation(Real v) = stopDist(v) + friendlyMargin(V) + accelComp(v);

  Bool isWellformedDir(Real dx,Real dy) <-> dx^2 + dy^2 = 1;        /* The orientation of the robot is a unit vector. */

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A >= 0                                                                                        /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & V >= 0
    & tau >= 0
    & bo > 0
  );

  /* Stopped somewhere safe initially */
  Bool initialState(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo, Real vxo, Real vyo) <-> (
    v = 0
    & (abs(x-xo) > friendlyMargin(V) | abs(y-yo) > friendlyMargin(V))
    & vxo^2+vyo^2<=V^2
    & isWellformedDir(dx,dy)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo, Real vxo, Real vyo) <->
    bounds() & initialState(x, y, v, dx, dy, xo, yo, vxo, vyo);

  /* Conditions that are true on each loop iteration */
  Bool loopinv(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v >= 0
    & isWellformedDir(dx,dy)
    & (v>0 -> abs(x-xo) > stopDist(v)+friendlyMargin(V) | abs(y-yo) > stopDist(v)+friendlyMargin(V))
  );
End.

ProgramVariables
  Real x;    /* robot position: x */
  Real y;    /* robot position: y */
  Real v;    /* robot translational velocity */
  Real a;    /* robot translational acceleration */
  Real dx;   /* robot orientation: x */
  Real dy;   /* robot orientation: y */
  Real w;    /* robot rotational velocity */
  Real r;    /* robot curve radius */
  Real xo;   /* position of closest obstacle on curve */
  Real yo;
  Real vxo;  /* velocity vector of obstacle */
  Real vyo;
  Real vo;   /* refined obstacle: speed, acceleration, and direction */
  Real ao;
  Real dxo;
  Real dyo;
  Real t;    /* time */
End.

Problem
assumptions(x, y, v, dx, dy, xo, yo, vxo, vyo) ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
          ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
        t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv(x, y, v, dx, dy, xo, yo))
  ](  (v>0 -> (x - xo)^2 + (y - yo)^2 > (friendlyMargin(V))^2)                     /* robot ensures friendly margin */
    & (  0<=vo & vo^2=vxo^2+vyo^2 & dxo*vo=vxo & dyo*vo=vyo                                      /* obstacle can stop */
       & (x - xo)^2 + (y - yo)^2 > (friendlyMargin(V))^2
       ->
        <{
          ao := *; ?-bo <= ao & vo + ao*ep <= V;
          t := 0;
          {xo'=vo*dxo, yo'=vo*dyo, vo'=ao, t'=1 & vo>=0 & t<=ep}
         }*>((x-xo)^2 + (y-yo)^2 > 0 & vo=0))
  )
End.

Tactic "IJRR17/Proof Theorem 3: Passive Friendly Safety".
  useSolver("Mathematica");
  tactic obstacleCanStop as (
    unfold;
    cut("vo=0|dxo^2+dyo^2=1") ; <(
      cut("vo<=V") ; <(
        hideL('L=="vo^2=vxo^2+vyo^2");
        hideL('L=="vxo^2+vyo^2<=V^2");
        con("v", "(vo=0|dxo^2+dyo^2=1)&bo>0&ep>0&(x-xo)^2+(y-yo)^2>(vo^2/(2*bo))^2&0<=vo&vo<=V&(v*ep*bo>=vo|vo=0)", 1); <(
          QE,
          QE,
          unfold;
          existsR("-bo", 1);
          unfold; <(
            QE
            ,
            solve(1);
            existsR("min((vo/bo,ep))", 1);
            abbrv("min((vo/bo,ep))", "minT");
            edit("minT=expand(min(vo/bo(),ep()))", 'Llast);
            orL('L=="vo=0|dxo^2+dyo^2=1");
            doall(QE)
          )
        )
        ,
        hideR(1);
        QE
      ),
      hideR(1);
      QE
    )
  );

  tactic diall as (
    diffInvariant("t>=0", 1);
    diffInvariant("isWellformedDir(dx,dy)", 1);
    diffInvariant("-t*V <= xo - old(xo) & xo - old(xo) <= t*V", 1);
    diffInvariant("-t*V <= yo - old(yo) & yo - old(yo) <= t*V", 1)
  );

  tactic dib as (
    diall;
    diffInvariant("v = old(v) - b*t", 1);
    diffInvariant("-t * (v + b/2*t) <= x - old(x) & x - old(x) <= t * (v + b/2*t)", 1);
    diffInvariant("-t * (v + b/2*t) <= y - old(y) & y - old(y) <= t * (v + b/2*t)", 1)
  );

  tactic di0 as (
    diall;
    diffInvariant("v = old(v)", 1);
    diffInvariant("x = old(x)", 1);
    diffInvariant("y = old(y)", 1)
  );

  tactic dia as (
    diall;
    diffInvariant("v = old(v) + A*t", 1);
    diffInvariant("-t * (v - A/2*t) <= x - old(x) & x - old(x) <= t * (v - A/2*t)", 1);
    diffInvariant("-t * (v - A/2*t) <= y - old(y) & y - old(y) <= t * (v - A/2*t)", 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print("Transforming...");
    transform("abs(x_0-xo_0)>v_0^2/(2*b)+V*v_0/b+fm+(A/b+1)*(A/2*t^2+t*(v_0+V))", 'L=="abs(x_0-xo_0)>v_0^2/(2*b)+V*v_0/b+fm+(A/b+1)*(A/2*ep^2+ep*(v_0+V))");
    hideR('R=="abs(y-yo)>stopDist(v)+fm");
    smartQE;
    print("Proved acc arithmetic")
  );

  tactic yAccArith as (
    andL('L)*;
    print("Transforming...");
    transform("abs(y_0-yo_0)>v_0^2/(2*b)+V*v_0/b+fm+(A/b+1)*(A/2*t^2+t*(v_0+V))", 'L=="abs(y_0-yo_0)>v_0^2/(2*b)+V*v_0/b+fm+(A/b+1)*(A/2*ep^2+ep*(v_0+V))");
    hideR('R=="abs(x-xo)>stopDist(v)+fm");
    smartQE;
    print("Proved acc arithmetic")
  );

  tactic robotAlwaysStops as (
    loop("loopinv(x, y, v, dx, dy, xo, yo)", 1); <(
      print("Base case..."); smartQE; print("Base case done")
      ,
      print("Use case..."); smartQE; print("Use case done")
      ,
      print("Induction step"); unfold; <(
        print("Braking branch");
        abbrv("(V^2/(2*bo)+tau*V)", "fm");
        cut("fm>=0"); <(hideL('L=="fm=(V^2/(2*bo)+tau*V)"), hideR(1); QE);
        dib; dw; prop; doall(smartQE); print("Braking branch done")
        ,
        print("Stopped branch");
        abbrv("(V^2/(2*bo)+tau*V)", "fm");
        cut("fm>=0"); <(hideL('L=="fm=(V^2/(2*bo)+tau*V)"), hideR(1); QE);
        di0; dw; prop; doall(smartQE); print("Stopped branch done")
        ,
        print("Acceleration branch");
        hideL('L == "v>0 -> abs(x-xo_0)>stopDist(v)+friendlyMargin(V) | abs(y-yo_0)>stopDist(v)+friendlyMargin(V)");
        abbrv("(V^2/(2*bo)+tau*V)", "fm");
        cut("fm>=0"); <(hideL('L=="fm=(V^2/(2*bo)+tau*V)"), hideR(1); QE);
        dia; dw;
        prop; <(
          xAccArith,
          yAccArith
        );
        print("Acceleration branch done")
      );
      print("Induction step done")
    );
    done;
    print("Robot done")
  );

  implyR(1) ; andL('L)* ; boxAnd(1) ; andR(1) ; <(
    robotAlwaysStops ; done
    ,
    MR("vxo^2+vyo^2<=V^2",1); <(
      loop("vxo^2+vyo^2<=V^2", 1); <(
        id ; done,
        id ; done,
        composeb(1) ; GV(1.1) ; composeb(1) ; GV(1.1) ; auto ; done
      )
      ,
      andL('L)* ;
      hideL('L=="A>=0");
      hideL('L=="b>0");
      obstacleCanStop
    )
  )
End.

End.

Theorem "IJRR17/Theorem 4: Passive orientation safety".
Definitions
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real W;       /* maximum steering */
  Real V;       /* maximum obstacle velocity */
  Real GammA;   /* Sensor range in radian */

  Real stopDist(Real v)   = v^2 / (2*b);
  Real stopMargin(Real v) = stopDist(v) + V*v/b;
  Real accelComp(Real v)  = ( (A/b + 1) * (A/2 * ep^2 + ep*v) );
  Real accelMargin(Real v)  = accelComp(v) + (A/b + 1)*ep*V;
  Real admissibleSeparation(Real v) = stopMargin(v) + accelMargin(v);
  Real admissibleTurnLength(Real v) = stopDist(v) + accelComp(v);

  Bool isWellformedDir(Real dx, Real dy) <-> dx^2 + dy^2 = 1;       /* The orientation of the robot is a unit vector. */

  Bool isVisible(Real x) <-> x>0;  /* Indicates whether or not the obstacle is visible for the robot at the decision. */

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A >= 0                                                                                        /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & V >= 0
    & GammA > 0
  );

  /* Stopped somewhere safe initially */
  Bool initialState(Real x, Real y, Real v, Real beta, Real r, Real dx, Real dy, Real xo, Real yo) <-> (
    v = 0
    & beta = 0
    & r != 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir(dx,dy)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real beta, Real r, Real dx, Real dy, Real xo, Real yo) <->
    bounds() & initialState(x, y, v, beta, r, dx, dy, xo, yo);

  /* Conditions that are true on each loop iteration */
  Bool loopinv(Real x, Real y, Real v, Real beta, Real visDeg, Real r, Real dx, Real dy, Real xo, Real yo) <-> (
    v >= 0
    & isWellformedDir(dx,dy)
    & r != 0
    & (v>0 -> ( (abs(x-xo) > stopMargin(v) | abs(y-yo) > stopMargin(v))
              | (!isVisible(visDeg) & abs(beta) + stopDist(v)/abs(r) < GammA )) )
  );
End.

ProgramVariables
  Real x;    /* robot position: x */
  Real y;    /* robot position: y */
  Real v;    /* robot translational velocity */
  Real a;    /* robot translational acceleration */
  Real dx;   /* robot orientation: x */
  Real dy;   /* robot orientation: y */
  Real w;    /* robot rotational velocity */
  Real r;    /* robot curve radius */
  Real xo;   /* position of closest obstacle on curve */
  Real yo;
  Real vxo;  /* velocity vector of obstacle */
  Real vyo;
  Real t;    /* time */
  Real beta; /* Angle that the robot traveled since it last chose a new curve */
  Real visDeg; /* Indicates the "degree" to which the obstacle is visible to the robot (input to isVisible) */
End.

Problem
  assumptions(x, y, v, beta, r, dx, dy, xo, yo) -> [
      {
        {
        /* obstacle control */
        {
          vxo := *;
          vyo := *;
          ?vxo^2+vyo^2 <= V^2;
        }

        /* robot control */
        {
           /* brake on current curve. If the velocity is zero this just means that the robot remains stopped */
           {a := -b;}
        ++ /* When we are stopped, both translational and rotational acceleration are 0 */
           {?v=0; a := 0; w := 0;}
        ++ /* or choose a new safe curve */
           {a := A;
            beta := 0;
            r :=*; ?r!=0;

            /* measure obstacle position and whether or not it is visible to the robot */
            xo := *; yo := *; visDeg := *;
            ?(isVisible(visDeg) ->
               ( abs(x-xo) > admissibleSeparation(v)
               | abs(y-yo) > admissibleSeparation(v)) );
            ?admissibleTurnLength(v) < GammA*abs(r);
            }
        }

        /* Reset the clocks */
        t := 0;
        /* Set w according to physics (rigid body motion) */
        w :=*; ?w*r = v;
        }

        {x' = v * dx, y' = v * dy, dx' = -w * dy, dy' = w * dx, v' = a, w' = a/r, beta'=w,
                      xo' = vxo, yo' = vyo, t' = 1 & (t <= ep & v >= 0)}
      }*
    ] (v > 0 -> ((x - xo)^2 + (y - yo)^2 > 0 | (!isVisible(visDeg) & (abs(beta) < GammA))) )
End.

Tactic "Proof Theorem 4: Passive orientation safety".
  tactic dIHide as (
    hideL('L~="v>0->(abs(x-xo)>v^2/(2*b)+V*v/b|abs(y-yo)>v^2/(2*b)+V*v/b)|!visDeg>0&abs(beta)+v^2/(2*b)/abs(r) < GammA")*
  );

  tactic diall as (
    print("diall");
    diffInvariant("t>=0", 1);
    diffInvariant("isWellformedDir(dx,dy)", 1);
    dC("(-t*V <= xo - old(xo) & xo - old(xo) <= t*V)
       & (-t*V <= yo - old(yo) & yo - old(yo) <= t*V)", 1); <(nil, dIHide; boxAnd(1); andR(1); doall(dI(1)));
    diffInvariant("w*r=v", 1)
  );

  tactic dib as (
    diall;
    diffInvariant("v = old(v) - b*t", 1);
    diffInvariant("beta = old(beta) + t/r*(v + b/2*t)", 1);
    dC("(-t * (v + b/2*t) <= x - old(x) & x - old(x) <= t * (v + b/2*t))
       & (-t * (v + b/2*t) <= y - old(y) & y - old(y) <= t * (v + b/2*t))", 1); <(nil, dIHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic di0 as (
    diall;
    diffInvariant("v = old(v)", 1);
    diffInvariant("beta = old(beta)", 1);
    dC("x = old(x) & y = old(y)", 1); <(nil, dIHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic dia as (
    diall;
    diffInvariant("v = old(v) + A*t", 1);
    diffInvariant("beta = old(beta) + t/r*(v - A/2*t)", 1);
    dC("(-t * (v - A/2*t) <= x - old(x) & x - old(x) <= t * (v - A/2*t))
       & (-t * (v - A/2*t) <= y - old(y) & y - old(y) <= t * (v - A/2*t))", 1); <(nil, dIHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic dw as (andL('L)*; dW(1));

  tactic qeHide as (
    hideL('L~="w*r=v")*;
    hideL('L~="dx^2+dy^2=1")*
  );

  tactic xAccArith as (
    hideR('R=="abs(y-yo)>stopMargin(v)");
    hideL('L=="-t*(v-A/2*t)<=y-y_0");
    hideL('L=="y-y_0<=t*(v-A/2*t)");
    hideL('L=="-t*V<=yo-yo_0");
    hideL('L=="yo-yo_0<=t*V");
    print("Transforming...");
    transform("abs(x_0-xo_0)>v_0^2/(2*b)+V*v_0/b+((A/b+1)*(A/2*t^2+t*v_0)+(A/b+1)*t*V)", 'L=="abs(x_0-xo_0)>admissibleSeparation(v_0)");
    smartQE;
    print("Proved acc arithmetic")
  );

  tactic yAccArith as (
    hideR('R=="abs(x-xo)>stopMargin(v)");
    hideL('L=="-t*(v-A/2*t)<=x-x_0");
    hideL('L=="x-x_0<=t*(v-A/2*t)");
    hideL('L=="-t*V<=xo-xo_0");
    hideL('L=="xo-xo_0<=t*V");
    print("Transforming...");
    transform("abs(y_0-yo_0)>v_0^2/(2*b)+V*v_0/b+((A/b+1)*(A/2*t^2+t*v_0)+(A/b+1)*t*V)", 'L=="abs(y_0-yo_0)>admissibleSeparation(v_0)");
    smartQE;
    print("Proved acc arithmetic")
  );

  implyR(1); andL('L)*; loop("loopinv(x, y, v, beta, visDeg, r, dx, dy, xo, yo)", 1); <(
    print("Base case..."); smartQE; print("Base case done")
    ,
    print("Use case..."); smartQE; print("Use case done")
    ,
    print("Induction step"); unfold; <(
      print("Braking branch"); dib; dw; prop ; doall(qeHide; smartQE); print("Braking branch done")
      ,
      print("Stopped branch"); di0; dw; prop; doall(qeHide; smartQE); print("Stopped branch done")
      ,
      print("Acceleration branch");
      hideL('L == "v>0->((abs(x-xo_0)>stopMargin(v)|abs(y-yo_0)>stopMargin(v))|!isVisible(visDeg_0)&abs(beta_0)+stopDist(v)/abs(r_0) < GammA)");
      unfold;
      dia; dw;
      print("Acceleration arithmetic");
      andL('L)* ; fullSimplify ; implyR(1) ; orR(1) ; orR(1) ;
      implyL('L=="isVisible(visDeg) -> ( abs(x_0-xo_0) > admissibleSeparation(v_0) | abs(y_0-yo_0) > admissibleSeparation(v_0))") ; <(
        hideR('R=="abs(x-xo)>stopMargin(v)") ; hideR('R=="abs(y-yo)>stopMargin(v)") ; andR(1) ; doall(smartQE)
        ,
        print("Acc Distance");
        hideL('L=="admissibleTurnLength(v_0) < GammA*abs(r)") ;
        hideR('R=="visDeg<=0 & abs(beta) + stopDist(v)/abs(r) < GammA");
        hideL('L=="r_0!=0");
        hideL('L=="vxo^2+vyo^2<=V^2");
        hideL('L=="dx^2+dy^2=1");
        hideL('L=="GammA>0");
        hideL('L=="beta_0=0");
        hideL('L=="w*r=v");
        hideL('L=="beta=beta_0+t/r*(v-A/2*t)");
        orL('L=="abs(x_0-xo_0)>admissibleSeparation(v_0) | abs(y_0-yo_0)>admissibleSeparation(v_0)"); <(
          xAccArith
          ,
          yAccArith
        )
      );
      print("Acceleration branch done")
    );
    print("Induction step done")
  );
  done;
  print("Proof done")

End.

End.

Theorem "IJRR17/Theorem 5: Passive safety with actual acceleration".

Definitions
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real W;       /* maximum steering */
  Real V;       /* maximum obstacle velocity */

  Real stopDist(Real v) = v^2 / (2*b) + V*v/b;
  Real accelComp(Real v, Real a) = ((a/b + 1) * (a/2 * ep^2 + ep*(v+V)));
  Real admissibleSeparationG(Real v, Real a) = stopDist(v) + accelComp(v,a);
  Real admissibleSeparationL(Real v, Real a) = -v^2/(2*a)-V*v/a;

  Bool isWellformedDir(Real dx, Real dy) <-> dx^2 + dy^2 = 1;       /* The orientation of the robot is a unit vector. */

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A >= 0                                                                                        /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & V >= 0
  );

  /* Stopped somewhere safe initially */
  Bool initialState(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir(dx,dy)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <->
    bounds() & initialState(x, y, v, dx, dy, xo, yo);

  /* Conditions that are true on each loop iteration */
  Bool loopinv(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v >= 0
    & isWellformedDir(dx,dy)
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  );
End.

ProgramVariables
  Real x;    /* robot position: x */
  Real y;    /* robot position: y */
  Real v;    /* robot translational velocity */
  Real a;    /* robot translational acceleration */
  Real dx;   /* robot orientation: x */
  Real dy;   /* robot orientation: y */
  Real w;    /* robot rotational velocity */
  Real r;    /* robot curve radius */
  Real xo;   /* position of closest obstacle on curve */
  Real yo;
  Real vxo;  /* velocity vector of obstacle */
  Real vyo;
  Real t;    /* time */
End.

Problem
assumptions(x, y, v, dx, dy, xo, yo) ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
          ++
          /* or choose a new safe curve */
          { a := *; ?-b<=a & a<=A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            if (v+a*ep>=0) { ?abs(x-xo) > admissibleSeparationG(v,a) | abs(y-yo) > admissibleSeparationG(v,a); }
            else           { ?abs(x-xo) > admissibleSeparationL(v,a) | abs(y-yo) > admissibleSeparationL(v,a); }
          }
        };
        t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv(x, y, v, dx, dy, xo, yo))
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 5: Passive safety with actual acceleration".
  tactic dIHide as (
    hideL('L~="v>0->abs(x-xo_0)>v^2/(2*b)+V*v/b|abs(y-yo_0)>v^2/(2*b)+V*v/b")*;
    hideL('L~="abs(x-xo)>v^2/(2*b)+V*v/b+(a/b+1)*(a/2*ep^2+ep*(v+V))|abs(y-yo)>v^2/(2*b)+V*v/b+(a/b+1)*(a/2*ep^2+ep*(v+V))")*
  );

  tactic diall as (
    diffInvariant("t>=0", 'R);
    diffInvariant("isWellformedDir(dx,dy)", 'R);
    dC("(-t*V <= xo - old(xo) & xo - old(xo) <= t*V)
       & (-t*V <= yo - old(yo) & yo - old(yo) <= t*V)", 'R); <(nil, dIHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic dib as (
    diall;
    diffInvariant("v = old(v) - b*t", 'R);
    diffInvariant("-t * (v + b/2*t) <= x - old(x) & x - old(x) <= t * (v + b/2*t)", 'R);
    diffInvariant("-t * (v + b/2*t) <= y - old(y) & y - old(y) <= t * (v + b/2*t)", 'R)
  );

  tactic di0 as (
    diall;
    diffInvariant("v = old(v)", 'R);
    diffInvariant("x = old(x)", 'R);
    diffInvariant("y = old(y)", 'R)
  );

  tactic dia as (
    diall;
    diffInvariant("v = old(v) + a*t", 'R);
    diffInvariant("-t * (v - a/2*t) <= x - old(x) & x - old(x) <= t * (v - a/2*t)", 'R);
    diffInvariant("-t * (v - a/2*t) <= y - old(y) & y - old(y) <= t * (v - a/2*t)", 'R)
  );

  tactic dw as (andL('L)*; dW('R));

  tactic xAccArith as (
    andL('L)*;
    print("Transforming...");
    ?(transform("abs(x_0-xo_0)>stopDist(v_0) + (a/b+1)*(a/2*t^2 + t*(v_0+V))", 'L=="abs(x_0-xo_0)>stopDist(v_0) + (a/b+1)*(a/2*ep^2 + ep*(v_0+V))"));
    hideL('L~="dx^2+dy^2=1")*;
    hideL('L~="r*w=v")*;
    hideL('L=="vxo^2+vyo^2<=V^2");
    hideR('R=="abs(y-yo)>stopDist(v)");
    smartQE;
    print("Proved acc arithmetic")
  );

  tactic yAccArith as (
    andL('L)*;
    print("Transforming...");
    ?(transform("abs(y_0-yo_0)>stopDist(v_0) + (a/b+1)*(a/2*t^2 + t*(v_0+V))", 'L=="abs(y_0-yo_0)>stopDist(v_0) + (a/b+1)*(a/2*ep^2 + ep*(v_0+V))"));
    hideL('L~="dx^2+dy^2=1")*;
    hideL('L~="r*w=v")*;
    hideL('L=="vxo^2+vyo^2<=V^2");
    hideR('R=="abs(x-xo)>stopDist(v)");
    smartQE;
    print("Proved acc arithmetic")
  );

  implyR(1); andL('L)*; loop("loopinv(x, y, v, dx, dy, xo, yo)", 1); <(
    print("Base case..."); smartQE; print("Base case done")
    ,
    print("Use case..."); smartQE; print("Use case done")
    ,
    print("Induction step"); unfold; <(
      print("Braking branch"); dib; dw; prop; doall(smartQE); print("Braking branch done")
      ,
      print("Stopped branch"); di0; dw; prop; doall(smartQE); print("Stopped branch done")
      ,
      print("Free driving non-stopping branch");
      hideL('L == "v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)");
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print("Free driving non-stopping branch done")
      ,
      print("Free driving stopping branch");
      hideL('L == "v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)");
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print("Free driving stopping branch done")
    );
    print("Induction step done")
  );
  done;
  print("Proof done")

End.

End.

Theorem "IJRR17/Theorem 6: Passive safety despite location uncertainty".

Definitions
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real W;       /* maximum steering */
  Real V;       /* maximum obstacle velocity */
  Real Dp;      /* maximum location uncertainty */

  Real stopDist(Real v) = v^2 / (2*b) + V*v/b;
  Real accelComp(Real v) = ((A/b + 1) * (A/2 * ep^2 + ep*(v+V)) + Dp);
  Real admissibleSeparation(Real v) = stopDist(v) + accelComp(v);

  Bool isWellformedDir(Real dx, Real dy) <-> dx^2 + dy^2 = 1;       /* The orientation of the robot is a unit vector. */

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A >= 0                                                                                        /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & V >= 0
    & Dp >= 0
  );

  /* Stopped somewhere safe initially */
  Bool initialState(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir(dx,dy)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <->
    bounds() & initialState(x, y, v, dx, dy, xo, yo);

  /* Conditions that are true on each loop iteration */
  Bool loopinv(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v >= 0
    & isWellformedDir(dx,dy)
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  );
End.

ProgramVariables
  Real x;    /* robot position: x */
  Real y;    /* robot position: y */
  Real mx;   /* robot measured position: x */
  Real my;   /* robot measured position: y */
  Real v;    /* robot translational velocity */
  Real a;    /* robot translational acceleration */
  Real dx;   /* robot orientation: x */
  Real dy;   /* robot orientation: y */
  Real w;    /* robot rotational velocity */
  Real r;    /* robot curve radius */
  Real xo;   /* position of closest obstacle on curve */
  Real yo;
  Real vxo;  /* velocity vector of obstacle */
  Real vyo;
  Real t;    /* time */
End.

Problem
assumptions(x, y, v, dx, dy, xo, yo) ->
  [
    {
      {
        /* locate */
        {
          mx := *; my := *;
          ?(mx-x)^2+(my-y)^2 <= Dp^2;
        }
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
          ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(mx-xo) > admissibleSeparation(v)
            | abs(my-yo) > admissibleSeparation(v);
          }
        };
        t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv(x, y, v, dx, dy, xo, yo))
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 6: Passive safety despite location uncertainty".
  tactic dIHide as (
    hideL('L~="v>0->abs(x-xo_0)>v^2/(2*b)+V*v/b|abs(y-yo_0)>v^2/(2*b)+V*v/b")*;
    hideL('L~="abs(mx-xo)>v^2/(2*b)+V*v/b+((A/b+1)*(A/2*ep^2+ep*(v+V))+Dp)|abs(my-yo)>v^2/(2*b)+V*v/b+((A/b+1)*(A/2*ep^2+ep*(v+V))+Dp)")*
  );

  tactic diall as (
    diffInvariant("t>=0", 1);
    diffInvariant("isWellformedDir(dx,dy)", 1);
    dC("(-t*V <= xo - old(xo) & xo - old(xo) <= t*V)
       & (-t*V <= yo - old(yo) & yo - old(yo) <= t*V)", 1); <(nil, dIHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic dib as (
    diall;
    diffInvariant("v = old(v) - b*t", 1);
    diffInvariant("-t * (v + b/2*t) <= x - old(x) & x - old(x) <= t * (v + b/2*t)", 1);
    diffInvariant("-t * (v + b/2*t) <= y - old(y) & y - old(y) <= t * (v + b/2*t)", 1)
  );

  tactic di0 as (
    diall;
    diffInvariant("v = old(v)", 1);
    diffInvariant("x = old(x)", 1);
    diffInvariant("y = old(y)", 1)
  );

  tactic dia as (
    diall;
    diffInvariant("v = old(v) + A*t", 1);
    diffInvariant("-t * (v - A/2*t) <= x - old(x) & x - old(x) <= t * (v - A/2*t)", 1);
    diffInvariant("-t * (v - A/2*t) <= y - old(y) & y - old(y) <= t * (v - A/2*t)", 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    hideL('L~="r*w=v")*;
    hideL('L~="dx^2+dy^2=1")*;
    hideL('L=="vxo^2+vyo^2<=V^2");
    print("Transforming...");
    transform("abs(mx-xo_0)>v_0^2/(2*b)+V*v_0/b+(A/b+1)*(A/2*t^2+t*(v_0+V))+Dp", 'L=="abs(mx-xo_0)>admissibleSeparation(v_0)");
    hideL('L=="t<=ep");
    transform("abs(x_0-xo_0)>v_0^2/(2*b)+V*v_0/b+(A/b+1)*(A/2*t^2+t*(v_0+V))", 'L=="abs(mx-xo_0)>v_0^2/(2*b)+V*v_0/b+(A/b+1)*(A/2*t^2+t*(v_0+V))+Dp");
    hideL('L=="(mx-x_0)^2+(my-y_0)^2<=Dp^2");
    hideR('R=="abs(y-yo)>stopDist(v)");
    smartQE;
    print("Proved acc arithmetic")
  );

  tactic yAccArith as (
    andL('L)*;
    hideL('L~="r*w=v")*;
    hideL('L~="dx^2+dy^2=1")*;
    hideL('L=="vxo^2+vyo^2<=V^2");
    print("Transforming...");
    transform("abs(my-yo_0)>v_0^2/(2*b)+V*v_0/b+(A/b+1)*(A/2*t^2+t*(v_0+V))+Dp", 'L=="abs(my-yo_0)>admissibleSeparation(v_0)");
    hideL('L=="t<=ep");
    transform("abs(y_0-yo_0)>v_0^2/(2*b)+V*v_0/b+(A/b+1)*(A/2*t^2+t*(v_0+V))", 'L=="abs(my-yo_0)>v_0^2/(2*b)+V*v_0/b+(A/b+1)*(A/2*t^2+t*(v_0+V))+Dp");
    hideL('L=="(mx-x_0)^2+(my-y_0)^2<=Dp^2");
    hideR('R=="abs(x-xo)>stopDist(v)");
    smartQE;
    print("Proved acc arithmetic")
  );

  implyR(1); andL('L)*; loop("loopinv(x, y, v, dx, dy, xo, yo)", 1); <(
    print("Base case..."); smartQE; print("Base case done")
    ,
    print("Use case..."); smartQE; print("Use case done")
    ,
    print("Induction step"); unfold; <(
      print("Braking branch"); dib; dw; prop; doall(smartQE); print("Braking branch done")
      ,
      print("Stopped branch"); di0; dw; prop; doall(smartQE); print("Stopped branch done")
      ,
      print("Acceleration branch");
      hideL('L == "v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)");
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print("Acceleration branch done")
    );
    print("Induction step done")
  );
  done;
  print("Proof done")

End.

End.

Theorem "IJRR17/Theorem 7: Passive safety despite actuator perturbation".

Definitions
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real W;       /* maximum steering */
  Real V;       /* maximum obstacle velocity */
  Real Da;      /* maximum actuator perturbation 0< Da <= 1 (robot will not loose brakes entirely) */

  Real stopDist(Real v) = v^2 / (2*(b*Da)) + V*v/(b*Da);
  Real accelComp(Real v) = ( (A/(b*Da) + 1) * (A/2 * ep^2 + ep*(v+V)) );
  Real admissibleSeparation(Real v) = stopDist(v) + accelComp(v);

  Bool isWellformedDir(Real dx, Real dy) <-> dx^2 + dy^2 = 1;       /* The orientation of the robot is a unit vector. */

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A >= 0                                                                                        /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & V >= 0
    & 0 < Da & Da <= 1
  );

  /* Stopped somewhere safe initially */
  Bool initialState(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir(dx,dy)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <->
    bounds() & initialState(x, y, v, dx, dy, xo, yo);

  /* Conditions that are true on each loop iteration */
  Bool loopinv(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v >= 0
    & isWellformedDir(dx,dy)
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  );
End.

ProgramVariables
  Real x;    /* robot position: x */
  Real y;    /* robot position: y */
  Real v;    /* robot translational velocity */
  Real a;    /* robot control choice: translational acceleration */
  Real da;   /* robot actuator disturbance */
  Real acc;  /* robot actual translational acceleration */
  Real dx;   /* robot orientation: x */
  Real dy;   /* robot orientation: y */
  Real w;    /* robot rotational velocity */
  Real r;    /* robot curve radius */
  Real xo;   /* position of closest obstacle on curve */
  Real yo;
  Real vxo;  /* velocity vector of obstacle */
  Real vyo;
  Real t;    /* time */
End.

Problem
assumptions(x, y, v, dx, dy, xo, yo) ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
          ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
        /* actuator perturbation */
        {
          da := *; ?(Da<=da & da<=1); acc := da*a;
        };
        t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = acc,      /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = acc/r, /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv(x, y, v, dx, dy, xo, yo))
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 7: Passive safety despite actuator perturbation".
  tactic dIHide as (
    hideL('L~="v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v)")*;
    hideL('L~="abs(x-xo)>admissibleSeparation(v)|abs(y-yo)>admissibleSeparation(v)")*
  );

  tactic diall as (
    diffInvariant("t>=0", 1);
    diffInvariant("isWellformedDir(dx,dy)", 1);
    dC("(-t*V <= xo - old(xo) & xo - old(xo) <= t*V)
       & (-t*V <= yo - old(yo) & yo - old(yo) <= t*V)", 1); <(nil, dIHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic dib as (
    diall;
    dC("v <= old(v) - (b*Da)*t", 1); <(nil, dIHide; dI(1));
    dC("(-t * (old(v) - (b*Da)/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - (b*Da)/2*t))
        & -t * (old(v) - (b*Da)/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - (b*Da)/2*t)", 1); <(nil, dIHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic di0 as (
    diall;
    diffInvariant("v = old(v)", 1);
    diffInvariant("x = old(x)", 1);
    diffInvariant("y = old(y)", 1)
  );

  tactic dia as (
    diall;
    dC("v <= old(v) + A*t", 1); <(nil, dIHide; dI(1));
    dC("(-t * (old(v) + A/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A/2*t))
       & (-t * (old(v) + A/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A/2*t))", 1); <(nil, dIHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    hideL('L=="r!=0");
    hideL('L=="vxo^2+vyo^2<=V^2");
    hideL('L=="dx^2+dy^2=1");
    hideL('L=="-t*(v_0+A/2*t)<=y-y_0");
    hideL('L=="y-y_0<=t*(v_0+A/2*t)");
    hideL('L=="-t*V<=yo-yo_1");
    hideL('L=="yo-yo_1<=t*V");
    print("Transforming...");
    transform("abs(x_0-xo_1)>v_0^2/(2*(b*Da))+V*v_0/(b*Da)+(A/(b*Da)+1)*(A/2*t^2+t*(v_0+V))", 'L~="abs(x-xo)>admissibleSeparation(v)");
    hideR('R=="abs(y-yo)>stopDist(v)");
    abbrv("b*Da","actB"); cut("actB>0"); <(hideL('L=="actB=b*Da"), hideR(1); smartQE);
    hideL('L=="t<=ep");
    hideL('L=="b>0");
    hideL('L=="ep>0");
    hideL('L=="0<Da");
    hideL('L=="Da<=1");
    hideL('L=="Da<=da");
    hideL('L=="da<=1");
    hideL('L=="v>=0");
    smartQE;
    print("Proved acc arithmetic")
  );

  tactic yAccArith as (
    andL('L)*;
    hideL('L=="r!=0");
    hideL('L=="vxo^2+vyo^2<=V^2");
    hideL('L=="dx^2+dy^2=1");
    hideL('L=="-t*(v_0+A/2*t)<=x-x_0");
    hideL('L=="x-x_0<=t*(v_0+A/2*t)");
    hideL('L=="-t*V<=xo-xo_1");
    hideL('L=="xo-xo_1<=t*V");
    print("Transforming...");
    transform("abs(y_0-yo_1)>v_0^2/(2*(b*Da))+V*v_0/(b*Da)+(A/(b*Da)+1)*(A/2*t^2+t*(v_0+V))", 'L~="abs(y-yo)>admissibleSeparation(v)");
    hideR('R=="abs(x-xo)>stopDist(v)");
    abbrv("b*Da","actB"); cut("actB>0"); <(hideL('L=="actB=b*Da"), hideR(1); smartQE);
    hideL('L=="t<=ep");
    hideL('L=="b>0");
    hideL('L=="ep>0");
    hideL('L=="0<Da");
    hideL('L=="Da<=1");
    hideL('L=="Da<=da");
    hideL('L=="da<=1");
    smartQE;
    print("Proved acc arithmetic")
  );

  implyR(1); andL('L)*; loop("loopinv(x, y, v, dx, dy, xo, yo)", 1); <(
    print("Base case..."); QE; print("Base case done")
    ,
    print("Use case..."); QE; print("Use case done")
    ,
    print("Induction step"); unfold; <(
      print("Braking branch"); dib; dw; abbrv("b*Da","actB"); cut("actB>0"); <(hideL('L=="actB=b*Da"), hideR(1); smartQE);
      prop;
      doall(hideL('L=="dx^2+dy^2=1"); hideL('L=="vxo^2+vyo^2<=V^2");
        hideL('L=="t<=ep"); hideL('L=="ep>0"); hideL('L=="A>=0");
        print("Braking QE"); smartQE);
      print("Braking branch done")
      ,
      print("Stopped branch"); di0; dw; prop; doall(print("Stopped QE"); smartQE); print("Stopped branch done")
      ,
      print("Acceleration branch");
      dia; dw;
      andL('L)*;
      hideL('L~="v>0->abs(x-xo)>v^2/(2*(b*Da))+V*v/(b*Da)|abs(y-yo)>v^2/(2*(b*Da))+V*v/(b*Da)");
      prop; <(
        xAccArith,
        yAccArith
      );
      print("Acceleration branch done")
    );
    print("Induction step done")
  );
  done;
  print("Proof done")

End.

End.

Theorem "IJRR17/Theorem 8: Passive safety despite velocity uncertainty".

Definitions
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real W;       /* maximum steering */
  Real V;       /* maximum obstacle velocity */
  Real DV;      /* maximum velocity uncertainty */

  Real stopDist(Real v) = v^2 / (2*b) + V*v/b;
  Real accelComp(Real v) = ( (A/b + 1) * (A/2 * ep^2 + ep*(v+V)) );
  Real admissibleSeparation(Real v) = stopDist(v) + accelComp(v);

  Bool isWellformedDir(Real dx, Real dy) <-> dx^2 + dy^2 = 1;       /* The orientation of the robot is a unit vector. */

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A >= 0                                                                                        /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & V >= 0
    & DV >= 0
  );

  /* Stopped somewhere safe initially */
  Bool initialState(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir(dx,dy)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <->
    bounds() & initialState(x, y, v, dx, dy, xo, yo);

  /* Conditions that are true on each loop iteration */
  Bool loopinv(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v >= 0
    & isWellformedDir(dx,dy)
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  );
End.

ProgramVariables
  Real x;    /* robot position: x */
  Real y;    /* robot position: y */
  Real v;    /* robot translational velocity */
  Real mv;   /* robot measured velocity */
  Real a;    /* robot control choice: translational acceleration */
  Real dx;   /* robot orientation: x */
  Real dy;   /* robot orientation: y */
  Real w;    /* robot rotational velocity */
  Real r;    /* robot curve radius */
  Real xo;   /* position of closest obstacle on curve */
  Real yo;
  Real vxo;  /* velocity vector of obstacle */
  Real vyo;
  Real t;    /* time */
End.

Problem
assumptions(x, y, v, dx, dy, xo, yo) ->
  [
    {
      {
        /* sense */
        {
          mv := *; ?0<=mv & v-DV<=mv & mv<=v+DV;
        }
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
          ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(mv+DV)
            | abs(y-yo) > admissibleSeparation(mv+DV);
          }
        };
        t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv(x, y, v, dx, dy, xo, yo))
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 8: Passive safety despite velocity uncertainty".
  tactic dIHide as (
    hideL('L~="v>0->abs(x-xo)>v^2/(2*b)+V*v/b|abs(y-yo)>v^2/(2*b)+V*v/b")*;
    hideL('L~="abs(x-xo)>(mv+DV)^2/(2*b)+V*(mv+DV)/b+(A/b+1)*(A/2*ep^2+ep*(mv+DV+V))|abs(y-yo)>(mv+DV)^2/(2*b)+V*(mv+DV)/b+(A/b+1)*(A/2*ep^2+ep*(mv+DV+V))")*
  );

  tactic preQEHide as (
    andL('L)*;
    hideL('L~="dx^2+dy^2=1");
    hideL('L~="vxo^2+vyo^2<=V^2")
  );

  tactic diall as (
    diffInvariant("t>=0", 1);
    diffInvariant("isWellformedDir(dx,dy)", 1);
    dC("(-t*V <= xo - old(xo) & xo - old(xo) <= t*V)
       & (-t*V <= yo - old(yo) & yo - old(yo) <= t*V)", 1); <(nil, dIHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic dib as (
    diall;
    dC("v <= old(v) - b*t", 1); <(nil, dIHide; dI(1));
    dC("(-t * (old(v) - b/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - b/2*t))
       & (-t * (old(v) - b/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - b/2*t))", 1); <(nil, dIHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic di0 as (
    diall;
    diffInvariant("v = old(v)", 1);
    diffInvariant("x = old(x)", 1);
    diffInvariant("y = old(y)", 1)
  );

  tactic dia as (
    diall;
    dC("v <= old(v) + A*t", 1); <(nil, dIHide; dI(1));
    dC("(-t * (old(v) + A/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A/2*t))
       & (-t * (old(v) + A/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A/2*t))", 1); <(nil, dIHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    hideL('L=="-t*(v_0+A/2*t)<=y-y_0");
    hideL('L=="y-y_0<=t*(v_0+A/2*t)");
    hideL('L=="-t*V<=yo-yo_0");
    hideL('L=="yo-yo_0<=t*V");
    hideL('L=="r!=0");
    print("Transforming...");
    transform("abs(x_0-xo_0)>(mv+DV)^2/(2*b)+V*(mv+DV)/b+(A/b+1)*(A/2*t^2+t*((mv+DV)+V))", 'L~="abs(x-xo)>admissibleSeparation(mv+DV)");
    hideL('L=="t<=ep");
    hideL('L=="ep>0");
    hideR('R=="abs(y-yo)>stopDist(v)");
    transform("abs(x_0-xo_0)>v_0^2/(2*b)+V*v_0/b+(A/b+1)*(A/2*t^2+t*(v_0+V))", 'L~="abs(x_0-xo_0)>(mv+DV)^2/(2*b)+V*(mv+DV)/b+(A/b+1)*(A/2*t^2+t*((mv+DV)+V))");
    smartQE;
    print("Proved acc arithmetic")
  );

  tactic yAccArith as (
    hideL('L=="-t*(v_0+A/2*t)<=x-x_0");
    hideL('L=="x-x_0<=t*(v_0+A/2*t)");
    hideL('L=="-t*V<=xo-xo_0");
    hideL('L=="xo-xo_0<=t*V");
    hideL('L=="r!=0");
    print("Transforming...");
    transform("abs(y_0-yo_0)>(mv+DV)^2/(2*b)+V*(mv+DV)/b+(A/b+1)*(A/2*t^2+t*((mv+DV)+V))", 'L~="abs(y-yo)>admissibleSeparation(mv+DV)");
    hideL('L=="t<=ep");
    hideL('L=="ep>0");
    hideR('R=="abs(x-xo)>stopDist(v)");
    transform("abs(y_0-yo_0)>v_0^2/(2*b)+V*v_0/b+(A/b+1)*(A/2*t^2+t*(v_0+V))", 'L~="abs(y_0-yo_0)>(mv+DV)^2/(2*b)+V*(mv+DV)/b+(A/b+1)*(A/2*t^2+t*((mv+DV)+V))");
    smartQE;
    print("Proved acc arithmetic")
  );

  implyR(1); andL('L)*; loop("loopinv(x, y, v, dx, dy, xo, yo)", 1); <(
    print("Base case..."); smartQE; print("Base case done")
    ,
    print("Use case..."); smartQE; print("Use case done")
    ,
    print("Induction step"); unfold; <(
      print("Braking branch"); dib; dw; prop; doall(print("Braking QE"); preQEHide; smartQE); print("Braking branch done")
      ,
      print("Stopped branch"); di0; dw; prop; doall(preQEHide; smartQE); print("Stopped branch done")
      ,
      print("Acceleration branch");
      hideL('L~="v>0 -> abs(x-xo)>stopDist(v) | abs(y-yo)>stopDist(v)");
      dia; dw;
      prop; <(
        preQEHide; xAccArith,
        preQEHide; yAccArith
      );
      print("Acceleration branch done")
    );
    print("Induction step done")
  );
  done;
  print("Proof done")

End.

End.

Theorem "IJRR17/Theorem 9: Passive safety for asynchronous controllers".

Definitions
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real W;       /* maximum steering */
  Real V;       /* maximum obstacle velocity */

  Real stopDist(Real v) = v^2 / (2*b) + V*v/b;
  Real accelComp(Real v) = ((A/b + 1) * (A/2 * ep^2 + ep*(v+V)));
  Real admissibleSeparation(Real v) = stopDist(v) + accelComp(v);

  Bool isWellformedDir(Real dx, Real dy) <-> dx^2 + dy^2 = 1;       /* The orientation of the robot is a unit vector. */

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A >= 0                                                                                        /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & V >= 0
  );

  /* Stopped somewhere safe initially */
  Bool initialState(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir(dx,dy)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <->
    bounds() & initialState(x, y, v, dx, dy, xo, yo);

  /* Conditions that are true on each loop iteration */
  Bool loopinv(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v >= 0
    & isWellformedDir(dx,dy)
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  );

  Bool innerloopinv(Real x, Real y, Real v, Real a, Real dx, Real dy, Real xo, Real yo, Real t) <-> (
    0<=t & t<=ep
    & v >= 0
    & isWellformedDir(dx,dy)
    & -t*V <= xo - old(xo) & xo - old(xo) <= t*V
    & -t*V <= yo - old(yo) & yo - old(yo) <= t*V
    & -t * (v - a/2*t) <= x - old(x) & x - old(x) <= t * (v - a/2*t)
    & -t * (v - a/2*t) <= y - old(y) & y - old(y) <= t * (v - a/2*t)
  );
End.

ProgramVariables
  Real x;    /* robot position: x */
  Real y;    /* robot position: y */
  Real v;    /* robot translational velocity */
  Real a;    /* robot translational acceleration */
  Real dx;   /* robot orientation: x */
  Real dy;   /* robot orientation: y */
  Real w;    /* robot rotational velocity */
  Real r;    /* robot curve radius */
  Real xo;   /* position of closest obstacle on curve */
  Real yo;
  Real vxo;  /* velocity vector of obstacle */
  Real vyo;
  Real t;    /* time */
End.

Problem
assumptions(x, y, v, dx, dy, xo, yo) ->
  [
    {
      {
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
          ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
        t := 0;
      }

      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        };
        /* dynamics */
        { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
          dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
          xo' = vxo, yo' = vyo,                    /* obstacle moves */
          t' = 1 & t <= ep & v >= 0
        }
      }*@invariant(innerloopinv(x, y, v, a, dx, dy, xo, yo, t))
    }*@invariant(loopinv(x, y, v, dx, dy, xo, yo))
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 9: Passive safety for asynchronous controllers".
  tactic dibHide as (
    hideL('L=="vxo^2+vyo^2<=V^2");
    hideL('L=="dx^2+dy^2=1");
    hideL('L~="-t*V<=xo-old(xo)")*2;
    hideL('L~="xo-old(xo)<=t*V")*2;
    hideL('L~="-t*(v+b/2*t)<=x-old(x)")*2;
    hideL('L~="x-old(x)<=t*(v+b/2*t)")*2
  );

  tactic diaHide as (
    hideL('L=="vxo^2+vyo^2<=V^2");
    hideL('L=="dx^2+dy^2=1");
    hideL('L~="-t*V<=xo-old(xo)")*2;
    hideL('L~="xo-old(xo)<=t*V")*2;
    hideL('L~="-t*(v-A/2*t)<=x-old(x)")*2;
    hideL('L~="x-old(x)<=t*(v-A/2*t)")*2
  );

  tactic diall as (
    diffInvariant("t>=old(t)", 1);
    diffInvariant("isWellformedDir(dx,dy)", 1);
    diffInvariant("-(t-old(t))*V <= xo - old(xo) & xo - old(xo) <= (t-old(t))*V", 1);
    diffInvariant("-(t-old(t))*V <= yo - old(yo) & yo - old(yo) <= (t-old(t))*V", 1)
  );

  tactic dib as (
    diall;
    dC("v = old(v) - b*(t-old(t))", 1); <(nil, dibHide; dI(1));
    dC("(-(t-old(t)) * (v + b/2*(t-old(t))) <= x - old(x) & x - old(x) <= (t-old(t)) * (v + b/2*(t-old(t))))
       & (-(t-old(t)) * (v + b/2*(t-old(t))) <= y - old(y) & y - old(y) <= (t-old(t)) * (v + b/2*(t-old(t))))", 1); <(nil, dibHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic di0 as (
    diall;
    diffInvariant("v = old(v)", 1);
    diffInvariant("x = old(x)", 1);
    diffInvariant("y = old(y)", 1)
  );

  tactic dia as (
    diall;
    dC("v = old(v) + A*(t-old(t))", 1); <(nil, diaHide; dI(1));
    dC("(-(t-old(t)) * (v - A/2*(t-old(t))) <= x - old(x) & x - old(x) <= (t-old(t)) * (v - A/2*(t-old(t))))
       & (-(t-old(t)) * (v - A/2*(t-old(t))) <= y - old(y) & y - old(y) <= (t-old(t)) * (v - A/2*(t-old(t))))", 1); <(nil, diaHide; boxAnd(1); andR(1); doall(dI(1)))
  );

  tactic dw as (andL('L)*; dW(1));

  tactic ghosts as (
    discreteGhost("v", 1) ; discreteGhost("x", 1) ; discreteGhost("y", 1) ; discreteGhost("xo", 1) ;
    discreteGhost("yo", 1) ; allR2L('Llast)*5
  );

  tactic innerUseCase as (
    andR(1) ; <(
    prop,
    andR(1) ; <(
      prop,
      implyR(1) ; orR(1) ; implyL('L=="v_0>0 -> abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)") ; <(
        QE,
        orL('L=="abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)") ; <(
          hideR('R=="abs(y-yo) > stopDist(v)"); smartQE,
          hideR('R=="abs(x-xo) > stopDist(v)"); smartQE
          )
        )
      )
    )
  );

  tactic brakingInnerLoop as (
    ghosts;
    loop("0<=t&t<=ep&v>=0&dx^2+dy^2=1&v=v_0-b*t&-t*V<=xo-xo_0&xo-xo_0<=t*V&-t*V<=yo-yo_0&yo-yo_0<=t*V&-t*(v+b/2*t)<=x-x_0&x-x_0<=t*(v+b/2*t)&-t*(v+b/2*t)<=y-y_0&y-y_0<=t*(v+b/2*t)", 1) ; <(
      QE,
      innerUseCase,
      unfold;
      hideL('L=="v_0>0 -> abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)");
      dib; dw; prop; doall(smartQE)
    )
  );

  tactic stoppedInnerLoop as (
    ghosts;
    loop("0<=t&t<=ep&v>=0&dx^2+dy^2=1&v=v_0&-t*V<=xo-xo_0&xo-xo_0<=t*V&-t*V<=yo-yo_0&yo-yo_0<=t*V&x=x_0&y=y_0", 1) ; <(
      QE,
      innerUseCase,
      unfold;
      hideL('L=="v_0>0 -> abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)");
      di0; dw; prop; doall(smartQE)
    )
  );

  tactic accInnerLoop as (
    hideL('L=="v>0 -> abs(x-xo_0) > stopDist(v) | abs(y-yo_0) > stopDist(v)") ;
    ghosts;
    loop("0<=t&t<=ep&v>=0&dx^2+dy^2=1&v=v_0+A*t&-t*V<=xo-xo_0&xo-xo_0<=t*V&-t*V<=yo-yo_0&yo-yo_0<=t*V&-t*(v-A/2*t)<=x-x_0&x-x_0<=t*(v-A/2*t)&-t*(v-A/2*t)<=y-y_0&y-y_0<=t*(v-A/2*t)", 1) ; <(
      QE,
      andR(1) ; <(
        prop,
        andR(1) ; <(
          prop,
          implyR(1) ; orR(1) ;
          orL('L=="abs(x_0-xo_0) > admissibleSeparation(v_0) | abs(y_0-yo_0) > admissibleSeparation(v_0)"); <(
            transform("abs(x_0-xo_0) > v_0^2/(2*b)+V*v_0/b+(A/b+1)*(A/2*t^2+t*(v_0+V))", 'L=="abs(x_0-xo_0)>admissibleSeparation(v_0)");
            hideR('R=="abs(y-yo) > stopDist(v)"); smartQE
            ,
            transform("abs(y_0-yo_0) > v_0^2/(2*b)+V*v_0/b+(A/b+1)*(A/2*t^2+t*(v_0+V))", 'L=="abs(y_0-yo_0)>admissibleSeparation(v_0)");
            hideR('R=="abs(x-xo) > stopDist(v)"); smartQE
          )
        )
      ),
      unfold; hideL('L=="abs(x_0-xo_0) > admissibleSeparation(v_0) | abs(y_0-yo_0) > admissibleSeparation(v_0)");
      dia; dw; prop; doall(smartQE)
    )
  );

  implyR(1); andL('L)*; loop("loopinv(x, y, v, dx, dy, xo, yo)", 1); <(
    print("Base case..."); smartQE; print("Base case done")
    ,
    print("Use case..."); smartQE; print("Use case done")
    ,
    print("Induction step"); unfold; <(
      print("Braking branch"); brakingInnerLoop; print("Braking branch done")
      ,
      print("Stopped branch"); stoppedInnerLoop; print("Stopped branch done")
      ,
      print("Acceleration branch"); accInnerLoop; print("Acceleration branch done")
    );
    print("Induction step done")
  );
  done;
  print("Proof done")

End.

End.

Theorem "IJRR17/Theorem 11: Reach waypoint".

/*
 *	Robot must stop within distance delta at goal.
 *
 *  Robot
 * 	- must stop within distance delta of goal
 *  - can only drive straight and forward
 *  - ensures progress towards goal
 *
 *  Liveness property:
 *  - Robot can stop at goal
 *
 */

Definitions.
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real GDelta;	/* goal area size */
  Real Vmax;    /* robot cannot go faster than this */

  Real waypointStartDist(Real xg) = xg-GDelta;
  Real waypointEndDist(Real xg)   = xg+GDelta;

  Real minV = A*ep;

  Real stopDist(Real v) = v^2/(2*b);
  Real accComp(Real v)  = ( (A/b + 1)*(A/2*ep^2 + ep*v) );

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A > 0                                                                                         /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & Vmax >= 2*A*ep
    & GDelta > Vmax*ep + Vmax^2/(2*b)  /* waypoint is large enough that robot can start driving and still stop inside */
  );
  Bool initialState(Real xr, Real vr, Real xg) <-> (                              /* Stopped somewhere safe initially */
    vr = 0
    & xr < waypointStartDist(xg)
  );
  Bool assumptions(Real xr, Real vr, Real xg) <->                      /* Under these assumptions we guarantee safety */
    bounds() & initialState(xr, vr, xg);

  Bool loopinv(Real xr, Real vr, Real xg) <-> 0 <= vr & vr <= Vmax & xr + stopDist(vr) < waypointEndDist(xg);

  HP ctrl ::= {
      ar := -b;
   ++ ?vr = 0; ar := 0;
   ++ ?xr + stopDist(vr) + accComp(vr) < waypointEndDist(xg) & vr+A*ep<=Vmax; ar := A;
   ++ ?xr <= waypointStartDist(xg) & vr <= Vmax; ar := *; ?-b <= ar & ar <= (Vmax-vr)/ep & ar <= A;
  };

  HP dyn ::= { {xr' = vr, vr' = ar, t' = 1 & t <= ep & vr >= 0} };

  HP dwwp ::= { { { ctrl; t:=0; } dyn; }*@invariant(loopinv(xr, vr, xg)) };
End.

ProgramVariables
  Real xr;		/* robot position: x */
  Real vr;		/* robot translational velocity */
  Real ar;		/* robot translational acceleration */
  Real xg;		/* goal position */
  Real t;		  /* control cycle time */
End.

Problem
  assumptions(xr, vr, xg)
    ->
    /* safety */
    [ dwwp; ] (xr < waypointEndDist(xg))
    &
    /* liveness */
    < dwwp; >(waypointStartDist(xg) < xr)
End.

Tactic "Proof Theorem 11: Reach waypoint".
  implyR(1) ; andL('L)* ; andR(1) ; <(
    auto,
    iterated(1) ; orR(1) ; composed(2) ; composed(2) ; choiced(2) ; orR(2) ; hideR(2) ; choiced(2) ; orR(2) ;
    hideR(2) ; choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; andR(2); <(
      QE,
      composed(2) ; randomd(2) ; existsR("min(((Vmax-vr)/ep,A))", 2) ; testd(2) ; andR(2) ; <(
        QE,
        assignd(2) ; solve(2) ; existsR("ep", 2) ; andR(2) ; <(
          QE,
          andR(2) ; <(
            QE,
            allR(2); implyR(2);
            allR(2); implyR(2);
            con("v", "Vmax>0&A>0&b>0&ep>0&0 < vr&vr<=Vmax&xg-GDelta < xr+v*ep*vr", 2) ; <(
              QE,
              QE,
              composed(1) ; composed(1) ; cut("xr<=xg-GDelta|xg-GDelta < xr") ; <(
                orL('L=="xr<=xg-GDelta|xg-GDelta < xr") ; <(
                  choiced(1) ; orR(1) ; hideR(1) ; choiced(1) ; orR(1) ; hideR(1) ; choiced(1) ; orR(1) ;
                  hideR(1) ; composed(1) ; testd(1) ; andR(1) ; <(
                    QE,
                    composed(1) ; randomd(1) ; existsR("0", 1) ; testd(1) ; andR(1) ; <(
                      QE,
                      assignd(1) ; solve(1) ; QE("Mathematica")
                      )
                    ),
                  choiced(1) ; orR(1) ; hideR(2) ; assignd(1) ; assignd(1) ; solve(1) ;
                  andL('L)*;
                  /* hide duplicate facts */
                  hideL('L=="b>0"); hideL('L=="ep>0");
                  /* hide irrelevant facts */
                  hideL('L=="vr_1=0"); hideL('L=="xr_1 < xg-GDelta"); hideL('L=="A>0")*2;
                  hideL('L=="Vmax>=2*A*ep"); hideL('L=="GDelta>Vmax*ep+Vmax^2/(2*b)");
                  QE("Mathematica")
                  ),
                hideR(1) ; QE
                )
              )
            )
          )
        )
      )
    )
End.

End.

Theorem "IJRR17/Theorem 12: Cross intersection".

/*
 *	Robot must safely cross an intersection.
 *
 *  Robot
 * 	- must cross intersection safely
 *  - can only drive straight and forward
 *  - ensures progress towards intersection
 *
 *  Obstacle
 *  - Drives forward with minimum speed (does not block intersection)
 *
 *  Intersection
 *  - At position 0 (on both the robot's and the obstacle's path)
 *
 *  Liveness property:
 *  - Robot can cross intersection
 *
 *  Safety property:
 *  - Robot and obstacle are not at the intersection at the same time
 *
 */

Definitions.
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real Vmin;    /* obstacle minimum speed */
  Real ixr = 0; /* position of intersection on path of robot */
  Real ixo = 0; /* position of intersection on path of obstacle */

  Real minV = A*ep;

  Real stopDist(Real v) = v^2/(2*b);
  Real accComp(Real v)  = ( (A/b + 1)*(A/2*ep^2 + ep*v) );

  Bool OAfterX(Real xo) <-> xo>ixo;
  Bool RAfterX(Real x) <-> x>ixr;

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A > 0                                                                                         /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & Vmin > 0
  );
  Bool initialState(Real xr, Real vr, Real ixr, Real vo) <-> (             /* Somewhere before intersection initially */
    vr = 0
    & vo>=Vmin
    & xr < ixr
  );
  Bool assumptions(Real xr, Real vr, Real ixr, Real vo) <->            /* Under these assumptions we guarantee safety */
    bounds() & initialState(xr, vr, ixr, vo);

  Bool loopinv(Real xr, Real vr, Real ixr, Real xo, Real vo) <-> (
    0 <= vr & Vmin<=vo & (RAfterX(xr) | OAfterX(xo) | xr + stopDist(vr) < ixr |
      (vr>0 & ( xo+vo*(ixr-xr)/vr+A/2*((ixr-xr)/vr)^2 < ixo
              | ixo < xo + Vmin*(ixr-xr)/vr))
    )
  );

  HP obstacle ::= { ao := *; ?-b<=ao&ao<=A; };

  HP robot ::= {
    if (RAfterX(xr) | OAfterX(xo)) {
      ar := *; ?-b<=ar&ar<=A;
    } else { if (/*PassFaster*/ vr>0 & ( xo+vo*(ixr-xr)/vr+A/2*((ixr-xr)/vr)^2 < ixo
                                       | ixo < xo + Vmin*(ixr-xr)/(vr+A*ep) ) ) {
      ar := *; ?0<=ar&ar<=A;
    } else { if (/*PassCoast*/ vr>0 & ixo < xo + Vmin*(ixr-xr)/vr) {
      ar := 0;
    } else {         /* 1D Model 3 */
        ar := -b;
     ++ ?vr = 0; ar := 0;
     ++ ?xr + stopDist(vr) + accComp(vr) < ixr; ar := A;
    }}}
  };

  HP dyn ::= { {xr' = vr, vr' = ar, xo'=vo, vo'=ao, t' = 1 & t <= ep & vr >= 0 & vo>=Vmin } };

  HP dwcx ::= {
    {	obstacle;
      { robot; t := 0; }
      dyn;
    }*@invariant(loopinv(xr, vr, ixr, xo, vo))
  };
End.

ProgramVariables
  Real xr;		/* robot position: x */
  Real vr;		/* robot translational velocity */
  Real ar;		/* robot translational acceleration */
  Real xo;		/* obstacle position */
  Real vo;   /* obstacle velocity */
  Real ao;   /* obstacle acceleration */
  Real t;		/* control cycle time */
End.

Problem
  assumptions(xr, vr, ixr, vo)
    ->
    /* safety */
    [ dwcx; ](xr=ixr -> xo!=ixo)
    &
    /* liveness */
    < dwcx; >(RAfterX(xr))
End.

Tactic "Proof Theorem 12: Cross intersection (single convergence condition)".
useSolver("Mathematica");
implyR('R=="assumptions(xr,vr,ixr(),vo)->[dwcx{|^@|};](xr=ixr()->xo!=ixo())&<dwcx{|^@|};>RAfterX(xr)");
andR('R=="[dwcx{|^@|};](xr=ixr()->xo!=ixo())&<dwcx{|^@|};>RAfterX(xr)"); <(
  "[dwcx{|^@|};](xr=ixr()->xo!=ixo())":
    expand "dwcx";
    loop("loopinv(xr,vr,ixr(),xo,vo)", 'R=="[{obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};}*](xr=ixr()->xo!=ixo())"); <(
      "Init":
        QE,
      "Post":
        QE,
      "Step":
        composeb('R=="[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};]loopinv(xr,vr,0,xo,vo)");
        composeb('R=="[obstacle{|^@|};]#[{robot{|^@|};t:=0;}dyn{|^@|};]loopinv(xr,vr,0,xo,vo)#");
        expand "dyn";
        solve('R=="[obstacle{|^@|};][robot{|^@|};t:=0;]#[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}]loopinv(xr,vr,0,xo,vo)#");
        allL("t_", 'R=="[obstacle{|^@|};][robot{|^@|};t:=0;]\forall t_ (t_>=0->#\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&ao*s_+vo>=Vmin())#->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))");
        simplify('R=="[obstacle{|^@|};][robot{|^@|};t:=0;]\forall t_ #(t_>=0->(0<=t_&t_<=t_->t_+t<=ep()&ar*t_+vr>=0&ao*t_+vo>=Vmin())->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))#");
        expand "obstacle";
        expand "robot";
        unfold; <(
          "[?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();][t:=0;]\forall t_ (t_>=0->t_+t<=ep()&ar*t_+vr>=0&ao*t_+vo>=Vmin()->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))":
            QE,
          "[?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();][t:=0;]\forall t_ (t_>=0->t_+t<=ep()&ar*t_+vr>=0&ao*t_+vo>=Vmin()->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))":
            expand "loopinv";
            andR('R=="0<=ar*t_+vr&Vmin()<=ao*t_+vo&(RAfterX(ar*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|ar*(t_^2/2)+vr*t_+xr+stopDist(ar*t_+vr) < 0|ar*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)))"); <(
              "0<=ar*t_+vr":
                QE using "ar*t_+vr>=0 :: 0<=ar*t_+vr :: nil",
              "Vmin()<=ao*t_+vo&(RAfterX(ar*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|ar*(t_^2/2)+vr*t_+xr+stopDist(ar*t_+vr) < 0|ar*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)))":
                andR('R=="Vmin()<=ao*t_+vo&(RAfterX(ar*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|ar*(t_^2/2)+vr*t_+xr+stopDist(ar*t_+vr) < 0|ar*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)))"); <(
                  "Vmin()<=ao*t_+vo":
                    QE using "ao*t_+vo>=Vmin() :: Vmin()<=ao*t_+vo :: nil",
                  "RAfterX(ar*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|ar*(t_^2/2)+vr*t_+xr+stopDist(ar*t_+vr) < 0|ar*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))":
                    orR('R)*;
                    andR('R=="ar*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))"); <(
                      "ar*t_+vr>0":
                        QE using "t_>=0 :: vr>0 :: 0<=ar :: ar*t_+vr>0 :: nil",
                      "ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)":
                        orR('R=="ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)");
                        orL('L=="xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())"); <(
                          "xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()":
                            QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: t_>=0 :: -b()<=ao :: ao<=A() :: vr>0 :: xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo() :: 0<=ar :: ar<=A() :: t_+0<=ep() :: ar*t_+vr>=0 :: ao*t_+vo>=Vmin() :: RAfterX(ar*(t_^2/2)+vr*t_+xr) :: ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo() :: nil",
                          "ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())":
                            andL('L)*;
                            orL('L=="RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                              "RAfterX(xr)":
                                id using "RAfterX(xr) :: RAfterX(xr) :: nil",
                              "OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                                orL('L=="OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                                  "OAfterX(xo)":
                                    id using "OAfterX(xo) :: OAfterX(xo) :: nil",
                                  "xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                                    orL('L=="xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                                      "xr+stopDist(vr) < 0":
                                        QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: t_>=0 :: -b()<=ao :: ao<=A() :: vr>0 :: ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()) :: 0<=ar :: ar<=A() :: t_+0<=ep() :: ar*t_+vr>=0 :: ao*t_+vo>=Vmin() :: 0<=vr :: Vmin()<=vo :: xr+stopDist(vr) < 0 :: OAfterX(ao*(t_^2/2)+vo*t_+xo) :: ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr) :: nil",
                                      "vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                                        andL('L=="vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)");
                                        QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: t_>=0 :: -b()<=ao :: ao<=A() :: vr>0 :: ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()) :: 0<=ar :: ar<=A() :: t_+0<=ep() :: ar*t_+vr>=0 :: ao*t_+vo>=Vmin() :: 0<=vr :: Vmin()<=vo :: vr>0 :: OAfterX(ao*(t_^2/2)+vo*t_+xo) :: ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr) :: nil"
                                    )
                                )
                            )
                        )
                    )
                )
            ),
          "[?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;][t:=0;]\forall t_ (t_>=0->t_+t<=ep()&ar*t_+vr>=0&ao*t_+vo>=Vmin()->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))":
            expand "loopinv";
            andL('L)*;
            fullSimplify;
            orR('R)*;
            orL('L=="RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(-xr)/vr"); <(
              "RAfterX(xr)":
                id using "RAfterX(xr) :: RAfterX(xr) :: nil",
              "OAfterX(xo)|xr+stopDist(vr) < 0|xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(-xr)/vr":
                orL('L=="OAfterX(xo)|xr+stopDist(vr) < 0|xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(-xr)/vr"); <(
                  "OAfterX(xo)":
                    id using "OAfterX(xo) :: OAfterX(xo) :: nil",
                  "xr+stopDist(vr) < 0|xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(-xr)/vr":
                    orL('L=="xr+stopDist(vr) < 0|xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(-xr)/vr"); <(
                      "xr+stopDist(vr) < 0":
                        QE using "A()>0 :: b()>0 :: Vmin()>0 :: !(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())) :: t_>=0 :: -b()<=ao :: ao<=A() :: vr>0 :: ixo() < xo+Vmin()*(ixr()-xr)/vr :: ao*t_+vo>=Vmin() :: Vmin()<=vo :: ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(-(vr*t_+xr))/vr :: nil",
                      "xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(-xr)/vr":
                        orL('L=="xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(-xr)/vr"); <(
                          "xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()":
                            QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: !(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())) :: t_>=0 :: -b()<=ao :: ao<=A() :: vr>0 :: ixo() < xo+Vmin()*(ixr()-xr)/vr :: t_<=ep() :: ao*t_+vo>=Vmin() :: Vmin()<=vo :: xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo() :: ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(-(vr*t_+xr))/vr+A()/2*((-(vr*t_+xr))/vr)^2 < ixo() :: nil",
                          "ixo() < xo+Vmin()*(-xr)/vr":
                            QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: !(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())) :: t_>=0 :: -b()<=ao :: ao<=A() :: vr>0 :: ixo() < xo+Vmin()*(ixr()-xr)/vr :: t_<=ep() :: ao*t_+vo>=Vmin() :: Vmin()<=vo :: ixo() < xo+Vmin()*(-xr)/vr :: ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(-(vr*t_+xr))/vr :: nil"
                        )
                    )
                )
            ),
          "[ar:=-b();][t:=0;]\forall t_ (t_>=0->t_+t<=ep()&ar*t_+vr>=0&ao*t_+vo>=Vmin()->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))":
            expand "loopinv";
            andL('L)*;
            andR('R=="0<=(-b())*t_+vr&Vmin()<=ao*t_+vo&(RAfterX((-b())*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|(-b())*(t_^2/2)+vr*t_+xr+stopDist((-b())*t_+vr) < 0|(-b())*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)+A()/2*((0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)))"); <(
              "0<=(-b())*t_+vr":
                QE using "(-b())*t_+vr>=0 :: 0<=(-b())*t_+vr :: nil",
              "Vmin()<=ao*t_+vo&(RAfterX((-b())*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|(-b())*(t_^2/2)+vr*t_+xr+stopDist((-b())*t_+vr) < 0|(-b())*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)+A()/2*((0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)))":
                andR('R=="Vmin()<=ao*t_+vo&(RAfterX((-b())*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|(-b())*(t_^2/2)+vr*t_+xr+stopDist((-b())*t_+vr) < 0|(-b())*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)+A()/2*((0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)))"); <(
                  "Vmin()<=ao*t_+vo":
                    QE using "ao*t_+vo>=Vmin() :: Vmin()<=ao*t_+vo :: nil",
                  "RAfterX((-b())*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|(-b())*(t_^2/2)+vr*t_+xr+stopDist((-b())*t_+vr) < 0|(-b())*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)+A()/2*((0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))":
                    orR('R)*;
                    andR('R=="(-b())*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)+A()/2*((0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))"); <(
                      "(-b())*t_+vr>0":
                        orL('L=="RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                          "RAfterX(xr)":
                            id using "RAfterX(xr) :: RAfterX(xr) :: nil",
                          "OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                            orL('L=="OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                              "OAfterX(xo)":
                                id using "OAfterX(xo) :: OAfterX(xo) :: nil",
                              "xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                                orL('L=="xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                                  "xr+stopDist(vr) < 0":
                                    QE using "b()>0 :: t_>=0 :: 0<=vr :: xr+stopDist(vr) < 0 :: (-b())*(t_^2/2)+vr*t_+xr+stopDist((-b())*t_+vr) < 0 :: nil",
                                  "vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                                    andL('L=="vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)");
                                    QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: !(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()))) :: !(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr) :: t_>=0 :: -b()<=ao :: ao<=A() :: t_+0<=ep() :: (-b())*t_+vr>=0 :: ao*t_+vo>=Vmin() :: 0<=vr :: Vmin()<=vo :: vr>0 :: xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr :: nil"
                                )
                            )
                        ),
                      "ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)+A()/2*((0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)":
                        orR('R=="ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)+A()/2*((0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)");
                        orL('L=="RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                          "RAfterX(xr)":
                            id using "RAfterX(xr) :: RAfterX(xr) :: nil",
                          "OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                            orL('L=="OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                              "OAfterX(xo)":
                                id using "OAfterX(xo) :: OAfterX(xo) :: nil",
                              "xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                                orL('L=="xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                                  "xr+stopDist(vr) < 0":
                                    QE using "b()>0 :: ep()>0 :: Vmin()>0 :: t_>=0 :: -b()<=ao :: ao<=A() :: t_+0<=ep() :: (-b())*t_+vr>=0 :: ao*t_+vo>=Vmin() :: 0<=vr :: Vmin()<=vo :: xr+stopDist(vr) < 0 :: (-b())*(t_^2/2)+vr*t_+xr+stopDist((-b())*t_+vr) < 0 :: nil",
                                  "vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                                    andL('L=="vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)");
                                    orL('L=="xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr"); <(
                                      "xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()":
                                        simplify('L=="!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())))") using "vr>0";
                                        notL('L=="!(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()))");
                                        orR('R=="xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())");
                                        QE using "xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo() :: xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo() :: nil",
                                      "ixo() < xo+Vmin()*(0-xr)/vr":
                                        simplify('L=="!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr)") using "vr>0";
                                        QE using "Vmin()>0 :: ixo()>=xo+Vmin()*(ixr()-xr)/vr :: vr>0 :: ixo() < xo+Vmin()*(0-xr)/vr :: nil"
                                    )
                                )
                            )
                        )
                    )
                )
            ),
          "[?vr=0;ar:=0;][t:=0;]\forall t_ (t_>=0->t_+t<=ep()&ar*t_+vr>=0&ao*t_+vo>=Vmin()->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))":
            expand "loopinv";
            andL('L)*;
            allL2R('L=="vr=0");
            simplify('R=="0<=0*t_+0&Vmin()<=ao*t_+vo&(RAfterX(0*(t_^2/2)+0*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|0*(t_^2/2)+0*t_+xr+stopDist(0*t_+0) < 0|0*t_+0>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(0*(t_^2/2)+0*t_+xr))/(0*t_+0)+A()/2*((0-(0*(t_^2/2)+0*t_+xr))/(0*t_+0))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(0*(t_^2/2)+0*t_+xr))/(0*t_+0)))");
            orR('R)*;
            QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vr=0 :: t_>=0 :: -b()<=ao :: ao<=A() :: t_+0<=ep() :: 0*t_+0>=0 :: ao*t_+vo>=Vmin() :: 0<=0 :: Vmin()<=vo :: RAfterX(xr)|OAfterX(xo)|xr+stopDist(0) < 0|0>0&(xo+vo*(0-xr)/0+A()/2*((0-xr)/0)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/0) :: RAfterX(xr) :: OAfterX(xo) :: RAfterX(xr) :: OAfterX(ao*(t_^2/2)+vo*t_+xo) :: xr+stopDist(0) < 0 :: nil",
          "[?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();][t:=0;]\forall t_ (t_>=0->t_+t<=ep()&ar*t_+vr>=0&ao*t_+vo>=Vmin()->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))":
            expand "loopinv";
            andL('L)*;
            andR('R=="0<=A()*t_+vr&Vmin()<=ao*t_+vo&(RAfterX(A()*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|A()*(t_^2/2)+vr*t_+xr+stopDist(A()*t_+vr) < 0|A()*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr)+A()/2*((0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr)))"); <(
              "0<=A()*t_+vr":
                QE using "A()*t_+vr>=0 :: 0<=A()*t_+vr :: nil",
              "Vmin()<=ao*t_+vo&(RAfterX(A()*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|A()*(t_^2/2)+vr*t_+xr+stopDist(A()*t_+vr) < 0|A()*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr)+A()/2*((0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr)))":
                andR('R=="Vmin()<=ao*t_+vo&(RAfterX(A()*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|A()*(t_^2/2)+vr*t_+xr+stopDist(A()*t_+vr) < 0|A()*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr)+A()/2*((0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr)))"); <(
                  "Vmin()<=ao*t_+vo":
                    QE using "ao*t_+vo>=Vmin() :: Vmin()<=ao*t_+vo :: nil",
                  "RAfterX(A()*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|A()*(t_^2/2)+vr*t_+xr+stopDist(A()*t_+vr) < 0|A()*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr)+A()/2*((0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr))":
                    orR('R)*;
                    QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: xr+stopDist(vr)+accComp(vr) < ixr() :: t_>=0 :: -b()<=ao :: ao<=A() :: t_+0<=ep() :: A()*t_+vr>=0 :: ao*t_+vo>=Vmin() :: 0<=vr :: Vmin()<=vo :: RAfterX(A()*(t_^2/2)+vr*t_+xr) :: A()*(t_^2/2)+vr*t_+xr+stopDist(A()*t_+vr) < 0 :: nil"
                )
            )
        )
    ),
  "<dwcx{|^@|};>RAfterX(xr)":
    expand "dwcx";
    expand "obstacle";
    expand "robot";
    expand "dyn";
    con("v", "A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo<=0->vr=0)&\exists n (n>=2&xo+(v-n)*ep()*Vmin()>0&vr+(min(v,n-1)-(n-2))*ep()*A()>=A()*ep()&(xr>0|xr+min(v,n-2)*ep()*(A()*ep())>0))", 'R=="<{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)"); <(
      "Init":
        QE,
      "Post":
        QE,
      "Step":
        composed('R=="<{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo<=0->vr=0)&\exists n (n>=2&xo+(v-1-n)*ep()*Vmin()>0&vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(xr>0|xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
        composed('R=="<ao:=*;?-b()<=ao&ao<=A();>#<{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo<=0->vr=0)&\exists n (n>=2&xo+(v-1-n)*ep()*Vmin()>0&vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(xr>0|xr+min(v-1,n-2)*ep()*(A()*ep())>0)))#");
        solve('R=="<ao:=*;?-b()<=ao&ao<=A();><{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;>#<{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo<=0->vr=0)&\exists n (n>=2&xo+(v-1-n)*ep()*Vmin()>0&vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(xr>0|xr+min(v-1,n-2)*ep()*(A()*ep())>0)))#");
        composed('R=="<ao:=*;?-b()<=ao&ao<=A();><{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&ao*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&ao*t_+vo>=Vmin()&ar*t_+vr>=0&(ao*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&ao*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
        randomd('R=="<ao:=*;><?-b()<=ao&ao<=A();><{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&ao*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&ao*t_+vo>=Vmin()&ar*t_+vr>=0&(ao*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&ao*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
        existsR("0", 'R=="\exists ao <?-b()<=ao&ao<=A();><{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&ao*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&ao*t_+vo>=Vmin()&ar*t_+vr>=0&(ao*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&ao*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
        testd('R=="<?-b()<=0&0<=A();><{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
        andR('R=="(-b()<=0&0<=A())&<{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
          "-b()<=0&0<=A()":
            QE,
          "<{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
            (andL('L) | existsL('L))*;
            composed('R=="<{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
            choiced('R=="<?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
            orR('R=="<?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))|<?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
            composed('R=="<?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
            testd('R=="<?RAfterX(xr)|OAfterX(xo);><ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
            orL('L=="xr>0|xr+min(v,n-2)*ep()*(A()*ep())>0"); <(
              "xr>0":
                andR('R=="(RAfterX(xr)|OAfterX(xo))&<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
                  "RAfterX(xr)|OAfterX(xo)":
                    expand "RAfterX";
                    expand "ixr";
                    simplify('R=="xr>0|OAfterX(xo)") using "xr>0";
                    closeT,
                  "<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
                    composed('R=="<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                    randomd('R=="<ar:=*;><?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                    implyL('L=="xo<=0->vr=0"); <(
                      "xo<=0":
                        cut("xo+vo*ep()>0|xo+vo*ep()<=0"); <(
                          "Use":
                            orL('L=="xo+vo*ep()>0|xo+vo*ep()<=0"); <(
                              "xo+vo*ep()>0":
                                existsR("A()", 'R=="\exists ar <?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                testd('R=="<?-b()<=A()&A()<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                andR('R=="(-b()<=A()&A()<=A())&<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
                                  "-b()<=A()&A()<=A()":
                                    QE using "A()>0 :: b()>0 :: -b()<=A()&A()<=A() :: nil",
                                  "<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
                                    assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                    existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                    simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*ep()+vo>=Vmin()&A()*ep()+vr>=0&(0*(ep()^2/2)+vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&0*(ep()^2/2)+vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: nil";
                                    andR('R=="\forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0)&A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                      "\forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0)":
                                        QE using "A()>0 :: ep()>0 :: vr>=0 :: \forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0) :: nil",
                                      "A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                        andR('R=="A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                          "A()*ep()+vr>=0":
                                            QE using "A()>0 :: ep()>0 :: vr>=0 :: A()*ep()+vr>=0 :: nil",
                                          "(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                            andR('R=="(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                              "vo*ep()+xo<=0->A()*ep()+vr=0":
                                                implyR('R=="vo*ep()+xo<=0->A()*ep()+vr=0");
                                                QE using "xo+vo*ep()>0 :: vo*ep()+xo<=0 :: nil",
                                              "\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                                existsR("n", 'R=="\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))");
                                                simplify('R=="n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0)") using "n>=2";
                                                QE using "v>0 :: A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: n>=2 :: xo+(v-n)*ep()*Vmin()>0 :: vr+(min(v,n-1)-(n-2))*ep()*A()>=A()*ep() :: xr>0 :: xo+vo*ep()>0 :: vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0) :: xo<=0 :: nil"
                                            )
                                        )
                                    )
                                ),
                              "xo+vo*ep()<=0":
                                QE using "ep()>0 :: Vmin()>0 :: vo>=Vmin() :: xo+vo*ep()<=0 :: xo<=0 :: nil"
                            ),
                          "Show":
                            QE using "xo+vo*ep()>0|xo+vo*ep()<=0"
                        ),
                      "vr=0":
                        cut("xo+vo*ep()>0|xo+vo*ep()<=0"); <(
                          "Use":
                            orL('L=="xo+vo*ep()>0|xo+vo*ep()<=0"); <(
                              "xo+vo*ep()>0":
                                existsR("A()", 'R=="\exists ar <?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                testd('R=="<?-b()<=A()&A()<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                andR('R=="(-b()<=A()&A()<=A())&<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
                                  "-b()<=A()&A()<=A()":
                                    QE using "A()>0 :: b()>0 :: -b()<=A()&A()<=A() :: nil",
                                  "<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
                                    assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                    existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                    simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*ep()+vo>=Vmin()&A()*ep()+vr>=0&(0*(ep()^2/2)+vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&0*(ep()^2/2)+vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: nil";
                                    andR('R=="\forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0)&A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                      "\forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0)":
                                        QE using "A()>0 :: ep()>0 :: vr>=0 :: \forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0) :: nil",
                                      "A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                        andR('R=="A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                          "A()*ep()+vr>=0":
                                            QE using "A()>0 :: ep()>0 :: vr>=0 :: A()*ep()+vr>=0 :: nil",
                                          "(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                            andR('R=="(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                              "vo*ep()+xo<=0->A()*ep()+vr=0":
                                                implyR('R=="vo*ep()+xo<=0->A()*ep()+vr=0");
                                                QE using "xo+vo*ep()>0 :: vo*ep()+xo<=0 :: nil",
                                              "\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                                existsR("n", 'R=="\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))");
                                                simplify('R=="n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0)") using "n>=2";
                                                QE using "v>0 :: A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: vr=0 :: n>=2 :: xo+(v-n)*ep()*Vmin()>0 :: vr+(min(v,n-1)-(n-2))*ep()*A()>=A()*ep() :: xr>0 :: xo+vo*ep()>0 :: vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0) :: nil"
                                            )
                                        )
                                    )
                                ),
                              "xo+vo*ep()<=0":
                                existsR("0", 'R=="\exists ar <?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                testd('R=="<?-b()<=0&0<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->0*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&0*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(t_^2/2)+vr*t_+xr>0|0*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                andR('R=="(-b()<=0&0<=A())&<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->0*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&0*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(t_^2/2)+vr*t_+xr>0|0*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
                                  "-b()<=0&0<=A()":
                                    QE using "A()>0 :: b()>0 :: -b()<=0&0<=A() :: nil",
                                  "<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->0*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&0*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(t_^2/2)+vr*t_+xr>0|0*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
                                    assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->0*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&0*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(t_^2/2)+vr*t_+xr>0|0*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                    existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->0*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&0*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(t_^2/2)+vr*t_+xr>0|0*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                    simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*ep()+vo>=Vmin()&0*ep()+vr>=0&(0*(ep()^2/2)+vo*ep()+xo<=0->0*ep()+vr=0)&\exists n (n>=2&0*(ep()^2/2)+vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&0*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(ep()^2/2)+vr*ep()+xr>0|0*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: vr=0 :: nil";
                                    existsR("n", 'R=="\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(vr*ep()+xr>0|vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))");
                                    simplify('R=="n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(vr*ep()+xr>0|vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0)") using "n>=2";
                                    QE using "v>0 :: A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: vr=0 :: n>=2 :: xo+(v-n)*ep()*Vmin()>0 :: vr+(min(v,n-1)-(n-2))*ep()*A()>=A()*ep() :: xr>0 :: xo+vo*ep()<=0 :: vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(vr*ep()+xr>0|vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0) :: nil"
                                )
                            ),
                          "Show":
                            QE using "xo+vo*ep()>0|xo+vo*ep()<=0"
                        )
                    )
                ),
              "xr+min(v,n-2)*ep()*(A()*ep())>0":
                composed('R=="<?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                testd('R=="<?!(RAfterX(xr)|OAfterX(xo));><?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                andR('R=="(RAfterX(xr)|OAfterX(xo))&<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
                  "RAfterX(xr)|OAfterX(xo)":
                    useAt("!! double negation", "1", 'R=="RAfterX(xr)|OAfterX(xo)");
                    notR('R=="!!(RAfterX(xr)|OAfterX(xo))");
                    simplify('R=="!(RAfterX(xr)|OAfterX(xo))&<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))") using "!(RAfterX(xr)|OAfterX(xo))";
                    choiced('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                    orR('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))|<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                    hideR('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                    composed('R=="<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                    testd('R=="<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));><?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                    andR('R=="!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())))&<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
                      "!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())))":
                        QE,
                      "<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
                        choiced('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                        orR('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))|<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                        hideR('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                        composed('R=="<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                        testd('R=="<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);><ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                        andR('R=="!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr)&<ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
                          "!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr)":
                            QE,
                          "<ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
                            choiced('R=="<ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                            orR('R=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))|<?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                            hideR('R=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                            choiced('R=="<?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                            orR('R=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))|<?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                            implyL('L=="xo<=0->vr=0"); <(
                              "xo<=0":
                                hideR('R=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                composed('R=="<?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                testd('R=="<?xr+stopDist(vr)+accComp(vr) < ixr();><ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                andR('R=="xr+stopDist(vr)+accComp(vr) < ixr()&<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
                                  "xr+stopDist(vr)+accComp(vr) < ixr()":
                                    QE,
                                  "<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
                                    assignd('R=="<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                    assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&A()*t_+vr>=0&(vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                    existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&A()*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&A()*t_+vr>=0&(vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                    simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&A()*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: nil";
                                    andR('R=="\forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0)&A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                      "\forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0)":
                                        QE using "A()>0 :: ep()>0 :: vr>=0 :: \forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0) :: nil",
                                      "A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                        andR('R=="A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                          "A()*ep()+vr>=0":
                                            QE using "A()>0 :: ep()>0 :: vr>=0 :: A()*ep()+vr>=0 :: nil",
                                          "(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                            andR('R=="(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                              "vo*ep()+xo<=0->A()*ep()+vr=0":
                                                implyR('R=="vo*ep()+xo<=0->A()*ep()+vr=0");
                                                QE using "ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vo*ep()+xo<=0 :: xo<=0 :: nil",
                                              "\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                                existsR("n", 'R=="\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))");
                                                simplify('R=="n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0)") using "n>=2";
                                                QE
                                            )
                                        )
                                    )
                                ),
                              "vr=0":
                                hideR('R=="<?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                composed('R=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                testd('R=="<?vr=0;><ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                simplify('R=="vr=0&<ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))") using "vr=0";
                                assignd('R=="<ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo<=0->0*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&0*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(t_^2/2)+vr*t_+xr>0|0*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo<=0->0*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&0*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(t_^2/2)+vr*t_+xr>0|0*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*ep()+vr>=0&(vo*ep()+xo<=0->0*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&0*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(ep()^2/2)+vr*ep()+xr>0|0*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: vr=0 :: nil";
                                existsR("n", 'R=="\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(vr*ep()+xr>0|vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))");
                                simplify('R=="n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(vr*ep()+xr>0|vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0)") using "n>=2";
                                QE
                            )
                        )
                    ),
                  "<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
                    implyL('L=="xo<=0->vr=0"); <(
                      "xo<=0":
                        composed('R=="<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                        randomd('R=="<ar:=*;><?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                        existsR("A()", 'R=="\exists ar <?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                        testd('R=="<?-b()<=A()&A()<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                        andR('R=="(-b()<=A()&A()<=A())&<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
                          "-b()<=A()&A()<=A()":
                            QE using "A()>0 :: b()>0 :: -b()<=A()&A()<=A() :: nil",
                          "<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
                            assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                            existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                            simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*ep()+vo>=Vmin()&A()*ep()+vr>=0&(0*(ep()^2/2)+vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&0*(ep()^2/2)+vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: nil";
                            andR('R=="\forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0)&A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                              "\forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0)":
                                QE using "A()>0 :: ep()>0 :: vr>=0 :: \forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0) :: nil",
                              "A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                andR('R=="A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                  "A()*ep()+vr>=0":
                                    QE using "A()>0 :: ep()>0 :: vr>=0 :: A()*ep()+vr>=0 :: nil",
                                  "(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                    andR('R=="(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                      "vo*ep()+xo<=0->A()*ep()+vr=0":
                                        implyR('R=="vo*ep()+xo<=0->A()*ep()+vr=0");
                                        QE using "ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vo*ep()+xo<=0 :: xo<=0 :: nil",
                                      "\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                        existsR("n", 'R=="\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))");
                                        simplify('R=="n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0)") using "n>=2";
                                        QE using "v>0 :: A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: n>=2 :: xo+(v-n)*ep()*Vmin()>0 :: vr+(min(v,n-1)-(n-2))*ep()*A()>=A()*ep() :: xr+min(v,n-2)*ep()*(A()*ep())>0 :: vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0) :: xo<=0 :: nil"
                                    )
                                )
                            )
                        ),
                      "vr=0":
                        composed('R=="<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                        randomd('R=="<ar:=*;><?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                        andR('R=="!(RAfterX(xr)|OAfterX(xo))&<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
                          "!(RAfterX(xr)|OAfterX(xo))":
                            cut("xo+vo*ep()>0|xo+vo*ep()<=0"); <(
                              "Use":
                                orL('L=="xo+vo*ep()>0|xo+vo*ep()<=0"); <(
                                  "xo+vo*ep()>0":
                                    existsR("A()", 'R=="\exists ar <?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                    testd('R=="<?-b()<=A()&A()<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                    andR('R=="(-b()<=A()&A()<=A())&<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
                                      "-b()<=A()&A()<=A()":
                                        QE using "A()>0 :: b()>0 :: -b()<=A()&A()<=A() :: nil",
                                      "<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
                                        assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                        existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                        simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*ep()+vo>=Vmin()&A()*ep()+vr>=0&(0*(ep()^2/2)+vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&0*(ep()^2/2)+vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: vr=0 :: nil";
                                        andR('R=="\forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0)&A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                          "\forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0)":
                                            QE using "A()>0 :: ep()>0 :: vr>=0 :: \forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0) :: nil",
                                          "A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                            andR('R=="A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                              "A()*ep()+vr>=0":
                                                QE using "A()>0 :: ep()>0 :: vr>=0 :: A()*ep()+vr>=0 :: nil",
                                              "(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                                andR('R=="(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                                  "vo*ep()+xo<=0->A()*ep()+vr=0":
                                                    implyR('R=="vo*ep()+xo<=0->A()*ep()+vr=0");
                                                    QE using "xo+vo*ep()>0 :: vo*ep()+xo<=0 :: nil",
                                                  "\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                                    existsR("n", 'R=="\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))");
                                                    simplify('R=="n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0)") using "n>=2";
                                                    QE using "v>0 :: A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: vr=0 :: n>=2 :: xo+(v-n)*ep()*Vmin()>0 :: vr+(min(v,n-1)-(n-2))*ep()*A()>=A()*ep() :: xr+min(v,n-2)*ep()*(A()*ep())>0 :: xo+vo*ep()>0 :: vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0) :: nil"
                                                )
                                            )
                                        )
                                    ),
                                  "xo+vo*ep()<=0":
                                    existsR("0", 'R=="\exists ar <?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                    testd('R=="<?-b()<=0&0<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->0*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&0*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(t_^2/2)+vr*t_+xr>0|0*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                    andR('R=="(-b()<=0&0<=A())&<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->0*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&0*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(t_^2/2)+vr*t_+xr>0|0*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
                                      "-b()<=0&0<=A()":
                                        QE using "A()>0 :: b()>0 :: -b()<=0&0<=A() :: nil",
                                      "<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->0*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&0*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(t_^2/2)+vr*t_+xr>0|0*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
                                        assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->0*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&0*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(t_^2/2)+vr*t_+xr>0|0*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                        existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->0*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&0*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(t_^2/2)+vr*t_+xr>0|0*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                        simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*ep()+vo>=Vmin()&0*ep()+vr>=0&(0*(ep()^2/2)+vo*ep()+xo<=0->0*ep()+vr=0)&\exists n (n>=2&0*(ep()^2/2)+vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&0*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(ep()^2/2)+vr*ep()+xr>0|0*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: vr=0 :: nil";
                                        existsR("n", 'R=="\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(vr*ep()+xr>0|vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))");
                                        simplify('R=="n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(vr*ep()+xr>0|vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0)") using "n>=2";
                                        QE using "v>0 :: A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: vr=0 :: n>=2 :: xo+(v-n)*ep()*Vmin()>0 :: vr+(min(v,n-1)-(n-2))*ep()*A()>=A()*ep() :: xr+min(v,n-2)*ep()*(A()*ep())>0 :: xo+vo*ep()<=0 :: vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(vr*ep()+xr>0|vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0) :: nil"
                                    )
                                ),
                              "Show":
                                QE using "xo+vo*ep()>0|xo+vo*ep()<=0"
                            ),
                          "<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
                            existsR("A()", 'R=="\exists ar <?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                            testd('R=="<?-b()<=A()&A()<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                            andR('R=="(-b()<=A()&A()<=A())&<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
                              "-b()<=A()&A()<=A()":
                                QE using "A()>0 :: b()>0 :: -b()<=A()&A()<=A() :: nil",
                              "<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
                                assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->A()*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&A()*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(t_^2/2)+vr*t_+xr>0|A()*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*ep()+vo>=Vmin()&A()*ep()+vr>=0&(0*(ep()^2/2)+vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&0*(ep()^2/2)+vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: vr=0 :: nil";
                                andR('R=="\forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0)&A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                  "\forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0)":
                                    QE using "A()>0 :: ep()>0 :: vr>=0 :: \forall s_ (0<=s_&s_<=ep()->A()*s_+vr>=0) :: nil",
                                  "A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                    andR('R=="A()*ep()+vr>=0&(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                      "A()*ep()+vr>=0":
                                        QE using "A()>0 :: ep()>0 :: vr>=0 :: A()*ep()+vr>=0 :: nil",
                                      "(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                        andR('R=="(vo*ep()+xo<=0->A()*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))"); <(
                                          "vo*ep()+xo<=0->A()*ep()+vr=0":
                                            implyR('R=="vo*ep()+xo<=0->A()*ep()+vr=0");
                                            choiced('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                            orR('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))|<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                            hideR('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                            composed('R=="<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                            testd('R=="<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));><?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                            andR('R=="!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())))&<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
                                              "!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())))":
                                                QE,
                                              "<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
                                                choiced('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                orR('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))|<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                hideR('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                composed('R=="<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                testd('R=="<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);><ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                andR('R=="!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr)&<ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))"); <(
                                                  "!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr)":
                                                    QE,
                                                  "<ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))":
                                                    choiced('R=="<ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                    orR('R=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))|<?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                    hideR('R=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                    choiced('R=="<?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                    orR('R=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))|<?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                    hideR('R=="<?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                    composed('R=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                    testd('R=="<?vr=0;><ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                    simplify('R=="vr=0&<ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))") using "vr=0";
                                                    assignd('R=="<ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(ar*(t_^2/2)+vr*t_+xr>0|ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                    assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo<=0->0*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&0*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(t_^2/2)+vr*t_+xr>0|0*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                    existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo<=0->0*t_+vr=0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&0*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(t_^2/2)+vr*t_+xr>0|0*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0)))");
                                                    simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*ep()+vr>=0&(vo*ep()+xo<=0->0*ep()+vr=0)&\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&0*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(0*(ep()^2/2)+vr*ep()+xr>0|0*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: vr=0 :: nil";
                                                    existsR("n", 'R=="\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(vr*ep()+xr>0|vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))");
                                                    simplify('R=="n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(vr*ep()+xr>0|vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0)") using "n>=2";
                                                    QE
                                                )
                                            ),
                                          "\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))":
                                            existsR("n", 'R=="\exists n (n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0))");
                                            simplify('R=="n>=2&vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0)") using "n>=2";
                                            QE using "v>0 :: A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: vr>=0 :: vr=0 :: n>=2 :: xo+(v-n)*ep()*Vmin()>0 :: vr+(min(v,n-1)-(n-2))*ep()*A()>=A()*ep() :: xr+min(v,n-2)*ep()*(A()*ep())>0 :: vo*ep()+xo+(v-1-n)*ep()*Vmin()>0&A()*ep()+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&(A()*(ep()^2/2)+vr*ep()+xr>0|A()*(ep()^2/2)+vr*ep()+xr+min(v-1,n-2)*ep()*(A()*ep())>0) :: nil"
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)
End.

Tactic "Proof Theorem 12: Cross intersection (loop split and unroll)".
useSolver("Mathematica");
implyR('R=="assumptions(xr,vr,ixr(),vo)->[dwcx{|^@|};](xr=ixr()->xo!=ixo())&<dwcx{|^@|};>RAfterX(xr)");
andR('R=="[dwcx{|^@|};](xr=ixr()->xo!=ixo())&<dwcx{|^@|};>RAfterX(xr)"); <(
  "[dwcx{|^@|};](xr=ixr()->xo!=ixo())":
    expand "dwcx";
    loop("loopinv(xr,vr,ixr(),xo,vo)", 'R=="[{obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};}*](xr=ixr()->xo!=ixo())"); <(
      "Init":
        QE,
      "Post":
        QE,
      "Step":
        composeb('R=="[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};]loopinv(xr,vr,0,xo,vo)");
        composeb('R=="[obstacle{|^@|};]#[{robot{|^@|};t:=0;}dyn{|^@|};]loopinv(xr,vr,0,xo,vo)#");
        expand "dyn";
        solve('R=="[obstacle{|^@|};][robot{|^@|};t:=0;]#[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}]loopinv(xr,vr,0,xo,vo)#");
        allL("t_", 'R=="[obstacle{|^@|};][robot{|^@|};t:=0;]\forall t_ (t_>=0->#\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&ao*s_+vo>=Vmin())#->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))");
        simplify('R=="[obstacle{|^@|};][robot{|^@|};t:=0;]\forall t_ #(t_>=0->(0<=t_&t_<=t_->t_+t<=ep()&ar*t_+vr>=0&ao*t_+vo>=Vmin())->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))#");
        expand "obstacle";
        expand "robot";
        unfold; <(
          "[?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();][t:=0;]\forall t_ (t_>=0->t_+t<=ep()&ar*t_+vr>=0&ao*t_+vo>=Vmin()->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))":
            QE,
          "[?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();][t:=0;]\forall t_ (t_>=0->t_+t<=ep()&ar*t_+vr>=0&ao*t_+vo>=Vmin()->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))":
            expand "loopinv";
            andR('R=="0<=ar*t_+vr&Vmin()<=ao*t_+vo&(RAfterX(ar*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|ar*(t_^2/2)+vr*t_+xr+stopDist(ar*t_+vr) < 0|ar*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)))"); <(
              "0<=ar*t_+vr":
                QE using "ar*t_+vr>=0 :: 0<=ar*t_+vr :: nil",
              "Vmin()<=ao*t_+vo&(RAfterX(ar*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|ar*(t_^2/2)+vr*t_+xr+stopDist(ar*t_+vr) < 0|ar*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)))":
                andR('R=="Vmin()<=ao*t_+vo&(RAfterX(ar*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|ar*(t_^2/2)+vr*t_+xr+stopDist(ar*t_+vr) < 0|ar*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)))"); <(
                  "Vmin()<=ao*t_+vo":
                    QE using "ao*t_+vo>=Vmin() :: Vmin()<=ao*t_+vo :: nil",
                  "RAfterX(ar*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|ar*(t_^2/2)+vr*t_+xr+stopDist(ar*t_+vr) < 0|ar*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))":
                    orR('R)*;
                    andR('R=="ar*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))"); <(
                      "ar*t_+vr>0":
                        QE using "t_>=0 :: vr>0 :: 0<=ar :: ar*t_+vr>0 :: nil",
                      "ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)":
                        orR('R=="ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)");
                        orL('L=="xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())"); <(
                          "xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()":
                            QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: t_>=0 :: -b()<=ao :: ao<=A() :: vr>0 :: xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo() :: 0<=ar :: ar<=A() :: t_+0<=ep() :: ar*t_+vr>=0 :: ao*t_+vo>=Vmin() :: RAfterX(ar*(t_^2/2)+vr*t_+xr) :: ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr)+A()/2*((0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr))^2 < ixo() :: nil",
                          "ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())":
                            andL('L)*;
                            orL('L=="RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                              "RAfterX(xr)":
                                id using "RAfterX(xr) :: RAfterX(xr) :: nil",
                              "OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                                orL('L=="OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                                  "OAfterX(xo)":
                                    id using "OAfterX(xo) :: OAfterX(xo) :: nil",
                                  "xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                                    orL('L=="xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                                      "xr+stopDist(vr) < 0":
                                        QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: t_>=0 :: -b()<=ao :: ao<=A() :: vr>0 :: ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()) :: 0<=ar :: ar<=A() :: t_+0<=ep() :: ar*t_+vr>=0 :: ao*t_+vo>=Vmin() :: 0<=vr :: Vmin()<=vo :: xr+stopDist(vr) < 0 :: OAfterX(ao*(t_^2/2)+vo*t_+xo) :: ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr) :: nil",
                                      "vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                                        andL('L=="vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)");
                                        QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: t_>=0 :: -b()<=ao :: ao<=A() :: vr>0 :: ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()) :: 0<=ar :: ar<=A() :: t_+0<=ep() :: ar*t_+vr>=0 :: ao*t_+vo>=Vmin() :: 0<=vr :: Vmin()<=vo :: vr>0 :: OAfterX(ao*(t_^2/2)+vo*t_+xo) :: ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(ar*(t_^2/2)+vr*t_+xr))/(ar*t_+vr) :: nil"
                                    )
                                )
                            )
                        )
                    )
                )
            ),
          "[?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;][t:=0;]\forall t_ (t_>=0->t_+t<=ep()&ar*t_+vr>=0&ao*t_+vo>=Vmin()->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))":
            expand "loopinv";
            andL('L)*;
            fullSimplify;
            orR('R)*;
            orL('L=="RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(-xr)/vr"); <(
              "RAfterX(xr)":
                id using "RAfterX(xr) :: RAfterX(xr) :: nil",
              "OAfterX(xo)|xr+stopDist(vr) < 0|xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(-xr)/vr":
                orL('L=="OAfterX(xo)|xr+stopDist(vr) < 0|xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(-xr)/vr"); <(
                  "OAfterX(xo)":
                    id using "OAfterX(xo) :: OAfterX(xo) :: nil",
                  "xr+stopDist(vr) < 0|xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(-xr)/vr":
                    orL('L=="xr+stopDist(vr) < 0|xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(-xr)/vr"); <(
                      "xr+stopDist(vr) < 0":
                        QE using "A()>0 :: b()>0 :: Vmin()>0 :: !(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())) :: t_>=0 :: -b()<=ao :: ao<=A() :: vr>0 :: ixo() < xo+Vmin()*(ixr()-xr)/vr :: ao*t_+vo>=Vmin() :: Vmin()<=vo :: ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(-(vr*t_+xr))/vr :: nil",
                      "xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(-xr)/vr":
                        orL('L=="xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(-xr)/vr"); <(
                          "xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo()":
                            QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: !(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())) :: t_>=0 :: -b()<=ao :: ao<=A() :: vr>0 :: ixo() < xo+Vmin()*(ixr()-xr)/vr :: t_<=ep() :: ao*t_+vo>=Vmin() :: Vmin()<=vo :: xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < ixo() :: ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(-(vr*t_+xr))/vr+A()/2*((-(vr*t_+xr))/vr)^2 < ixo() :: nil",
                          "ixo() < xo+Vmin()*(-xr)/vr":
                            QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: !(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())) :: t_>=0 :: -b()<=ao :: ao<=A() :: vr>0 :: ixo() < xo+Vmin()*(ixr()-xr)/vr :: t_<=ep() :: ao*t_+vo>=Vmin() :: Vmin()<=vo :: ixo() < xo+Vmin()*(-xr)/vr :: ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(-(vr*t_+xr))/vr :: nil"
                        )
                    )
                )
            ),
          "[ar:=-b();][t:=0;]\forall t_ (t_>=0->t_+t<=ep()&ar*t_+vr>=0&ao*t_+vo>=Vmin()->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))":
            expand "loopinv";
            andL('L)*;
            andR('R=="0<=(-b())*t_+vr&Vmin()<=ao*t_+vo&(RAfterX((-b())*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|(-b())*(t_^2/2)+vr*t_+xr+stopDist((-b())*t_+vr) < 0|(-b())*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)+A()/2*((0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)))"); <(
              "0<=(-b())*t_+vr":
                QE using "(-b())*t_+vr>=0 :: 0<=(-b())*t_+vr :: nil",
              "Vmin()<=ao*t_+vo&(RAfterX((-b())*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|(-b())*(t_^2/2)+vr*t_+xr+stopDist((-b())*t_+vr) < 0|(-b())*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)+A()/2*((0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)))":
                andR('R=="Vmin()<=ao*t_+vo&(RAfterX((-b())*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|(-b())*(t_^2/2)+vr*t_+xr+stopDist((-b())*t_+vr) < 0|(-b())*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)+A()/2*((0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)))"); <(
                  "Vmin()<=ao*t_+vo":
                    QE using "ao*t_+vo>=Vmin() :: Vmin()<=ao*t_+vo :: nil",
                  "RAfterX((-b())*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|(-b())*(t_^2/2)+vr*t_+xr+stopDist((-b())*t_+vr) < 0|(-b())*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)+A()/2*((0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))":
                    orR('R)*;
                    andR('R=="(-b())*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)+A()/2*((0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))"); <(
                      "(-b())*t_+vr>0":
                        orL('L=="RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                          "RAfterX(xr)":
                            id using "RAfterX(xr) :: RAfterX(xr) :: nil",
                          "OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                            orL('L=="OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                              "OAfterX(xo)":
                                id using "OAfterX(xo) :: OAfterX(xo) :: nil",
                              "xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                                orL('L=="xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                                  "xr+stopDist(vr) < 0":
                                    QE using "b()>0 :: t_>=0 :: 0<=vr :: xr+stopDist(vr) < 0 :: (-b())*(t_^2/2)+vr*t_+xr+stopDist((-b())*t_+vr) < 0 :: nil",
                                  "vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                                    andL('L=="vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)");
                                    QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: !(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()))) :: !(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr) :: t_>=0 :: -b()<=ao :: ao<=A() :: t_+0<=ep() :: (-b())*t_+vr>=0 :: ao*t_+vo>=Vmin() :: 0<=vr :: Vmin()<=vo :: vr>0 :: xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr :: nil"
                                )
                            )
                        ),
                      "ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)+A()/2*((0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)":
                        orR('R=="ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)+A()/2*((0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-((-b())*(t_^2/2)+vr*t_+xr))/((-b())*t_+vr)");
                        orL('L=="RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                          "RAfterX(xr)":
                            id using "RAfterX(xr) :: RAfterX(xr) :: nil",
                          "OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                            orL('L=="OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                              "OAfterX(xo)":
                                id using "OAfterX(xo) :: OAfterX(xo) :: nil",
                              "xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                                orL('L=="xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)"); <(
                                  "xr+stopDist(vr) < 0":
                                    QE using "b()>0 :: ep()>0 :: Vmin()>0 :: t_>=0 :: -b()<=ao :: ao<=A() :: t_+0<=ep() :: (-b())*t_+vr>=0 :: ao*t_+vo>=Vmin() :: 0<=vr :: Vmin()<=vo :: xr+stopDist(vr) < 0 :: (-b())*(t_^2/2)+vr*t_+xr+stopDist((-b())*t_+vr) < 0 :: nil",
                                  "vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)":
                                    andL('L=="vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr)");
                                    orL('L=="xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/vr"); <(
                                      "xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo()":
                                        simplify('L=="!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())))") using "vr>0";
                                        notL('L=="!(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()))");
                                        orR('R=="xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())");
                                        QE using "xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < ixo() :: xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo() :: nil",
                                      "ixo() < xo+Vmin()*(0-xr)/vr":
                                        simplify('L=="!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr)") using "vr>0";
                                        QE using "Vmin()>0 :: ixo()>=xo+Vmin()*(ixr()-xr)/vr :: vr>0 :: ixo() < xo+Vmin()*(0-xr)/vr :: nil"
                                    )
                                )
                            )
                        )
                    )
                )
            ),
          "[?vr=0;ar:=0;][t:=0;]\forall t_ (t_>=0->t_+t<=ep()&ar*t_+vr>=0&ao*t_+vo>=Vmin()->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))":
            expand "loopinv";
            andL('L)*;
            allL2R('L=="vr=0");
            simplify('R=="0<=0*t_+0&Vmin()<=ao*t_+vo&(RAfterX(0*(t_^2/2)+0*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|0*(t_^2/2)+0*t_+xr+stopDist(0*t_+0) < 0|0*t_+0>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(0*(t_^2/2)+0*t_+xr))/(0*t_+0)+A()/2*((0-(0*(t_^2/2)+0*t_+xr))/(0*t_+0))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(0*(t_^2/2)+0*t_+xr))/(0*t_+0)))");
            orR('R)*;
            QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vr=0 :: t_>=0 :: -b()<=ao :: ao<=A() :: t_+0<=ep() :: 0*t_+0>=0 :: ao*t_+vo>=Vmin() :: 0<=0 :: Vmin()<=vo :: RAfterX(xr)|OAfterX(xo)|xr+stopDist(0) < 0|0>0&(xo+vo*(0-xr)/0+A()/2*((0-xr)/0)^2 < ixo()|ixo() < xo+Vmin()*(0-xr)/0) :: RAfterX(xr) :: OAfterX(xo) :: RAfterX(xr) :: OAfterX(ao*(t_^2/2)+vo*t_+xo) :: xr+stopDist(0) < 0 :: nil",
          "[?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();][t:=0;]\forall t_ (t_>=0->t_+t<=ep()&ar*t_+vr>=0&ao*t_+vo>=Vmin()->loopinv(ar*(t_^2/2)+vr*t_+xr,ar*t_+vr,0,ao*(t_^2/2)+vo*t_+xo,ao*t_+vo))":
            expand "loopinv";
            andL('L)*;
            andR('R=="0<=A()*t_+vr&Vmin()<=ao*t_+vo&(RAfterX(A()*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|A()*(t_^2/2)+vr*t_+xr+stopDist(A()*t_+vr) < 0|A()*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr)+A()/2*((0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr)))"); <(
              "0<=A()*t_+vr":
                QE using "A()*t_+vr>=0 :: 0<=A()*t_+vr :: nil",
              "Vmin()<=ao*t_+vo&(RAfterX(A()*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|A()*(t_^2/2)+vr*t_+xr+stopDist(A()*t_+vr) < 0|A()*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr)+A()/2*((0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr)))":
                andR('R=="Vmin()<=ao*t_+vo&(RAfterX(A()*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|A()*(t_^2/2)+vr*t_+xr+stopDist(A()*t_+vr) < 0|A()*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr)+A()/2*((0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr)))"); <(
                  "Vmin()<=ao*t_+vo":
                    QE using "ao*t_+vo>=Vmin() :: Vmin()<=ao*t_+vo :: nil",
                  "RAfterX(A()*(t_^2/2)+vr*t_+xr)|OAfterX(ao*(t_^2/2)+vo*t_+xo)|A()*(t_^2/2)+vr*t_+xr+stopDist(A()*t_+vr) < 0|A()*t_+vr>0&(ao*(t_^2/2)+vo*t_+xo+(ao*t_+vo)*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr)+A()/2*((0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr))^2 < ixo()|ixo() < ao*(t_^2/2)+vo*t_+xo+Vmin()*(0-(A()*(t_^2/2)+vr*t_+xr))/(A()*t_+vr))":
                    orR('R)*;
                    QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: xr+stopDist(vr)+accComp(vr) < ixr() :: t_>=0 :: -b()<=ao :: ao<=A() :: t_+0<=ep() :: A()*t_+vr>=0 :: ao*t_+vo>=Vmin() :: 0<=vr :: Vmin()<=vo :: RAfterX(A()*(t_^2/2)+vr*t_+xr) :: A()*(t_^2/2)+vr*t_+xr+stopDist(A()*t_+vr) < 0 :: nil"
                )
            )
        )
    ),
  "<dwcx{|^@|};>RAfterX(xr)":
    expand "dwcx";
    useAt("<*> merge", "1", 'R=="<{obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};}*>RAfterX(xr)");
    expand "obstacle";
    expand "robot";
    expand "dyn";
    con("v", "A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+v*ep()*Vmin()>0", 'R=="<{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)"); <(
      "Init":
        QE,
      "Post":
        andL('L)*;
        edit("xo>0", 'L=="xo>0|vr=0");
        iterated('R=="<{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
        orR('R=="RAfterX(xr)|<{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
        composed('R=="<{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
        composed('R=="<ao:=*;?-b()<=ao&ao<=A();><{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
        randomd('R=="<ao:=*;><?-b()<=ao&ao<=A();><{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
        existsR("0", 'R=="\exists ao <?-b()<=ao&ao<=A();><{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
        testd('R=="<?-b()<=0&0<=A();><{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
        andR('R=="(-b()<=0&0<=A())&<{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)"); <(
          "-b()<=0&0<=A()":
            QE using "A()>0 :: b()>0 :: -b()<=0&0<=A() :: nil",
          "<{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)":
            composed('R=="<{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
            composed('R=="<{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
            choiced('R=="<?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
            orR('R=="<?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)|<?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
            hideR('R=="<?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
            composed('R=="<?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
            testd('R=="<?RAfterX(xr)|OAfterX(xo);><ar:=*;?-b()<=ar&ar<=A();><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
            andR('R=="(RAfterX(xr)|OAfterX(xo))&<ar:=*;?-b()<=ar&ar<=A();><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)"); <(
              "RAfterX(xr)|OAfterX(xo)":
                QE,
              "<ar:=*;?-b()<=ar&ar<=A();><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)":
                composed('R=="<ar:=*;?-b()<=ar&ar<=A();><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
                randomd('R=="<ar:=*;><?-b()<=ar&ar<=A();><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
                existsR("A()", 'R=="\exists ar <?-b()<=ar&ar<=A();><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
                testd('R=="<?-b()<=A()&A()<=A();><t:=0;><{xr'=vr,vr'=A(),xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
                andR('R=="(-b()<=A()&A()<=A())&<t:=0;><{xr'=vr,vr'=A(),xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)"); <(
                  "-b()<=A()&A()<=A()":
                    QE using "A()>0 :: b()>0 :: -b()<=A()&A()<=A() :: nil",
                  "<t:=0;><{xr'=vr,vr'=A(),xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)":
                    assignd('R=="<t:=0;><{xr'=vr,vr'=A(),xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
                    solve('R=="<{xr'=vr,vr'=A(),xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
                    existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr_1>=0)&\forall vo (vo=vo_1->\forall vr (vr=A()*t_+vr_1->\forall xo (xo=vo_1*t_+xo_1->\forall xr (xr=A()*(t_^2/2)+vr_1*t_+xr_1-><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr))))))");
                    simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+t<=ep()&A()*s_+vr_1>=0)&\forall vo (vo=vo_1->\forall vr (vr=A()*ep()+vr_1->\forall xo (xo=vo_1*ep()+xo_1->\forall xr (xr=A()*(ep()^2/2)+vr_1*ep()+xr_1-><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)))))") using "ep()>0";
                    andR('R=="\forall s_ (0<=s_&s_<=ep()->s_+t<=ep()&A()*s_+vr_1>=0)&\forall vo (vo=vo_1->\forall vr (vr=A()*ep()+vr_1->\forall xo (xo=vo_1*ep()+xo_1->\forall xr (xr=A()*(ep()^2/2)+vr_1*ep()+xr_1-><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)))))"); <(
                      "\forall s_ (0<=s_&s_<=ep()->s_+t<=ep()&A()*s_+vr_1>=0)":
                        QE using "A()>0 :: ep()>0 :: vr_1>=0 :: t=0 :: \forall s_ (0<=s_&s_<=ep()->s_+t<=ep()&A()*s_+vr_1>=0) :: nil",
                      "\forall vo (vo=vo_1->\forall vr (vr=A()*ep()+vr_1->\forall xo (xo=vo_1*ep()+xo_1->\forall xr (xr=A()*(ep()^2/2)+vr_1*ep()+xr_1-><{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)))))":
                        (allR(2) ; implyR(2))*4;
                        edit("vr>=A()*ep()", 'L=="vr=A()*ep()+vr_1") using "A()>0 :: ep()>0 :: vr_1>=0 :: nil";
                        edit("xr>=xr_1", 'L=="xr=A()*(ep()^2/2)+vr_1*ep()+xr_1") using "A()>0 :: ep()>0 :: vr_1>=0 :: nil";
                        edit("xo>0", 'L=="xo=vo_1*ep()+xo_1") using "ep()>0 :: Vmin()>0 :: vo_1>=Vmin() :: xo_1>0 :: nil";
                        con("w", "A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&xo>0&vr>=A()*ep()&xr+w*ep()*(A()*ep())>0", 'R=="<{{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)"); <(
                          "Init":
                            QE,
                          "Post":
                            QE,
                          "Step":
                            andL('L)*;
                            composed('R=="<{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)");
                            composed('R=="<ao:=*;?-b()<=ao&ao<=A();><{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)");
                            randomd('R=="<ao:=*;><?-b()<=ao&ao<=A();><{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)");
                            existsR("0", 'R=="\exists ao <?-b()<=ao&ao<=A();><{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)");
                            testd('R=="<?-b()<=0&0<=A();><{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)");
                            andR('R=="(-b()<=0&0<=A())&<{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)"); <(
                              "-b()<=0&0<=A()":
                                QE using "A()>0 :: b()>0 :: -b()<=0&0<=A() :: nil",
                              "<{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)":
                                composed('R=="<{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)");
                                solve('R=="<{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;>#<{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)#");
                                composed('R=="<{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                                choiced('R=="<?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                                orR('R=="<?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)|<?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                                composed('R=="<?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                                testd('R=="<?RAfterX(xr)|OAfterX(xo);><ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                                hideR('R=="<?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                                andR('R=="(RAfterX(xr)|OAfterX(xo))&<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)"); <(
                                  "RAfterX(xr)|OAfterX(xo)":
                                    QE,
                                  "<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)":
                                    composed('R=="<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                                    randomd('R=="<ar:=*;><?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                                    existsR("A()", 'R=="\exists ar <?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                                    testd('R=="<?-b()<=A()&A()<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&A()*t_+vr>=A()*ep()&A()*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                                    andR('R=="(-b()<=A()&A()<=A())&<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&A()*t_+vr>=A()*ep()&A()*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)"); <(
                                      "-b()<=A()&A()<=A()":
                                        QE using "A()>0 :: b()>0 :: -b()<=A()&A()<=A() :: nil",
                                      "<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&A()*t_+vr>=A()*ep()&A()*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)":
                                        assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&A()*t_+vr>=A()*ep()&A()*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                                        existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&A()*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*t_+xo>0&A()*t_+vr>=A()*ep()&A()*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                                        simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&A()*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vo*ep()+xo>0&A()*ep()+vr>=A()*ep()&A()*(ep()^2/2)+vr*ep()+xr+(w-1)*ep()*(A()*ep())>0") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: xo>0 :: nil";
                                        QE
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),
      "Step":
        andL('L)*;
        composed('R=="<{ao:=*;?-b()<=ao&ao<=A();}{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+(v-1)*ep()*Vmin()>0)");
        composed('R=="<ao:=*;?-b()<=ao&ao<=A();><{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+(v-1)*ep()*Vmin()>0)");
        randomd('R=="<ao:=*;><?-b()<=ao&ao<=A();><{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+(v-1)*ep()*Vmin()>0)");
        existsR("0", 'R=="\exists ao <?-b()<=ao&ao<=A();><{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+(v-1)*ep()*Vmin()>0)");
        testd('R=="<?-b()<=0&0<=A();><{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+(v-1)*ep()*Vmin()>0)");
        andR('R=="(-b()<=0&0<=A())&<{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+(v-1)*ep()*Vmin()>0)"); <(
          "-b()<=0&0<=A()":
            QE using "A()>0 :: b()>0 :: -b()<=0&0<=A() :: nil",
          "<{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+(v-1)*ep()*Vmin()>0)":
            composed('R=="<{{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+(v-1)*ep()*Vmin()>0)");
            solve('R=="<{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;>#<{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1&t<=ep()&vr>=0&vo>=Vmin()}>(A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+(v-1)*ep()*Vmin()>0)#");
            composed('R=="<{?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
            choiced('R=="<?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();++?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
            orR('R=="<?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
            orL('L=="xo>0|vr=0"); <(
              "xo>0":
                hideR('R=="<?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                composed('R=="<?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                testd('R=="<?RAfterX(xr)|OAfterX(xo);><ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                andR('R=="(RAfterX(xr)|OAfterX(xo))&<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                  "RAfterX(xr)|OAfterX(xo)":
                    QE,
                  "<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                    composed('R=="<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                    randomd('R=="<ar:=*;><?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                    existsR("0", 'R=="\exists ar <?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                    testd('R=="<?-b()<=0&0<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo>0|0*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                    andR('R=="(-b()<=0&0<=A())&<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo>0|0*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                      "-b()<=0&0<=A()":
                        QE using "A()>0 :: b()>0 :: -b()<=0&0<=A() :: nil",
                      "<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo>0|0*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                        assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo>0|0*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo>0|0*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*ep()+vr>=0&(vo*ep()+xo>0|0*ep()+vr=0)&vo*ep()+xo+(v-1)*ep()*Vmin()>0") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: nil";
                        QE
                    )
                ),
              "vr=0":
                composed('R=="<?RAfterX(xr)|OAfterX(xo);ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                testd('R=="<?RAfterX(xr)|OAfterX(xo);><ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                andR('R=="(RAfterX(xr)|OAfterX(xo))&<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                  "RAfterX(xr)|OAfterX(xo)":
                    composed('R=="<?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                    testd('R=="<?!(RAfterX(xr)|OAfterX(xo));><?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                    andR('R=="!(RAfterX(xr)|OAfterX(xo))&<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                      "!(RAfterX(xr)|OAfterX(xo))":
                        notR('R=="!(RAfterX(xr)|OAfterX(xo))");
                        id using "RAfterX(xr)|OAfterX(xo) :: RAfterX(xr)|OAfterX(xo) :: nil",
                      "<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                        choiced('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        orR('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        hideR('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        composed('R=="<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        testd('R=="<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));><?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        simplify('R=="!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())))&<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)") using "vr=0";
                        choiced('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        orR('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        hideR('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        composed('R=="<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        testd('R=="<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);><ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        simplify('R=="!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr)&<ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)") using "vr=0";
                        choiced('R=="<ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        orR('R=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        hideR('R=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        choiced('R=="<?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        orR('R=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        hideR('R=="<?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        composed('R=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        testd('R=="<?vr=0;><ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        simplify('R=="vr=0&<ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)") using "vr=0";
                        assignd('R=="<ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo>0|0*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo>0|0*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*ep()+vr>=0&(vo*ep()+xo>0|0*ep()+vr=0)&vo*ep()+xo+(v-1)*ep()*Vmin()>0") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: nil";
                        QE
                    ),
                  "<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                    hideR('R=="<?!(RAfterX(xr)|OAfterX(xo));{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                    composed('R=="<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                    randomd('R=="<ar:=*;><?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                    existsR("0", 'R=="\exists ar <?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                    testd('R=="<?-b()<=0&0<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo>0|0*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                    andR('R=="(-b()<=0&0<=A())&<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo>0|0*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                      "-b()<=0&0<=A()":
                        QE using "A()>0 :: b()>0 :: -b()<=0&0<=A() :: nil",
                      "<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo>0|0*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                        assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo>0|0*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo>0|0*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&0*s_+vr>=0&vo>=Vmin())&A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&0*ep()+vr>=0&(vo*ep()+xo>0|0*ep()+vr=0)&vo*ep()+xo+(v-1)*ep()*Vmin()>0") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vo>=Vmin() :: nil";
                        QE
                    )
                )
            )
        )
    )
)
End.

End.

Theorem "IJRR17/Theorem 13: Passive safety with trajectory distance measurement".

Definitions
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real W;       /* maximum steering */
  Real V;       /* maximum obstacle velocity */

  Real stopDist(Real v) = v^2 / (2*b) + V*v/b;
  Real accelComp(Real v, Real a) = ((a/b + 1) * (a/2 * ep^2 + ep*(v+V)));
  Real admissibleSeparationG(Real v, Real a) = stopDist(v) + accelComp(v,a);
  Real admissibleSeparationL(Real v, Real a) = -v^2/(2*a)-V*v/a;
  Real trajectoryDist(Real r, Real xo, Real xc, Real yo, Real yc) = abs(abs(r) - ((xo-xc)^2 + (yo-yc)^2)^(1/2));

  Bool isWellformedDir(Real x, Real y, Real v, Real w, Real r, Real dx, Real dy, Real xc, Real yc) <->
    r!=0 & r^2 = (x-xc)^2 + (y-yc)^2 & dx^2 + dy^2 = 1 & dx = -(y-yc)/r & dy = (x-xc)/r & w*r=v;

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A >= 0                                                                                        /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & V >= 0
  );
  /* Stopped somewhere safe initially */
  Bool initialState(Real x, Real y, Real v, Real w, Real r, Real dx, Real dy, Real xo, Real yo, Real xc, Real yc) <-> (
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir(x, y, v, w, r, dx, dy, xc, yc)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real w, Real r, Real dx, Real dy, Real xo, Real yo, Real xc, Real yc) <->
    bounds() & initialState(x, y, v, w, r, dx, dy, xo, yo, xc, yc);

  /* Conditions that are true on each loop iteration */
  Bool loopinv(Real x, Real y, Real v, Real w, Real r, Real dx, Real dy, Real xo, Real yo, Real xc, Real yc) <-> (
    v >= 0
    & isWellformedDir(x, y, v, w, r, dx, dy, xc, yc)
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v) | abs(abs(r) - ((xo-xc)^2 + (yo-yc)^2)^(1/2)) > V*v/b)
  );
End.

ProgramVariables
  Real x;    /* robot position: x */
  Real y;    /* robot position: y */
  Real v;    /* robot translational velocity */
  Real a;    /* robot translational acceleration */
  Real dx;   /* robot orientation: x */
  Real dy;   /* robot orientation: y */
  Real w;    /* robot rotational velocity */
  Real r;    /* robot curve radius */
  Real xc;
  Real yc;
  Real xo;   /* position of closest obstacle on curve */
  Real yo;
  Real vxo;  /* velocity vector of obstacle */
  Real vyo;
  Real t;    /* time */
End.

Problem
assumptions(x, y, v, w, r, dx, dy, xo, yo, xc, yc) ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; { dx:=-dx;dy:=-dy; ++ dx:=dx;dy:=dy; }; r := *; xc := *; yc := *;
            ?(r!=0 & r^2 = (x-xc)^2+(y-yc)^2 & dx=-(y-yc)/r & dy=(x-xc)/r & r*w=v); }
          ++
          /* or choose a new safe curve */
          { a := *; ?-b<=a & a<=A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xc := *; yc := *;

            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?(r!=0 & r^2 = (x-xc)^2+(y-yc)^2 & dx=-(y-yc)/r & dy=(x-xc)/r & r*w=v);

            /* use that curve, if it is a safe one (admissible velocities) */
            if (v+a*ep>=0) { ?abs(x-xo) > admissibleSeparationG(v,a) | abs(y-yo) > admissibleSeparationG(v,a) | trajectoryDist(r,xo,xc,yo,yc) > V*(ep + (v+a*ep)/b); }
            else           { ?abs(x-xo) > admissibleSeparationL(v,a) | abs(y-yo) > admissibleSeparationL(v,a) | trajectoryDist(r,xo,xc,yo,yc) > -V*v/a; }
          }
        };
        t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv(x, y, v, w, r, dx, dy, xo, yo, xc, yc))
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 13: Passive safety with trajectory distance measurement".
tactic dIHide as (
  hideL('L~="v>0->abs(x-xo)>v^2/(2*b)+V*v/b|abs(y-yo)>v^2/(2*b)+V*v/b|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V*v/b")
);

useSolver("Mathematica");
implyR(1) ; loop("loopinv(x, y, v, w, r, dx, dy, xo, yo, xc, yc)", 1) ; <(
  print("Base Case"); QE; print("Base Case Done"),
  print("Use Case"); unfold ; fullSimplify ; hideL('L=="w*r=v") ; hideL('L=="dy=(x-xc)/r") ; hideL('L=="dx=-(y-yc)/r") ; hideL('L=="dx^2+dy^2=1") ; hideL('L=="ep>0") ; orL(-5) ; <(
    hideL('L=="r^2=(x-xc)^2+(y-yc)^2") ; hideL('L=="r!=0") ; QE,
    orL(-5) ; <(
      hideL('L=="r^2=(x-xc)^2+(y-yc)^2") ; hideL('L=="r!=0") ; QE,
      edit("expand(abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2)))>V*v/b", -5) ;
      edit("expand(abs(r))-((xo-xc)^2+(yo-yc)^2)^(1/2)>=0&abs_0=abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2)|abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2) < 0&abs_0=-(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))", -8) ;
      orL(-9) ; <(
        QE,
        QE
        )
      )
    ); print("Use Case Done"),
  unfold ; <(
    print("Induction Step (1)");
    dC("t>=0&dx^2+dy^2=1&v=old(v)-b*t&w*r=v", 1) ; <(
      dC("dx=-(y-yc)/r&dy=(x-xc)/r", 1) ; <(
        dC("xo=old(xo)+vxo*t&yo=old(yo)+vyo*t", 1) ; <(
          dC("-t*(v+b/2*t)<=x-old(x)&x-old(x)<=t*(v+b/2*t)", 1) ; <(
            dC("-t*(v+b/2*t)<=y-old(y)&y-old(y)<=t*(v+b/2*t)", 1) ; <(
              print("Induction Step (1) Differential Invariants Established");
              dW(1) ; andL('L)* ; fullSimplify ; andR(1) ; <(
                hideL('L=="v_0>0->abs(x_0-xo_0)>v_0^2/(2*b)+V*v_0/b|abs(y_0-yo_0)>v_0^2/(2*b)+V*v_0/b|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V*v_0/b") ;
                QE,
                implyR(1) ; orR(1) ; orR(2) ;
                hideL('L=="A>=0") ; hideL('L=="ep>0") ; hideL('L=="t<=ep") ; hideL('L=="dx^2+dy^2=1") ;
                hideL('L=="dy=(x-xc)/r") ; hideL('L=="dx=-(y-yc)/r") ; implyL(-13) ; <(
                  hideR('R=="abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V*v/b") ; hideR('R=="abs(y-yo)>v^2/(2*b)+V*v/b") ; hideR('R=="abs(x-xo)>v^2/(2*b)+V*v/b") ; QE,
                  orL(-13) ; <(
                    hideR('R=="abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V*v/b") ; hideR('R=="abs(y-yo)>v^2/(2*b)+V*v/b") ; smartQE,
                    orL(-13) ; <(
                      hideR('R=="abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V*v/b") ; hideR('R=="abs(x-xo)>v^2/(2*b)+V*v/b") ; smartQE,
                      hideR('R=="abs(y-yo)>v^2/(2*b)+V*v/b") ; hideR('R=="abs(x-xo)>v^2/(2*b)+V*v/b") ;
                      edit("abs(abs(r)-abbrv((((xo_0-xc)^2+(yo_0-yc)^2)^(1/2),oldCDist)))>V*v_0/b", 'L=="abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V*v_0/b") ;
                      edit("abs(abs(r)-abbrv((((xo-xc)^2+(yo-yc)^2)^(1/2),cDist)))>V*v/b", 'R=="abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V*v/b") ;
                      cut("abs(cDist-oldCDist)<=t*V") ; <(
                        hideL('L=="cDist=((xo-xc)^2+(yo-yc)^2)^(1/2)") ; hideL('L=="oldCDist=((xo_0-xc)^2+(yo_0-yc)^2)^(1/2)") ;
                        hideL('L=="r^2=(x_0-xc)^2+(y_0-yc)^2") ; hideL('L=="vxo^2+vyo^2<=V^2") ;
                        QE,
                        hideR('R=="abs(abs(r)-cDist)>V*v/b") ; hideL('L=="abs(abs(r)-oldCDist)>V*v_0/b") ;
                        hideL('L=="r^2=(x_0-xc)^2+(y_0-yc)^2") ; hideL('L=="r!=0") ;
                        hideL('L=="v_0>=0") ; hideL('L=="w*r=v") ; cut("abs(cDist-oldCDist)<=t*(vxo^2+vyo^2)^(1/2)") ; <(
                          hideL('L=="cDist=((xo-xc)^2+(yo-yc)^2)^(1/2)") ; hideL('L=="oldCDist=((xo_0-xc)^2+(yo_0-yc)^2)^(1/2)") ; smartQE,
                          hideR('R=="abs(cDist-oldCDist)<=t*V") ; hideL('L=="vxo^2+vyo^2<=V^2") ;
                          hideL('L=="V>=0") ; hideL('L=="-t*(v+b/2*t)<=y-y_0") ;
                          hideL('L=="y-y_0<=t*(v+b/2*t)") ; hideL('L=="-t*(v+b/2*t)<=x-x_0") ;
                          hideL('L=="x-x_0<=t*(v+b/2*t)") ; smartQE
                          )
                        )
                      )
                    )
                  )
                ),
              dIHide ; dI(1)
              ),
            dIHide ; dI(1)
            ),
          dIHide ; dI(1)
          ),
        dIHide ; dI(1)
        ),
      dIHide ; dI(1)
      ); print("Induction Step (1) Done"),
    print("Induction Step (2)");
    dC("t>=0&dx^2+dy^2=1&v=old(v)&w*r=v", 1) ; <(
      dC("dx=-(y-yc)/r&dy=(x-xc)/r", 1) ; <(
        print("Induction Step (2) Differential Invariants Established");
        dW(1) ; andL('L)* ; fullSimplify ; prop ; doall(smartQE),
        dIHide ; dI(1)
        ),
      dIHide ; dI(1)
      ); print("Induction Step (2) Done"),
    print("Induction Step (3)");
    dIHide ; hideL('L=="r_0!=0") ; hideL('L=="r_0^2=(x-xc_0)^2+(y-yc_0)^2") ; hideL('L=="dx=-(y-yc_0)/r_0") ;
    hideL('L=="dy=(x-xc_0)/r_0") ; hideL('L=="w_0*r_0=v") ;
    dC("t>=0&dx^2+dy^2=1&v=old(v)+a*t&w*r=v", 1) ; <(
      dC("dx=-(y-yc)/r&dy=(x-xc)/r", 1) ; <(
        dC("xo=old(xo)+vxo*t&yo=old(yo)+vyo*t", 1) ; <(
          dC("-t*(v-a/2*t)<=x-old(x)&x-old(x)<=t*(v-a/2*t)", 1) ; <(
            dC("-t*(v-a/2*t)<=y-old(y)&y-old(y)<=t*(v-a/2*t)", 1) ; <(
              print("Induction Step (3) Differential Invariants Established");
              dW(1) ; andL('L)* ; fullSimplify ; andR(1) ; <(
                hideL('L=="abs(x_0-xo_0)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))|abs(y_0-yo_0)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V*(ep+(v_0+a*ep)/b)") ; QE,
                implyR(1) ; orR(1) ; orR(2) ; hideL('L=="dx^2+dy^2=1") ; hideL('L=="dy=(x-xc)/r") ; hideL('L=="dx=-(y-yc)/r") ;
                orL('L=="abs(x_0-xo_0)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))|abs(y_0-yo_0)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V*(ep+(v_0+a*ep)/b)") ; <(
                  edit("abs(x_0-xo_0)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*t^2+t*(v_0+V))", 'L=="abs(x_0-xo_0)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))") ;
                  hideL('L=="v_0+a*ep>=0") ; hideL('L=="t<=ep") ; hideL('L=="ep>0") ;
                  hideL('L=="w*r=v"); hideL('L=="r^2=(x_0-xc)^2+(y_0-yc)^2");
                  hideR('R=="abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V*v/b") ; hideR('R=="abs(y-yo)>v^2/(2*b)+V*v/b") ; smartQE,
                  orL('L=="abs(y_0-yo_0)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V*(ep+(v_0+a*ep)/b)") ; <(
                    hideR('R=="abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V*v/b") ; hideR('R=="abs(x-xo)>v^2/(2*b)+V*v/b") ;
                    edit("abs(y_0-yo_0)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*t^2+t*(v_0+V))", 'L=="abs(y_0-yo_0)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))") ;
                    hideL('L=="v_0+a*ep>=0") ; hideL('L=="ep>0") ; hideL('L=="t<=ep") ;
                    hideL('L=="w*r=v"); hideL('L=="r^2=(x_0-xc)^2+(y_0-yc)^2");
                    smartQE
                    ,
                    hideR('R=="abs(y-yo)>v^2/(2*b)+V*v/b") ; hideR('R=="abs(x-xo)>v^2/(2*b)+V*v/b") ;
                    edit("abs(abs(r)-abbrv((((xo_0-xc)^2+(yo_0-yc)^2)^(1/2),oldCDist)))>V*(ep+(v_0+a*ep)/b)", 'L=="abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V*(ep+(v_0+a*ep)/b)") ;
                    edit("abs(abs(r)-abbrv((((xo-xc)^2+(yo-yc)^2)^(1/2),cDist)))>V*v/b", 'R=="abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V*v/b") ;
                    hideL('L=="r!=0") ; hideL('L=="r^2=(x_0-xc)^2+(y_0-yc)^2") ; hideL('L=="v_0+a*ep>=0") ; cut("abs(cDist-oldCDist)<=t*V") ; <(
                      hideL('L=="oldCDist=((xo_0-xc)^2+(yo_0-yc)^2)^(1/2)") ; hideL('L=="cDist=((xo-xc)^2+(yo-yc)^2)^(1/2)") ;
                      edit("abs(abs(r)-oldCDist)>V*(t+(v_0+a*t)/b)", 'L=="abs(abs(r)-oldCDist)>V*(ep+(v_0+a*ep)/b)") ;
                      hideL('L=="ep>0") ; hideL('L=="t<=ep") ; smartQE
                      ,
                      hideR('R=="abs(abs(r)-cDist)>V*v/b") ; hideL('L=="abs(abs(r)-oldCDist)>V*(ep+(v_0+a*ep)/b)") ;
                      hideL('L=="t<=ep") ; hideL('L=="ep>0") ; cut("abs(cDist-oldCDist)<=t*(vxo^2+vyo^2)^(1/2)") ; <(
                        hideL('L=="oldCDist=((xo_0-xc)^2+(yo_0-yc)^2)^(1/2)") ; hideL('L=="cDist=((xo-xc)^2+(yo-yc)^2)^(1/2)") ;
                        edit("abbrv((abs(cDist-oldCDist),X))<=t*V", 'R=="abs(cDist-oldCDist)<=t*V") ;
                        hideL('L=="X=abs(cDist-oldCDist)") ; hideL('L=="A>=0") ; hideL('L=="-b<=a") ; hideL('L=="a<=A") ; hideL('L=="-t*(v-a/2*t)<=y-y_0") ; hideL('L=="y-y_0<=t*(v-a/2*t)") ; hideL('L=="-t*(v-a/2*t)<=x-x_0") ; hideL('L=="x-x_0<=t*(v-a/2*t)") ; hideL('L=="xo=xo_0+vxo*t") ; hideL('L=="yo=yo_0+vyo*t") ; hideL('L=="v=v_0+a*t") ; hideL('L=="v>=0") ; hideL('L=="w*r=v") ; hideL('L=="v>0") ; hideL('L=="b>0") ; QE,
                        hideR('R=="abs(cDist-oldCDist)<=t*V") ; hideL('L=="vxo^2+vyo^2<=V^2") ; hideL('L=="V>=0") ; hideL('L=="w*r=v") ; hideL('L=="a<=A") ; hideL('L=="A>=0") ; hideL('L=="-t*(v-a/2*t)<=y-y_0") ; hideL('L=="y-y_0<=t*(v-a/2*t)") ; hideL('L=="-t*(v-a/2*t)<=x-x_0") ; hideL('L=="x-x_0<=t*(v-a/2*t)") ; hideL('L=="v=v_0+a*t") ; hideL('L=="v>0") ; hideL('L=="v>=0") ; hideL('L=="-b<=a") ; hideL('L=="b>0") ; smartQE
                        )
                      )
                    )
                  )
                ),
              hideL('L=="abs(x_0-xo_0)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))|abs(y_0-yo_0)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V*(ep+(v_0+a*ep)/b)") ; dI(1)
              ),
            hideL('L=="abs(x_0-xo_0)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))|abs(y-yo_0)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V*(ep+(v_0+a*ep)/b)") ; dI(1)
            ),
          hideL('L=="abs(x-xo_0)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))|abs(y-yo_0)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V*(ep+(v_0+a*ep)/b)") ; dI(1)
          ),
        hideL('L=="abs(x-xo)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))|abs(y-yo)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V*(ep+(v_0+a*ep)/b)") ; dI(1)
        ),
      hideL('L=="abs(x-xo)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))|abs(y-yo)>v_0^2/(2*b)+V*v_0/b+(a/b+1)*(a/2*ep^2+ep*(v_0+V))|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V*(ep+(v_0+a*ep)/b)") ; dI(1)
      ); print("Induction Step (3) Done"),
    print("Induction Step (4)");
    dC("t>=0&dx^2+dy^2=1&v=old(v)&w*r=v", 1) ; <(
      dC("dx=-(y-yc)/r&dy=(x-xc)/r", 1) ; <(
        print("Induction Step (4) Differential Invariants Established");
        dW(1) ; andL('L)* ; fullSimplify;
        andR(1); <(
          QE
          ,
          hideL('L=="w*r=v"); hideL('L=="dx^2+dy^2=1");
          hideL('L=="dy=(x-xc)/r"); hideL('L=="dx=-(y-yc)/r");
          hideL('L=="r_0!=0");
          hideL('L=="r!=0");
          smartQE
        )
        ,
        hideL('L=="v_0>0->abs(x-xo)>v_0^2/(2*b)+V*v_0/b|abs(y-yo)>v_0^2/(2*b)+V*v_0/b|abs(abs(r_0)-((xo-xc_0)^2+(yo-yc_0)^2)^(1/2))>V*v_0/b") ; dI(1)
        ),
      hideL('L=="v_0>0->abs(x-xo)>v_0^2/(2*b)+V*v_0/b|abs(y-yo)>v_0^2/(2*b)+V*v_0/b|abs(abs(r_0)-((xo-xc_0)^2+(yo-yc_0)^2)^(1/2))>V*v_0/b") ; dI(1)
      ); print("Induction Step (4) Done"),
    print("Induction Step (5)");
    hideL('L=="v>0->abs(x-xo_0)>v^2/(2*b)+V*v/b|abs(y-yo_0)>v^2/(2*b)+V*v/b|abs(abs(r_0)-((xo_0-xc_0)^2+(yo_0-yc_0)^2)^(1/2))>V*v/b") ;
    hideL('L=="r_0!=0") ; hideL('L=="r_0^2=(x-xc_0)^2+(y-yc_0)^2") ; hideL('L=="dx=-(y-yc_0)/r_0") ;
    hideL('L=="dy=(x-xc_0)/r_0") ; hideL('L=="w_0*r_0=v") ; hideL('L=="-W<=w") ; hideL('L=="w<=W") ; cut("a < 0") ; <(
      hideL('L=="a<=A") ; hideL('L=="A>=0") ; dC("t>=0&dx^2+dy^2=1&v=old(v)+a*t&w*r=v", 1) ; <(
        dC("dx=-(y-yc)/r&dy=(x-xc)/r", 1) ; <(
          dC("xo=old(xo)+vxo*t&yo=old(yo)+vyo*t", 1) ; <(
            dC("-t*(v-a/2*t)<=x-old(x)&x-old(x)<=t*(v-a/2*t)", 1) ; <(
              dC("-t*(v-a/2*t)<=y-old(y)&y-old(y)<=t*(v-a/2*t)", 1) ; <(
                print("Induction Step (5) Differential Invariants Established");
                dW(1) ; andL('L)* ; fullSimplify ; andR(1) ; <(
                  hideL('L=="abs(x_0-xo_0)>-v_0^2/(2*a)-V*v_0/a|abs(y_0-yo_0)>-v_0^2/(2*a)-V*v_0/a|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>-V*v_0/a") ; QE,
                  implyR(1) ; orR(1) ; orR(2) ; hideL('L=="dx^2+dy^2=1") ; hideL('L=="dy=(x-xc)/r") ; hideL('L=="dx=-(y-yc)/r") ;
                  orL('L=="abs(x_0-xo_0)>-v_0^2/(2*a)-V*v_0/a|abs(y_0-yo_0)>-v_0^2/(2*a)-V*v_0/a|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>-V*v_0/a") ; <(
                    hideR('R=="abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V*v/b") ; hideR('R=="abs(y-yo)>v^2/(2*b)+V*v/b") ; smartQE,
                    orL('L=="abs(y_0-yo_0)>-v_0^2/(2*a)-V*v_0/a|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>-V*v_0/a") ; <(
                      hideR('R=="abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V*v/b") ; hideR('R=="abs(x-xo)>v^2/(2*b)+V*v/b") ; smartQE,
                      hideR('R=="abs(y-yo)>v^2/(2*b)+V*v/b") ; hideR('R=="abs(x-xo)>v^2/(2*b)+V*v/b") ;
                      edit("abs(abs(r)-abbrv((((xo_0-xc)^2+(yo_0-yc)^2)^(1/2),oldCDist)))>-V*v_0/a", 'L=="abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>-V*v_0/a") ;
                      edit("abs(abs(r)-abbrv((((xo-xc)^2+(yo-yc)^2)^(1/2),cDist)))>V*v/b", 'R=="abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V*v/b") ;
                      cut("abs(cDist-oldCDist)<=t*V") ; <(
                        hideL('L=="cDist=((xo-xc)^2+(yo-yc)^2)^(1/2)") ; hideL('L=="oldCDist=((xo_0-xc)^2+(yo_0-yc)^2)^(1/2)") ; smartQE,
                        hideR('R=="abs(abs(r)-cDist)>V*v/b") ;
                        hideL('L=="-t*(v-a/2*t)<=y-y_0") ; hideL('L=="y-y_0<=t*(v-a/2*t)") ;
                        hideL('L=="-t*(v-a/2*t)<=x-x_0") ; hideL('L=="x-x_0<=t*(v-a/2*t)") ;
                        hideL('L=="v=v_0+a*t") ; hideL('L=="w*r=v") ; hideL('L=="v>0") ; hideL('L=="v>=0") ;
                        hideL('L=="t<=ep") ; hideL('L=="ep>0") ; hideL('L=="r!=0") ; hideL('L=="r^2=(x_0-xc)^2+(y_0-yc)^2") ;
                        hideL('L=="-b<=a") ; hideL('L=="b>0") ;
                        cut("abs(cDist-oldCDist)<=t*(vxo^2+vyo^2)^(1/2)") ; <(
                          hideL('L=="oldCDist=((xo_0-xc)^2+(yo_0-yc)^2)^(1/2)") ; hideL('L=="cDist=((xo-xc)^2+(yo-yc)^2)^(1/2)") ;
                          edit("abbrv((abs(cDist-oldCDist),X))<=t*V", 'R=="abs(cDist-oldCDist)<=t*V") ;
                          hideL('L=="X=abs(cDist-oldCDist)") ; hideL('L=="abs(abs(r)-oldCDist)>-V*v_0/a") ; QE,
                          hideR('R=="abs(cDist-oldCDist)<=t*V") ; hideL('L=="vxo^2+vyo^2<=V^2") ;
                          hideL('L=="abs(abs(r)-oldCDist)>-V*v_0/a") ; hideL('L=="a < 0") ; hideL('L=="V>=0") ; hideL('L=="v_0>=0");
                          smartQE
                          )
                        )
                      )
                    )
                  ),
                hideL('L=="abs(x_0-xo_0)>-v_0^2/(2*a)-V*v_0/a|abs(y_0-yo_0)>-v_0^2/(2*a)-V*v_0/a|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>-V*v_0/a") ; dI(1)
                ),
              hideL('L=="abs(x_0-xo_0)>-v_0^2/(2*a)-V*v_0/a|abs(y-yo_0)>-v_0^2/(2*a)-V*v_0/a|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>-V*v_0/a") ; dI(1)
              ),
            hideL('L=="abs(x-xo_0)>-v_0^2/(2*a)-V*v_0/a|abs(y-yo_0)>-v_0^2/(2*a)-V*v_0/a|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>-V*v_0/a") ; dI(1)
            ),
          hideL('L=="abs(x-xo)>-v_0^2/(2*a)-V*v_0/a|abs(y-yo)>-v_0^2/(2*a)-V*v_0/a|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>-V*v_0/a") ; dI(1)
          ),
        hideL('L=="abs(x-xo)>-v_0^2/(2*a)-V*v_0/a|abs(y-yo)>-v_0^2/(2*a)-V*v_0/a|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>-V*v_0/a") ; dI(1)
        ),
      hideR('R=="[{x'=v*dx,y'=v*dy,v'=a,dx'=-w*dy,dy'=w*dx,w'=a/r,xo'=vxo,yo'=vyo,t'=1&t<=ep&v>=0}](v>=0&(r!=0&r^2=(x-xc)^2+(y-yc)^2&dx^2+dy^2=1&dx=-(y-yc)/r&dy=(x-xc)/r&w*r=v)&(v>0->abs(x-xo)>v^2/(2*b)+V*v/b|abs(y-yo)>v^2/(2*b)+V*v/b|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V*v/b))") ; hideL('L=="abs(x-xo)>-v^2/(2*a)-V*v/a|abs(y-yo)>-v^2/(2*a)-V*v/a|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>-V*v/a") ; QE
      )
    ); print("Induction Step (5) Done")
  ); print("Proof Done")
End.

End.

Theorem "IJRR17/Theorem 14: Reach waypoint with deadline".

/*
 *	Robot must stop within distance delta at goal.
 *
 *  Robot
 * 	- must stop within distance delta of goal
 *  - can only drive straight and forward
 *  - ensures progress towards goal
 *
 *  Liveness property:
 *  - Robot can stop at goal
 *
 */

Definitions
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real GDelta;	 /* goal area size */
  Real Vmax;    /* robot cannot go faster than this */

  Real waypointStartDist(Real xg) = xg-GDelta;
  Real waypointEndDist(Real xg)   = xg+GDelta;

  Real minV = A*ep;
  Real maxTravelTime(Real g) = waypointStartDist(g)/minV;
  Real stopTime(Real v)      = v/b;
  Real speedUpTime(Real v)   = ep-v/A;

  Real stopDist(Real v) = v^2/(2*b);
  Real accComp(Real v)  = ( (A/b + 1)*(A/2*ep^2 + ep*v) );

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A > 0                                                                                         /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & Vmax >= 2*A*ep
    & GDelta > Vmax*ep + Vmax^2/(2*b)  /* waypoint is large enough that robot can start driving and still stop inside */
  );

  Bool initialState(Real xr, Real vr, Real xg, Real T) <-> (                      /* Stopped somewhere safe initially */
    vr = 0
    & xr < waypointStartDist(xg)
    & T > ep + maxTravelTime(xg-xr) + ep + stopTime(Vmax)
  );
  Bool assumptions(Real xr, Real vr, Real xg, Real T) <->              /* Under these assumptions we guarantee safety */
    bounds() & initialState(xr, vr, xg, T);

  Bool loopinv(Real xr, Real vr, Real xg) <-> (
    0 <= vr & vr <= Vmax & xr + stopDist(vr) < waypointEndDist(xg)
            & (waypointStartDist(xg) < xr -> (vr = 0 | T >= stopTime(vr)))
            & (xr <= waypointStartDist(xg) ->
                   (vr >= minV & T > maxTravelTime(xg-xr) + ep + stopTime(Vmax))
                 | (vr <= minV & T > speedUpTime(vr) + maxTravelTime(xg-xr) + ep + stopTime(Vmax)))
  );

  HP ctrl ::= {
    if (xr > waypointStartDist(xg)) {
      /* in the goal area: brake or stay stopped */
      ar := -b; ++ ?vr = 0; ar := 0;
    } else {
      if (xr + stopDist(vr) + accComp(vr) < waypointEndDist(xg) & vr+A*ep <= Vmax) {
        /* if robot can stop from higher speed before leaving goal area then accelerate */
        ar := A;
      } else {
        /* else coast until at goal */
        ar := 0;
      }
    }
  };

  HP dyn ::= { {xr' = vr, vr' = ar, t' = 1, T'=-1 & t <= ep & vr >= 0} };

  HP dwwpdl ::= {
    {	{ ctrl; t := 0; }
      dyn;
    }*@invariant(loopinv(xr, vr, xg))
  };
End.

ProgramVariables
  Real xr;		/* robot position: x */
  Real vr;		/* robot translational velocity */
  Real ar;		/* robot translational acceleration */
  Real xg;		/* goal position */
  Real t;		  /* control cycle time */
  Real T;		  /* global time */
End.

Problem
  assumptions(xr, vr, xg, T)
    -> [ dwwpdl; ](xr < waypointEndDist(xg) & (T <= 0 -> (waypointStartDist(xg) < xr & vr = 0)))
     & < dwwpdl; >(waypointStartDist(xg) < xr & vr = 0)
End.

Tactic "Proof Theorem 14: Reach waypoint with deadline".
  useSolver("Mathematica");
  implyR(1) ; andR(1) ; <(
    loop("0<=vr&vr<=Vmax&xr+vr^2/(2*b) < xg+GDelta&(xg-GDelta < xr->vr=0|T>=vr/b)&(xr<=xg-GDelta->vr>=A*ep&T>(xg-xr-GDelta)/(A*ep)+ep+Vmax/b|vr<=A*ep&T>ep-vr/A+(xg-xr-GDelta)/(A*ep)+ep+Vmax/b)", 1) ; <(
      QE,
      andR(1) ; <(
        andL('L)* ; hideL('L=="xr<=xg-GDelta->vr>=A*ep&T>(xg-xr-GDelta)/(A*ep)+ep+Vmax/b|vr<=A*ep&T>ep-vr/A+(xg-xr-GDelta)/(A*ep)+ep+Vmax/b") ; QE,
        implyR(1) ; andL('L)* ; andR(1) ; <(
          hideL('L=="xg-GDelta < xr->vr=0|T>=vr/b") ; implyL(-10) ; <(
            QE,
            QE
            ),
          implyL(-10) ; <(
            implyL(-10) ; <(
              QE,
              QE
              ),
            hideL('L=="xr<=xg-GDelta->vr>=A*ep&T>(xg-xr-GDelta)/(A*ep)+ep+Vmax/b|vr<=A*ep&T>ep-vr/A+(xg-xr-GDelta)/(A*ep)+ep+Vmax/b") ; QE
            )
          )
        ),
      andL('L)* ; notGreater(1.0.0.0.1.0.0) ; notAnd(1.0.0.0.1.1.1.0.0) ; composeb(1) ; solve(1.1) ; chase(1) ; andR(1) ; <(
        implyR(1) ; fullSimplify ; andR(1) ; <(
          allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
            QE,
            andR(1) ; <(
              QE,
              andR(1) ; <(
                QE,
                andR(1) ; <(
                  QE,
                  implyR(1) ; orR(1) ; allL("t_", -12) ; implyL(-12) ; <(
                    hideR('R=="(-b)*t_+vr>=A*ep&-t_+T>(xg-((-b)*(t_^2/2)+vr*t_+xr)-GDelta)/(A*ep)+ep+Vmax/b") ; hideR('R=="(-b)*t_+vr<=A*ep&-t_+T>ep-((-b)*t_+vr)/A+(xg-((-b)*(t_^2/2)+vr*t_+xr)-GDelta)/(A*ep)+ep+Vmax/b") ; QE,
                    hideR('R=="(-b)*t_+vr>=A*ep&-t_+T>(xg-((-b)*(t_^2/2)+vr*t_+xr)-GDelta)/(A*ep)+ep+Vmax/b") ; hideR('R=="(-b)*t_+vr<=A*ep&-t_+T>ep-((-b)*t_+vr)/A+(xg-((-b)*(t_^2/2)+vr*t_+xr)-GDelta)/(A*ep)+ep+Vmax/b") ; hideL('L=="GDelta>Vmax*ep+Vmax^2/(2*b)") ; hideL('L=="xr+vr^2/(2*b) < xg+GDelta") ; QE
                    )
                  )
                )
              )
            ),
          implyR(1) ; fullSimplify ; allR(1) ; implyR(1) ; implyR(1) ; QE
          ),
        implyR(1) ; fullSimplify ; andR(1) ; <(
          implyR(1) ; andL(-11) ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
            QE,
            andR(1) ; <(
              QE,
              andR(1) ; <(
                hideL('L=="vr>=A*ep&T>(xg-xr-GDelta)/(A*ep)+ep+Vmax/b|vr<=A*ep&T>ep-vr/A+(xg-xr-GDelta)/(A*ep)+ep+Vmax/b") ; hideL('L=="xr<=xg-GDelta") ; hideL('L=="xr+vr^2/(2*b) < xg+GDelta") ; hideL('L=="Vmax>=2*A*ep") ; hideL('L=="GDelta>Vmax*ep+Vmax^2/(2*b)") ; hideL('L=="vr<=Vmax") ; hideL('L=="vr+A*ep<=Vmax") ; QE,
                andR(1) ; <(
                  hideL('L=="xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta") ; hideL(-8=="xr+vr^2/(2*b) < xg+GDelta") ; implyR(1) ; orR(1) ; QE,
                  implyR(1) ; orR(1) ; hideL('L=="xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta") ; hideL('L=="xr+vr^2/(2*b) < xg+GDelta") ; orL(-8) ; <(
                    hideR('R=="A*t_+vr<=A*ep&-t_+T>ep-(A*t_+vr)/A+(xg-(A*(t_^2/2)+vr*t_+xr)-GDelta)/(A*ep)+ep+Vmax/b") ; andL(-8) ; andR(1) ; <(
                      QE,
                      QE
                      ),
                    andL(-8) ; andR(1) ; <(
                      andR(2) ; <(
                        QE,
                        QE
                        ),
                      andR(2) ; <(
                        allL("t_", -11) ; implyL(-11) ; <(
                          hideR('R=="-t_+T>(xg-(A*(t_^2/2)+vr*t_+xr)-GDelta)/(A*ep)+ep+Vmax/b") ; hideR('R=="A*t_+vr<=A*ep") ; QE,
                          andL(-11) ; hideL('L=="A*(t_^2/2)+vr*t_+xr<=xg-GDelta") ; hideL('L=="GDelta>Vmax*ep+Vmax^2/(2*b)") ; edit("-t_+T>(xg-(A*(t_^2/2)+vr*t_+xr)-GDelta)/(A*ep)+abbrv(ep+Vmax/b)", 1) ; edit("T>ep-vr/A+(xg-xr-GDelta)/(A*ep)+abbrv", -11) ; hideL('L=="abbrv=ep+Vmax/b") ; edit("vr+A*t_<=Vmax", -8) ; QE
                          ),
                        QE
                        )
                      )
                    )
                  )
                )
              )
            ),
          implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
            hideL('L=="vr>=A*ep&T>(xg-xr-GDelta)/(A*ep)+ep+Vmax/b|vr<=A*ep&T>ep-vr/A+(xg-xr-GDelta)/(A*ep)+ep+Vmax/b") ; hideL('L=="xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr)>=xg+GDelta|vr+A*ep>Vmax") ; QE,
            andR(1) ; <(
              hideL('L=="xr+vr^2/(2*b) < xg+GDelta") ; allL("t_", -12) ; implyL(-12) ; <(
                hideR('R=="xg-GDelta < vr*t_+xr->vr=0|-t_+T>=vr/b") ; QE,
                orL(-8) ; <(
                  orL(-10) ; <(
                    QE,
                    QE
                    ),
                  implyR(1) ; orR(1) ; orL(-10) ; <(
                    QE,
                    QE
                    )
                  )
                ),
              implyR(1) ; orR(1) ; fullSimplify ; orL(-9) ; <(
                hideR('R=="vr<=A*ep&-t_+T>ep-vr/A+(xg-(vr*t_+xr)-GDelta)/(A*ep)+ep+Vmax/b") ; andL(-9) ; fullSimplify ; orL(-10) ; <(
                  edit("-t_+T>(xg-(vr*t_+xr)-GDelta)/(A*ep)+abbrv(ep+Vmax/b)", 1) ; edit("T>(xg-xr-GDelta)/(A*ep)+abbrv", -15) ; hideL('L=="abbrv=ep+Vmax/b") ; allL("t_", -12) ; implyL(-12) ; <(
                    QE,
                    hideL('L=="xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr)>=xg+GDelta") ; hideL('L=="GDelta>Vmax*ep+Vmax^2/(2*b)") ; QE
                    ),
                  allL("t_", -12) ; implyL(-12) ; <(
                    QE,
                    edit("-t_+T>(xg-(vr*t_+xr)-GDelta)/(A*ep)+abbrv(ep+Vmax/b)", 1) ; edit("T>(xg-xr-GDelta)/(A*ep)+abbrv", -15) ; hideL('L=="abbrv=ep+Vmax/b") ; hideL('L=="xr+vr^2/(2*b) < xg+GDelta") ; hideL('L=="GDelta>Vmax*ep+Vmax^2/(2*b)") ; QE
                    )
                  ),
                allL("t_", -13) ; implyL(-13) ; <(
                  hideR('R=="vr>=A*ep&-t_+T>(xg-(vr*t_+xr)-GDelta)/(A*ep)+ep+Vmax/b") ; hideR('R=="vr<=A*ep&-t_+T>ep-vr/A+(xg-(vr*t_+xr)-GDelta)/(A*ep)+ep+Vmax/b") ; QE,
                  andL(-9) ; fullSimplify ; hideR(1=="vr>=A*ep&-t_+T>(xg-(vr*t_+xr)-GDelta)/(A*ep)+ep+Vmax/b") ; hideR('R=="-t_+T>ep-vr/A+(xg-(vr*t_+xr)-GDelta)/(A*ep)+ep+Vmax/b") ; orL(-10) ; <(
                    hideL('L=="T>ep-vr/A+(xg-xr-GDelta)/(A*ep)+ep+Vmax/b") ; hideL('L=="xr<=xg-GDelta") ; QE,
                    hideL('L=="T>ep-vr/A+(xg-xr-GDelta)/(A*ep)+ep+Vmax/b") ; QE
                    )
                  )
                )
              )
            )
          )
        )
      ),
    notGreater(1.0.0.0.0.1.0.0) ; notAnd(1.0.0.0.0.1.1.1.0.0) ; iterated(1) ; orR(1) ; composed(2) ; solve(2.1) ; composed(2) ; choiced(2) ; orR(2) ;
    hideR('R=="<?xr_1>xg-GDelta;{ar:=-b;++?vr_1=0;ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep&ar*s_+vr_1>=0)&\forall T (T=-t_+T_1->\forall vr (vr=ar*t_+vr_1->\forall xr (xr=ar*(t_^2/2)+vr_1*t_+xr_1 -> <{{{?xr>xg-GDelta;{ar:=-b;++?vr=0;ar:=0;}++?xr<=xg-GDelta;{?xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta&vr+A*ep<=Vmax;ar:=A;++?!xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta|!vr+A*ep<=Vmax;ar:=0;}}t:=0;}{xr'=vr,vr'=ar,t'=1,T'=-1&t<=ep&vr>=0}}*>(xg-GDelta < xr&vr=0)))))") ;
    composed(2) ; andL('L)* ; testd(2) ; hideL('L=="T_1>ep+(xg-xr_1-GDelta)/(A*ep)+ep+Vmax/b") ;
    simplify(2) ; choiced(2) ; orR(2) ; composed(2) ; testd(2) ; andR(2) ; <(
      hideR('R=="<?!xr_1+vr_1^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr_1) < xg+GDelta|!vr_1+A*ep<=Vmax;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep&ar*s_+vr_1>=0)&\forall T (T=-t_+T_1->\forall vr (vr=ar*t_+vr_1->\forall xr (xr=ar*(t_^2/2)+vr_1*t_+xr_1 -> <{{{?xr>xg-GDelta;{ar:=-b;++?vr=0;ar:=0;}++?xr<=xg-GDelta;{?xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta&vr+A*ep<=Vmax;ar:=A;++?!xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta|!vr+A*ep<=Vmax;ar:=0;}}t:=0;}{xr'=vr,vr'=ar,t'=1,T'=-1&t<=ep&vr>=0}}*>(xg-GDelta < xr&vr=0)))))") ;
      QE
      ,
      hideR('R=="<?!xr_1+vr_1^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr_1) < xg+GDelta|!vr_1+A*ep<=Vmax;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep&ar*s_+vr_1>=0)&\forall T (T=-t_+T_1->\forall vr (vr=ar*t_+vr_1->\forall xr (xr=ar*(t_^2/2)+vr_1*t_+xr_1 -> <{{{?xr>xg-GDelta;{ar:=-b;++?vr=0;ar:=0;}++?xr<=xg-GDelta;{?xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta&vr+A*ep<=Vmax;ar:=A;++?!xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta|!vr+A*ep<=Vmax;ar:=0;}}t:=0;}{xr'=vr,vr'=ar,t'=1,T'=-1&t<=ep&vr>=0}}*>(xg-GDelta < xr&vr=0)))))") ;
      assignd(2) ; assignd(2) ; existsR("ep", 2) ; andR(2) ; <(
        QE
        ,
        andR(2) ; <(
          QE
          ,
          (allR(2); implyR(2))*3;
          useAt("<*> merge", "1", 2) ; hideL(-8=="T=-ep+T_1") ;
          print("Outer convergence");
          con("u", "Vmax>0&A>0&b>0&ep>0&0 < vr&vr<=Vmax&(xg-GDelta < xr|xg-GDelta < xr+u*ep*vr)", 2) ; <(
            QE,
            andL('L)* ; edit("xg-GDelta < xr", -8) ; hideL('L=="u<=0") ; useAt("<*> merge", "1", 1) ;
            print("Middle convergence");
            con("v", "Vmax>0&A>0&b>0&ep>0&vr>=0&vr-v*ep*b<=b*ep&xg-GDelta < xr", 1) ; <(
              QE
              ,
              andL('L)* ; edit("vr<=b*ep", -17) ; hideL('L=="v<=0") ; iterated(1) ; orR(1) ; composed(2) ; solve(2.1) ;
              composed(2) ; choiced(2) ; orR(2) ; composed(2) ; testd(2) ; simplify(2) ;
              hideR('R=="<?xr_2<=xg-GDelta;{?xr_2+vr_2^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr_2) < xg+GDelta&vr_2+A*ep<=Vmax;ar:=A;++?!xr_2+vr_2^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr_2) < xg+GDelta|!vr_2+A*ep<=Vmax;ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep&ar*s_+vr_2>=0)&\forall T (T=-t_+T_1->\forall vr (vr=ar*t_+vr_2->\forall xr (xr=ar*(t_^2/2)+vr_2*t_+xr_2 -> <{{{?xr>xg-GDelta;{ar:=-b;++?vr=0;ar:=0;}++?xr<=xg-GDelta;{?xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta&vr+A*ep<=Vmax;ar:=A;++?!xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta|!vr+A*ep<=Vmax;ar:=0;}}t:=0;}{xr'=vr,vr'=ar,t'=1,T'=-1&t<=ep&vr>=0}}*>(xg-GDelta < xr&vr=0)))))") ;
              choiced(2) ; orR(2) ;
              hideR('R=="<?vr_2=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep&ar*s_+vr_2>=0)&\forall T (T=-t_+T_1->\forall vr (vr=ar*t_+vr_2->\forall xr (xr=ar*(t_^2/2)+vr_2*t_+xr_2 -> <{{{?xr>xg-GDelta;{ar:=-b;++?vr=0;ar:=0;}++?xr<=xg-GDelta;{?xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta&vr+A*ep<=Vmax;ar:=A;++?!xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta|!vr+A*ep<=Vmax;ar:=0;}}t:=0;}{xr'=vr,vr'=ar,t'=1,T'=-1&t<=ep&vr>=0}}*>(xg-GDelta < xr&vr=0)))))") ;
              assignd(2) ; assignd(2) ; existsR("vr_2/b", 2) ; andR(2) ; <(
                QE,
                andR(2) ; <(
                  QE,
                  (allR(2); implyR(2))*3;
                  edit("vr=0",-19=="vr=(-b())*(vr_2/b())+vr_2");
                  edit("xr=vr_2^2/(2*b)+xr_2",-20=="xr=(-b())*((vr_2/b())^2/2)+vr_2*(vr_2/b())+xr_2");
                  print("Inner convergence");
                  con("w", "Vmax>0&A>0&b>0&ep>0&vr=0&xg-GDelta < xr", 2) ; <(
                    QE,
                    QE,
                    composed(1) ; solve(1.1) ; composed(1) ; andL('L)* ; choiced(1) ; orR(1) ;
                    hideR('R=="<?xr<=xg-GDelta;{?xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta&vr+A*ep<=Vmax;ar:=A;++?!xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta|!vr+A*ep<=Vmax;ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep&ar*s_+vr>=0)&Vmax>0&A>0&b>0&ep>0&ar*t_+vr=0&xg-GDelta < ar*(t_^2/2)+vr*t_+xr)") ; composed(1) ; testd(1) ; simplify(1) ; choiced(1) ; orR(1) ; hideR(1=="<ar:=-b;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep&ar*s_+vr>=0)&Vmax>0&A>0&b>0&ep>0&ar*t_+vr=0&xg-GDelta < ar*(t_^2/2)+vr*t_+xr)") ;
                    composed(1) ; testd(1) ; simplify(1) ; assignd(1) ; assignd(1) ; fullSimplify ; QE
                  );
                  print("Inner convergence done")
                )
              );
              print("Middle convergence done")
              ,
              andL('L)* ; composed(1) ; solve(1.1) ; composed(1) ; choiced(1) ; orR(1) ;
              hideR(2=="<?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&ar*t_+vr>=0&ar*t_+vr-(v-1)*ep()*b()<=b()*ep()&xg-GDelta() < ar*(t_^2/2)+vr*t_+xr)");
              composed(1) ; testd(1) ; simplify(1) ; choiced(1) ; orR(1) ;
              hideR(2=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&ar*t_+vr>=0&ar*t_+vr-(v-1)*ep()*b()<=b()*ep()&xg-GDelta() < ar*(t_^2/2)+vr*t_+xr)") ;
              assignd(1) ; assignd(1) ; QE
            );
            print("Outer convergence done")
            ,
            andL('L)* ; composed(1) ; solve(1.1) ; composed(1) ; choiced(1) ; orR(1) ; composed(1) ; testd(1) ;
            hideL('L=="ep>0") ; hideL('L=="b>0") ; hideL('L=="A>0") ; orL('L=="xg-GDelta < xr|xg-GDelta < xr+u*ep*vr") ; <(
              hideL('L=="xr_1 < xg-GDelta") ; hideL('L=="vr_1=0") ;
              simplify(1) ;
              hideR('R=="<?xr<=xg-GDelta;{?xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta&vr+A*ep<=Vmax;ar:=A;++?!xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta|!vr+A*ep<=Vmax;ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep&ar*s_+vr>=0)&Vmax>0&A>0&b>0&ep>0&0 < ar*t_+vr&ar*t_+vr<=Vmax&(xg-GDelta < ar*(t_^2/2)+vr*t_+xr|xg-GDelta < ar*(t_^2/2)+vr*t_+xr+(u-1)*ep*(ar*t_+vr)))") ;
              choiced(1) ; orR(1) ;
              hideR('R=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep&ar*s_+vr>=0)&Vmax>0&A>0&b>0&ep>0&0 < ar*t_+vr&ar*t_+vr<=Vmax&(xg-GDelta < ar*(t_^2/2)+vr*t_+xr|xg-GDelta < ar*(t_^2/2)+vr*t_+xr+(u-1)*ep*(ar*t_+vr)))") ;
              assignd(1) ; assignd(1) ;
              existsR("min(ep,vr/b)/2", 1) ; andR(1) ; <(
                QE,
                andR(1) ; <(
                  QE,
                  fullSimplify ; andR(1) ; doall(QE)
                )
              )
              ,
              cut("xr>xg-GDelta&(xr>xg-GDelta-><ar:=-b;++?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep&ar*s_+vr>=0)&Vmax>0&A>0&b>0&ep>0&0 < ar*t_+vr&ar*t_+vr<=Vmax&(xg-GDelta < ar*(t_^2/2)+vr*t_+xr|xg-GDelta < ar*(t_^2/2)+vr*t_+xr+(u-1)*ep*(ar*t_+vr))))") ; <(
                hideR('R=="<?xr<=xg-GDelta;{?xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta&vr+A*ep<=Vmax;ar:=A;++?!xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta|!vr+A*ep<=Vmax;ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep&ar*s_+vr>=0)&Vmax>0&A>0&b>0&ep>0&0 < ar*t_+vr&ar*t_+vr<=Vmax&(xg-GDelta < ar*(t_^2/2)+vr*t_+xr|xg-GDelta < ar*(t_^2/2)+vr*t_+xr+(u-1)*ep*(ar*t_+vr)))") ;
                andL('Llast) ; fullSimplify ; closeT
                ,
                hideR('R=="xr>xg-GDelta&<ar:=-b;++?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep&ar*s_+vr>=0)&Vmax>0&A>0&b>0&ep>0&0 < ar*t_+vr&ar*t_+vr<=Vmax&(xg-GDelta < ar*(t_^2/2)+vr*t_+xr|xg-GDelta < ar*(t_^2/2)+vr*t_+xr+(u-1)*ep*(ar*t_+vr)))") ;
                andR(2) ; <(
                  composed(1) ; testd(1) ; andR(1) ; <(
                    QE,
                    choiced(1) ; orR(1) ; composed(2) ; testd(2) ; andR(2) ; <(
                      composed(3) ; testd(3) ; andR(3) ; <(
                        prop,
                        assignd(3) ; assignd(3) ; existsR("ep", 3) ; fullSimplify ; QE
                      )
                      ,
                      assignd(2) ; assignd(2) ; composed(3) ; testd(3) ; andR(3) ; <(
                        fullSimplify ; orR(3) ; existsR("ep", 2) ; andR(2) ; <(
                          QE,
                          andR(2) ; <(
                            QE,
                            andR(2) ; <(
                              QE,
                              andR(2) ; <(
                                QE,
                                orR(2) ; QE
                              )
                            )
                          )
                        )
                        ,
                        assignd(3) ; assignd(3) ; existsR("ep", 3) ;
                        hideR('R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep&A*s_+vr>=0)&Vmax>0&A>0&b>0&ep>0&0 < A*t_+vr&A*t_+vr<=Vmax&(xg-GDelta < A*(t_^2/2)+vr*t_+xr|xg-GDelta < A*(t_^2/2)+vr*t_+xr+(u-1)*ep*(A*t_+vr)))") ;
                        fullSimplify ; QE
                      )
                    )
                  )
                  ,
                  hideR('R=="<?xr<=xg-GDelta;{?xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta&vr+A*ep<=Vmax;ar:=A;++?!xr+vr^2/(2*b)+(A/b+1)*(A/2*ep^2+ep*vr) < xg+GDelta|!vr+A*ep<=Vmax;ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep&ar*s_+vr>=0)&Vmax>0&A>0&b>0&ep>0&0 < ar*t_+vr&ar*t_+vr<=Vmax&(xg-GDelta < ar*(t_^2/2)+vr*t_+xr|xg-GDelta < ar*(t_^2/2)+vr*t_+xr+(u-1)*ep*(ar*t_+vr)))") ;
                  implyR(1) ; choiced(1) ; orR(1) ;
                  hideR('R=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep&ar*s_+vr>=0)&Vmax>0&A>0&b>0&ep>0&0 < ar*t_+vr&ar*t_+vr<=Vmax&(xg-GDelta < ar*(t_^2/2)+vr*t_+xr|xg-GDelta < ar*(t_^2/2)+vr*t_+xr+(u-1)*ep*(ar*t_+vr)))") ;
                  assignd(1) ; assignd(1) ;
                  existsR("min(ep,vr/b)/2", 1) ; andR(1) ; <(
                    QE,
                    andR(1) ; <(
                      QE,
                      fullSimplify ; andR(1) ; doall(QE)
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
End.

End.

Lemma "IJRR17/Lemma: Cross intersection with deadline - Safety".

/*
 *	Robot must safely cross an intersection.
 *
 *  Robot
 * 	- must cross intersection safely
 *  - can only drive straight and forward
 *  - ensures progress towards intersection
 *
 *  Obstacle
 *  - Drives forward with minimum speed (does not block intersection)
 *
 *  Intersection
 *  - At position 0 (on both the robot's and the obstacle's path)
 *
 *  Liveness property:
 *  - Robot can cross intersection
 *
 *  Safety property:
 *  - Robot always crosses intersection before deadline
 *  - Robot and obstacle are not at the intersection at the same time
 *
 */

Definitions.
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real Vmin;    /* obstacle minimum speed */
  Real ixr = 0; /* position of intersection on path of robot */
  Real ixo = 0; /* position of intersection on path of obstacle */
  Real D;       /* Deadline */

  Real minV = A*ep;

  Real stopDist(Real v) = v^2/(2*b);
  Real accComp(Real v)  = ( (A/b + 1)*(A/2*ep^2 + ep*v) );

  Bool OAfterX(Real xo) <-> xo>ixo;
  Bool RAfterX(Real xr) <-> xr>ixr;

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A > 0                                                                                         /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & Vmin > 0
    & D >= ep
  );

  /* Somewhere before intersection initially */
  Bool initialState(Real xr, Real vr, Real ixr, Real xo, Real vo, Real ixo, Real T) <-> (
    vr = 0
    & vo>=Vmin
    & xr < ixr
    & ixr-xr < A/2*(D-ep)^2
    & T = min(0, (xo-ixo)/Vmin) - ep
    & RAfterX(xr + A/2*(D - ep)^2)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real xr, Real vr, Real ixr, Real xo, Real vo, Real ixo, Real T) <->
    bounds() & initialState(xr, vr, ixr, xo, vo, ixo, T);

  Bool safetyloopinv(Real xr, Real vr, Real ixr, Real xo, Real vo, Real ixo) <-> (
    0 <= vr & Vmin<=vo & (RAfterX(xr) | OAfterX(xo) | xr + stopDist(vr) < ixr |
      (vr>0 & ( xo+vo*(ixr-xr)/vr+A/2*((ixr-xr)/vr)^2 < ixo
              | ixo < xo + Vmin*(ixr-xr)/vr))
    )
  );

  Bool deadlineloopinv(Real xr, Real vr, Real ixr, Real xo, Real vo, Real ixo, Real T) <-> (
    0 <= vr & Vmin<=vo
    & T <= (xo-ixo)/Vmin
    & ( T <= 0 & RAfterX(xr + A/2*(D - ep)^2)
      | T > 0 & RAfterX(xr + vr*(max(0,D-T)) + A/2*(max(0,D-T))^2) )
  );

  HP obstacle ::= { ao := *; ?-b<=ao&ao<=A; };

  HP robot ::= {
    if (OAfterX(xo)) {
      ar := A;
    } else { if (RAfterX(xr)) {
      ar := *; ?-b<=ar&ar<=A;
    } else { if (/*PassFaster*/ vr>0 & ( xo+vo*(ixr-xr)/vr+A/2*((ixr-xr)/vr)^2 < ixo
                                       | ixo < xo + Vmin*(ixr-xr)/(vr+A*ep) ) ) {
      ar := *; ?0<=ar&ar<=A;
    } else { if (/*PassCoast*/ vr>0 & ixo < xo + Vmin*(ixr-xr)/vr) {
      ar := 0;
    } else {         /* 1D Model 3 */
        ar := -b;
     ++ ?vr = 0; ar := 0;
     ++ ?xr + stopDist(vr) + accComp(vr) < ixr; ar := A;
    }}}}
  };

  HP dyn ::= { {xr' = vr, vr' = ar, xo'=vo, vo'=ao, t' = 1, T'=1 & t <= ep & vr >= 0 & vo>=Vmin } };

  HP dwcxd ::= {
    {
      obstacle;
      { robot; t := 0; }
      dyn;
    }*
  };

End.

ProgramVariables
  Real xr;	 /* robot position: x */
  Real vr;	 /* robot translational velocity */
  Real ar;	 /* robot translational acceleration */
  Real xo;	 /* obstacle position */
  Real vo;   /* obstacle velocity */
  Real ao;   /* obstacle acceleration */
  Real t;		 /* control cycle time */
  Real T;    /* remaining time until robot must start driving (i.e., until obstacle has passed the intersection) */
End.

Problem
  assumptions(xr, vr, ixr, xo, vo, ixo, T) -> [ dwcxd; ]( (xr=ixr -> xo!=ixo) & (T>=D -> RAfterX(xr)) )
End.

Tactic "Proof Lemma: Cross intersection with deadline - Safety".
implyR('R=="assumptions(xr,vr,ixr(),xo,vo,ixo(),T)->[dwcxd{|^@|};]((xr=ixr()->xo!=ixo())&(T>=D()->RAfterX(xr)))");
boxAnd('R=="[dwcxd{|^@|};]((xr=ixr()->xo!=ixo())&(T>=D()->RAfterX(xr)))");
andR('R=="[dwcxd{|^@|};](xr=ixr()->xo!=ixo())&[dwcxd{|^@|};](T>=D()->RAfterX(xr))"); <(
  "[dwcxd{|^@|};](xr=ixr()->xo!=ixo())":
    expand "dwcxd";
    loop("safetyloopinv(xr,vr,ixr(),xo,vo,ixo())", 'R=="[{obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};}*](xr=ixr()->xo!=ixo())"); <(
      "Init":
        QE,
      "Post":
        QE,
      "Step":
        expand "safetyloopinv";
        boxAnd('R=="[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};](0<=vr&Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
        andR('R=="[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};]0<=vr&[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))"); <(
          "[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};]0<=vr":
            composeb('R=="[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};]0<=vr");
            composeb('R=="[obstacle{|^@|};]#[{robot{|^@|};t:=0;}dyn{|^@|};]0<=vr#");
            expand "obstacle";
            expand "robot";
            expand "dyn";
            GV('R=="[ao:=*;?-b()<=ao&ao<=A();][{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;][{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}]0<=vr");
            GV('R=="\forall ao #[{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;][{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}]0<=vr#");
            dW('R=="\forall ao \forall ar \forall t #[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}]0<=vr#");
            simplify('R=="\forall ao \forall ar \forall t \forall t \forall vo \forall vr (t<=ep()&vr>=0&vo>=Vmin()->0<=vr)");
            closeT,
          "[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))":
            expand "robot";
            notAnd('R=="[obstacle{|^@|};{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?#!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())))#;{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
            notGreater('R=="[obstacle{|^@|};{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?#!vr>0#|!(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
            notOr('R=="[obstacle{|^@|};{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?vr<=0|#!(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()))#;{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
            notLess('R=="[obstacle{|^@|};{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?vr<=0|#!xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()#&!ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep());{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
            notLess('R=="[obstacle{|^@|};{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?vr<=0|xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2>=ixo()&#!ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())#;{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
            notAnd('R=="[obstacle{|^@|};{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?vr<=0|xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2>=ixo()&ixo()>=xo+Vmin()*(ixr()-xr)/(vr+A()*ep());{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?#!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr)#;{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
            notGreater('R=="[obstacle{|^@|};{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?vr<=0|xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2>=ixo()&ixo()>=xo+Vmin()*(ixr()-xr)/(vr+A()*ep());{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?#!vr>0#|!ixo() < xo+Vmin()*(ixr()-xr)/vr;{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
            notLess('R=="[obstacle{|^@|};{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?vr<=0|xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2>=ixo()&ixo()>=xo+Vmin()*(ixr()-xr)/(vr+A()*ep());{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?vr<=0|#!ixo() < xo+Vmin()*(ixr()-xr)/vr#;{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
            expand "obstacle";
            unfold; <(
              "[?OAfterX(xo);ar:=A();][t:=0;][dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))":
                expand "dyn";
                dC("xo>=old(xo)", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))"); <(
                  "Use":
                    dW('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&xo>=xo_0}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
                    QE,
                  "Show":
                    dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}]xo>=xo_0") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: t=0 :: -b()<=ao :: ao<=A() :: Vmin()<=vo :: xo_0=xo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}]xo>=xo_0 :: nil"
                ),
              "[?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();][t:=0;][dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))":
                expand "dyn";
                dC("xr>=old(xr)", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))"); <(
                  "Use":
                    dW('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&xr>=xr_0}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
                    QE,
                  "Show":
                    dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}]xr>=xr_0") using "0<=vr :: -b()<=ar :: ar<=A() :: xr_0=xr :: nil"
                ),
              "[?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();][t:=0;][dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))":
                expand "dyn";
                dC("t>=0&vr=old(vr)+ar*t&vo=old(vo)+ao*t", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))"); <(
                  "Use":
                    dC("xr=old(xr)+old(vr)*t+ar*t^2/2&xo=old(xo)+old(vo)*t+ao*t^2/2", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0+ar*t&vo=vo_0+ao*t}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))"); <(
                      "Use":
                        dW('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&((t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0+ar*t&vo=vo_0+ao*t)&xr=xr_0+vr_0*t+ar*t^2/2&xo=xo_0+vo_0*t+ao*t^2/2}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
                        andL('L)*;
                        simplify('R=="Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr))") using "vo>=Vmin()";
                        orR('R)*;
                        andR('R=="vr>0&(xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < 0|0 < xo+Vmin()*(-xr)/vr)"); <(
                          "vr>0":
                            QE using "t>=0 :: vr=vr_0+ar*t :: vr_0>0 :: 0<=ar :: vr>0 :: nil",
                          "xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < 0|0 < xo+Vmin()*(-xr)/vr":
                            orR('R=="xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < 0|0 < xo+Vmin()*(-xr)/vr");
                            simplify('L=="RAfterX(xr_0)|OAfterX(xo_0)|xr_0+stopDist(vr_0) < 0|vr_0>0&(xo_0+vo_0*(0-xr_0)/vr_0+A()/2*((0-xr_0)/vr_0)^2 < 0|0 < xo_0+Vmin()*(0-xr_0)/vr_0)") using "!OAfterX(xo_0) :: !RAfterX(xr_0) :: nil";
                            orL('L=="xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2 < ixo()|ixo() < xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep())"); <(
                              "xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2 < ixo()":
                                QE using "A()>0 :: xr=xr_0+vr_0*t+ar*t^2/2 :: xo=xo_0+vo_0*t+ao*t^2/2 :: b()>0 :: t<=ep() :: t>=0 :: ep()>0 :: vr>=0 :: vo>=Vmin() :: vr=vr_0+ar*t :: vo=vo_0+ao*t :: Vmin()>0 :: D()>=ep() :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: vr_0>0 :: xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2 < ixo() :: 0<=ar :: ar<=A() :: Vmin()<=vo_0 :: !OAfterX(xo_0) :: !RAfterX(xr_0) :: RAfterX(xr) :: xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < 0 :: nil",
                              "ixo() < xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep())":
                                QE using "A()>0 :: xr=xr_0+vr_0*t+ar*t^2/2 :: xo=xo_0+vo_0*t+ao*t^2/2 :: b()>0 :: t<=ep() :: t>=0 :: ep()>0 :: vr>=0 :: vo>=Vmin() :: vr=vr_0+ar*t :: vo=vo_0+ao*t :: Vmin()>0 :: D()>=ep() :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: vr_0>0 :: ixo() < xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep()) :: 0<=ar :: ar<=A() :: Vmin()<=vo_0 :: RAfterX(xr) :: 0 < xo+Vmin()*(-xr)/vr :: nil"
                            )
                        ),
                      "Show":
                        dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0+ar*t&vo=vo_0+ao*t}](xr=xr_0+vr_0*t+ar*t^2/2&xo=xo_0+vo_0*t+ao*t^2/2)") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: D()>=ep() :: t=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: vr_0>0 :: 0<=ar :: ar<=A() :: Vmin()<=vo_0 :: vr_0=vr :: vo_0=vo :: xr_0=xr :: xo_0=xo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0+ar*t&vo=vo_0+ao*t}](xr=xr_0+vr_0*t+ar*t^2/2&xo=xo_0+vo_0*t+ao*t^2/2) :: nil"
                    ),
                  "Show":
                    dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&vr=vr_0+ar*t&vo=vo_0+ao*t)") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: D()>=ep() :: t=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: vr_0>0 :: 0<=ar :: ar<=A() :: Vmin()<=vo_0 :: vr_0=vr :: vo_0=vo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&vr=vr_0+ar*t&vo=vo_0+ao*t) :: nil"
                ),
              "[?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;][t:=0;][dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))":
                expand "dyn";
                dC("t>=0&vr=old(vr)&vo=old(vo)+ao*t", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))"); <(
                  "Use":
                    dC("xr=old(xr)+old(vr)*t&xo=old(xo)+old(vo)*t+ao*t^2/2", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0&vo=vo_0+ao*t}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))"); <(
                      "Use":
                        dW('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&((t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0&vo=vo_0+ao*t)&xr=xr_0+vr_0*t&xo=xo_0+vo_0*t+ao*t^2/2}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
                        andL('L)*;
                        simplify('R=="Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr))") using "vo>=Vmin()";
                        orR('R)*;
                        allR2L('L=="vr=vr_0");
                        simplify('R=="vr>0&(xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < 0|0 < xo+Vmin()*(-xr)/vr)") using "vr>0";
                        orR('R=="xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < 0|0 < xo+Vmin()*(-xr)/vr");
                        orL('L=="vr<=0|xo_0+vo_0*(ixr()-xr_0)/vr+A()/2*((ixr()-xr_0)/vr)^2>=ixo()&ixo()>=xo_0+Vmin()*(ixr()-xr_0)/(vr+A()*ep())"); <(
                          "vr<=0":
                            QE using "vr<=0 :: vr>0 :: nil",
                          "xo_0+vo_0*(ixr()-xr_0)/vr+A()/2*((ixr()-xr_0)/vr)^2>=ixo()&ixo()>=xo_0+Vmin()*(ixr()-xr_0)/(vr+A()*ep())":
                            QE using "A()>0 :: xr=xr_0+vr*t :: xo=xo_0+vo_0*t+ao*t^2/2 :: b()>0 :: t<=ep() :: t>=0 :: ep()>0 :: vr>=0 :: vo>=Vmin() :: vr=vr_0 :: vo=vo_0+ao*t :: Vmin()>0 :: D()>=ep() :: xo_0+vo_0*(ixr()-xr_0)/vr+A()/2*((ixr()-xr_0)/vr)^2>=ixo()&ixo()>=xo_0+Vmin()*(ixr()-xr_0)/(vr+A()*ep()) :: ar=0 :: 0<=vr :: -b()<=ao :: ao<=A() :: vr>0 :: ixo() < xo_0+Vmin()*(ixr()-xr_0)/vr :: Vmin()<=vo_0 :: xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < 0 :: 0 < xo+Vmin()*(-xr)/vr :: nil"
                        ),
                      "Show":
                        dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0&vo=vo_0+ao*t}](xr=xr_0+vr_0*t&xo=xo_0+vo_0*t+ao*t^2/2)") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: ar=0 :: t=0 :: -b()<=ao :: ao<=A() :: vr_0>0 :: vr_0=vr :: vo_0=vo :: xr_0=xr :: xo_0=xo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0&vo=vo_0+ao*t}](xr=xr_0+vr_0*t&xo=xo_0+vo_0*t+ao*t^2/2) :: nil"
                    ),
                  "Show":
                    dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&vr=vr_0&vo=vo_0+ao*t)") using "b()>0 :: ar=0 :: t=0 :: -b()<=ao :: ao<=A() :: vr_0>0 :: vr_0=vr :: vo_0=vo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&vr=vr_0&vo=vo_0+ao*t) :: nil"
                ),
              "[ar:=-b();][t:=0;][dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))":
                expand "dyn";
                dC("t>=0&vr=old(vr)-b()*t", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))"); <(
                  "Use":
                    dC("xr=old(xr)+old(vr)*t-b()*t^2/2", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0-b()*t}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))"); <(
                      "Use":
                        dWplus('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&((t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0-b()*t)&xr=xr_0+vr_0*t-b()*t^2/2}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
                        andL('L)*;
                        simplify('R=="Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr))") using "vo>=Vmin()";
                        orR('R)*;
                        useAt("!! double negation", "1", 'R=="RAfterX(xr_0)");
                        notR('R=="!!RAfterX(xr_0)");
                        useAt("!! double negation", "1", 'R=="OAfterX(xo_0)");
                        notR('R=="!!OAfterX(xo_0)");
                        simplify('L=="RAfterX(xr_0)|OAfterX(xo_0)|xr_0+stopDist(vr_0) < 0|vr_0>0&(xo_0+vo_0*(0-xr_0)/vr_0+A()/2*((0-xr_0)/vr_0)^2 < 0|0 < xo_0+Vmin()*(0-xr_0)/vr_0)") using "!RAfterX(xr_0) :: !OAfterX(xo_0) :: nil";
                        orL('L=="xr_0+stopDist(vr_0) < 0|vr_0>0&(xo_0+vo_0*(-xr_0)/vr_0+A()/2*((-xr_0)/vr_0)^2 < 0|0 < xo_0+Vmin()*(-xr_0)/vr_0)"); <(
                          "xr_0+stopDist(vr_0) < 0":
                            QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: D()>=ep() :: vr_0<=0|ixo()>=xo_0+Vmin()*(ixr()-xr_0)/vr_0 :: ar=-b() :: t_0=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: Vmin()<=vo_0 :: xr_0+stopDist(vr_0) < 0 :: xr=xr_0+vr_0*t-b()*t^2/2 :: t<=ep() :: t>=0 :: vr=vr_0-b()*t :: vr>=0 :: vo>=Vmin() :: xr+stopDist(vr) < 0 :: nil",
                          "vr_0>0&(xo_0+vo_0*(-xr_0)/vr_0+A()/2*((-xr_0)/vr_0)^2 < 0|0 < xo_0+Vmin()*(-xr_0)/vr_0)":
                            andL('L=="vr_0>0&(xo_0+vo_0*(-xr_0)/vr_0+A()/2*((-xr_0)/vr_0)^2 < 0|0 < xo_0+Vmin()*(-xr_0)/vr_0)");
                            orL('L=="vr_0<=0|xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2>=ixo()&ixo()>=xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep())"); <(
                              "vr_0<=0":
                                QE using "vr_0<=0 :: vr_0>0 :: nil",
                              "xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2>=ixo()&ixo()>=xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep())":
                                andL('L=="xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2>=ixo()&ixo()>=xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep())");
                                QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: vr_0<=0|ixo()>=xo_0+Vmin()*(ixr()-xr_0)/vr_0 :: ar=-b() :: t_0=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: Vmin()<=vo_0 :: xr=xr_0+vr_0*t-b()*t^2/2 :: t<=ep() :: t>=0 :: vr=vr_0-b()*t :: vr>=0 :: vo>=Vmin() :: vr_0>0 :: xo_0+vo_0*(-xr_0)/vr_0+A()/2*((-xr_0)/vr_0)^2 < 0|0 < xo_0+Vmin()*(-xr_0)/vr_0 :: xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2>=ixo() :: ixo()>=xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep()) :: nil"
                            )
                        ),
                      "Show":
                        dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0-b()*t}]xr=xr_0+vr_0*t-b()*t^2/2") using "b()>0 :: ep()>0 :: Vmin()>0 :: ar=-b() :: t=0 :: 0<=vr_0 :: vr_0=vr :: xr_0=xr :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0-b()*t}]xr=xr_0+vr_0*t-b()*t^2/2 :: nil"
                    ),
                  "Show":
                    dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&vr=vr_0-b()*t)") using "b()>0 :: Vmin()>0 :: ar=-b() :: t=0 :: 0<=vr_0 :: vr_0=vr :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&vr=vr_0-b()*t) :: nil"
                ),
              "[?vr=0;ar:=0;][t:=0;][dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))":
                expand "dyn";
                dC("vr=0", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))"); <(
                  "Use":
                    dC("xr=old(xr)", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&vr=0}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))"); <(
                      "Use":
                        dWplus('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&((t<=ep()&vr>=0&vo>=Vmin())&vr=0)&xr=xr_0}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
                        andL('L)*;
                        simplify('R=="Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr))") using "vo>=Vmin()";
                        orR('R)*;
                        QE using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: D()>=ep() :: vr_0<=0|ixo()>=xo_0+Vmin()*(ixr()-xr_0)/vr_0 :: vr_0=0 :: ar=0 :: t_0=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: Vmin()<=vo_0 :: RAfterX(xr_0)|OAfterX(xo_0)|xr_0+stopDist(vr_0) < 0|vr_0>0&(xo_0+vo_0*(0-xr_0)/vr_0+A()/2*((0-xr_0)/vr_0)^2 < 0|0 < xo_0+Vmin()*(0-xr_0)/vr_0) :: xr=xr_0 :: vr=0 :: t<=ep() :: vr>=0 :: vo>=Vmin() :: RAfterX(xr_0) :: OAfterX(xo_0) :: RAfterX(xr) :: OAfterX(xo) :: xr+stopDist(vr) < 0 :: nil",
                      "Show":
                        dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&vr=0}]xr=xr_0") using "xr_0=xr :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&vr=0}]xr=xr_0 :: nil"
                    ),
                  "Show":
                    dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}]vr=0") using "vr=0 :: ar=0 :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}]vr=0 :: nil"
                ),
              "[?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();][t:=0;][dyn{|^@|};](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))":
                expand "dyn";
                dC("t>=0&vr=old(vr)+A()*t", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))"); <(
                  "Use":
                    dC("xr=old(xr)+old(vr)*t+A()*t^2/2", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0+A()*t}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))"); <(
                      "Use":
                        dW('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&((t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0+A()*t)&xr=xr_0+vr_0*t+A()*t^2/2}](Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))");
                        andL('L)*;
                        simplify('R=="Vmin()<=vo&(RAfterX(xr)|OAfterX(xo)|xr+stopDist(vr) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr))") using "vo>=Vmin()";
                        orR('R)*;
                        QE using "xr=xr_0+vr_0*t+A()*t^2/2 :: A()>0 :: b()>0 :: t<=ep() :: t>=0 :: vr=vr_0+A()*t :: ep()>0 :: vr>=0 :: vo>=Vmin() :: Vmin()>0 :: D()>=ep() :: xr_0+stopDist(vr_0)+accComp(vr_0) < ixr() :: ar=A() :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: !RAfterX(xr_0) :: RAfterX(xr) :: OAfterX(xo) :: xr+stopDist(vr) < 0 :: nil",
                      "Show":
                        dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0+A()*t}]xr=xr_0+vr_0*t+A()*t^2/2") using "ar=A() :: t=0 :: xr_0=xr :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&vr=vr_0+A()*t}]xr=xr_0+vr_0*t+A()*t^2/2 :: nil"
                    ),
                  "Show":
                    dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&vr=vr_0+A()*t)") using "ar=A() :: t=0 :: vr_0=vr :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&vr=vr_0+A()*t) :: nil"
                )
            )
        )
    ),
  "[dwcxd{|^@|};](T>=D()->RAfterX(xr))":
    expand "dwcxd";
    loop("0<=vr&Vmin()<=vo&T<=(xo-0)/Vmin()&(T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)", 'R=="[{obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};}*](T>=D()->RAfterX(xr))"); <(
      "Init":
        QE,
      "Post":
        QE,
      "Step":
        boxAnd('R=="[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};](0<=vr&Vmin()<=vo&T<=(xo-0)/Vmin()&(T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0))");
        andR('R=="[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};]0<=vr&[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};](Vmin()<=vo&T<=(xo-0)/Vmin()&(T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0))"); <(
          "[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};]0<=vr":
            composeb('R=="[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};]0<=vr");
            composeb('R=="[obstacle{|^@|};]#[{robot{|^@|};t:=0;}dyn{|^@|};]0<=vr#");
            expand "dyn";
            dW('R=="[obstacle{|^@|};][robot{|^@|};t:=0;]#[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}]0<=vr#");
            simplify('R=="[obstacle{|^@|};][robot{|^@|};t:=0;]#\forall t \forall vo \forall vr (t<=ep()&vr>=0&vo>=Vmin()->0<=vr)#");
            boxTrue('R=="[obstacle{|^@|};]#[robot{|^@|};t:=0;]true#");
            boxTrue('R=="[obstacle{|^@|};]true"),
          "[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};](Vmin()<=vo&T<=(xo-0)/Vmin()&(T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0))":
            boxAnd('R=="[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};](Vmin()<=vo&T<=(xo-0)/Vmin()&(T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0))");
            andR('R=="[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};]Vmin()<=vo&[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};](T<=(xo-0)/Vmin()&(T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0))"); <(
              "[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};]Vmin()<=vo":
                composeb('R=="[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};]Vmin()<=vo");
                composeb('R=="[obstacle{|^@|};]#[{robot{|^@|};t:=0;}dyn{|^@|};]Vmin()<=vo#");
                expand "dyn";
                dW('R=="[obstacle{|^@|};][robot{|^@|};t:=0;]#[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}]Vmin()<=vo#");
                simplify('R=="[obstacle{|^@|};][robot{|^@|};t:=0;]#\forall t \forall vo \forall vr (t<=ep()&vr>=0&vo>=Vmin()->Vmin()<=vo)#");
                boxTrue('R=="[obstacle{|^@|};]#[robot{|^@|};t:=0;]true#");
                boxTrue('R=="[obstacle{|^@|};]true"),
              "[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};](T<=(xo-0)/Vmin()&(T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0))":
                boxAnd('R=="[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};](T<=(xo-0)/Vmin()&(T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0))");
                andR('R=="[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};]T<=(xo-0)/Vmin()&[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                  "[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};]T<=(xo-0)/Vmin()":
                    composeb('R=="[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};]T<=(xo-0)/Vmin()");
                    composeb('R=="[obstacle{|^@|};]#[{robot{|^@|};t:=0;}dyn{|^@|};]T<=(xo-0)/Vmin()#");
                    composeb('R=="[obstacle{|^@|};]#[robot{|^@|};t:=0;][dyn{|^@|};]T<=(xo-0)/Vmin()#");
                    expand "robot";
                    GV('R=="[obstacle{|^@|};]#[?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}][t:=0;][dyn{|^@|};]T<=(xo-0)/Vmin()#");
                    expand "obstacle";
                    unfold;
                    expand "dyn";
                    dC("t>=0&T=old(T)+t&vo=old(vo)+ao*t", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}]T<=(xo-0)/Vmin()"); <(
                      "Use":
                        dC("xo=old(xo)+old(vo)*t+ao*t^2/2", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vo=vo_0+ao*t}]T<=(xo-0)/Vmin()"); <(
                          "Use":
                            dW('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&((t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vo=vo_0+ao*t)&xo=xo_0+vo_0*t+ao*t^2/2}]T<=(xo-0)/Vmin()");
                            QE,
                          "Show":
                            dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vo=vo_0+ao*t}]xo=xo_0+vo_0*t+ao*t^2/2") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: t=0 :: -b()<=ao :: ao<=A() :: Vmin()<=vo_0 :: T_0=T :: vo_0=vo :: xo_0=xo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vo=vo_0+ao*t}]xo=xo_0+vo_0*t+ao*t^2/2 :: nil"
                        ),
                      "Show":
                        dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&T=T_0+t&vo=vo_0+ao*t)") using "A()>0 :: b()>0 :: ep()>0 :: Vmin()>0 :: t=0 :: Vmin()<=vo_0 :: T_0=T :: vo_0=vo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&T=T_0+t&vo=vo_0+ao*t) :: nil"
                    ),
                  "[obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)":
                    expand "obstacle";
                    expand "robot";
                    unfold; <(
                      "[?OAfterX(xo);ar:=A();][t:=0;][dyn{|^@|};](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)":
                        expand "dyn";
                        dC("t>=0&T=old(T)+t&vr=old(vr)+A()*t", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                          "Use":
                            dC("xr=old(xr)+old(vr)*t+A()*t^2/2", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0+A()*t}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                              "Use":
                                dW('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&((t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0+A()*t)&xr=xr_0+vr_0*t+A()*t^2/2}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)");
                                QE,
                              "Show":
                                dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0+A()*t}]xr=xr_0+vr_0*t+A()*t^2/2") using "A()>0 :: ep()>0 :: ar=A() :: t=0 :: 0<=vr_0 :: T_0=T :: vr_0=vr :: xr_0=xr :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0+A()*t}]xr=xr_0+vr_0*t+A()*t^2/2 :: nil"
                            ),
                          "Show":
                            dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&T=T_0+t&vr=vr_0+A()*t)") using "A()>0 :: ep()>0 :: ar=A() :: t=0 :: 0<=vr_0 :: T_0=T :: vr_0=vr :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&T=T_0+t&vr=vr_0+A()*t) :: nil"
                        ),
                      "[?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();][t:=0;][dyn{|^@|};](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)":
                        expand "dyn";
                        dC("t>=0&T=old(T)+t&vr=old(vr)+ar*t&vo=old(vo)+ao*t", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                          "Use":
                            dC("xr=old(xr)+old(vr)*t+ar*t^2/2&xo=old(xo)+old(vo)*t+ao*t^2/2", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0+ar*t&vo=vo_0+ao*t}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                              "Use":
                                dW('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&((t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0+ar*t&vo=vo_0+ao*t)&xr=xr_0+vr_0*t+ar*t^2/2&xo=xo_0+vo_0*t+ao*t^2/2}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)");
                                andL('L)*;
                                orR('R=="T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0");
                                orL('L=="T_0<=0&xr_0+A()/2*(D()-ep())^2>0|T_0>0&xr_0+vr_0*max(0,D()-T_0)+A()/2*max(0,D()-T_0)^2>0"); <(
                                  "T_0<=0&xr_0+A()/2*(D()-ep())^2>0":
                                    andR('R=="T<=0&xr+A()/2*(D()-ep())^2>0"); <(
                                      "T<=0":
                                        andR('R=="T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0"); <(
                                          "T>0":
                                            QE using "T<=0 :: T>0 :: nil",
                                          "xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0":
                                            edit("xr+vr*max(0,D()-T)+A()/2*expand(max(0,D()-T))^2>0", 'R=="xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0");
                                            orL('L=="0>=D()-T&max_=0|0 < D()-T&max_=D()-T"); <(
                                              "0>=D()-T&max_=0":
                                                QE,
                                              "0 < D()-T&max_=D()-T":
                                                QE
                                            )
                                        ),
                                      "xr+A()/2*(D()-ep())^2>0":
                                        andR('R=="T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0"); <(
                                          "T>0":
                                            QE,
                                          "xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0":
                                            edit("xr+vr*expand(max(0,D()-T))+A()/2*max(0,D()-T)^2>0", 'R=="xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0");
                                            orL('L=="0>=D()-T&max_=0|0 < D()-T&max_=D()-T"); <(
                                              "0>=D()-T&max_=0":
                                                QE,
                                              "0 < D()-T&max_=D()-T":
                                                QE
                                            )
                                        )
                                    ),
                                  "T_0>0&xr_0+vr_0*max(0,D()-T_0)+A()/2*max(0,D()-T_0)^2>0":
                                    andR('R=="T<=0&xr+A()/2*(D()-ep())^2>0"); <(
                                      "T<=0":
                                        andR('R=="T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0"); <(
                                          "T>0":
                                            QE using "T<=0 :: T>0 :: nil",
                                          "xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0":
                                            edit("xr+vr*expand(max(0,D()-T))+A()/2*max(0,D()-T)^2>0", 'R=="xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0");
                                            orL('L=="0>=D()-T&max_=0|0 < D()-T&max_=D()-T"); <(
                                              "0>=D()-T&max_=0":
                                                QE,
                                              "0 < D()-T&max_=D()-T":
                                                QE
                                            )
                                        ),
                                      "xr+A()/2*(D()-ep())^2>0":
                                        andR('R=="T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0"); <(
                                          "T>0":
                                            QE,
                                          "xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0":
                                            edit("xr+vr*expand(max(0,D()-T))+A()/2*max(0,D()-T)^2>0", 'R=="xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0");
                                            orL('L=="0>=D()-T&max_=0|0 < D()-T&max_=D()-T"); <(
                                              "0>=D()-T&max_=0":
                                                QE,
                                              "0 < D()-T&max_=D()-T":
                                                QE
                                            )
                                        )
                                    )
                                ),
                              "Show":
                                dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0+ar*t&vo=vo_0+ao*t}](xr=xr_0+vr_0*t+ar*t^2/2&xo=xo_0+vo_0*t+ao*t^2/2)") using "A()>0 :: b()>0 :: t=0 :: -b()<=ao :: ao<=A() :: T_0=T :: vr_0=vr :: vo_0=vo :: xr_0=xr :: xo_0=xo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0+ar*t&vo=vo_0+ao*t}](xr=xr_0+vr_0*t+ar*t^2/2&xo=xo_0+vo_0*t+ao*t^2/2) :: nil"
                            ),
                          "Show":
                            dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&T=T_0+t&vr=vr_0+ar*t&vo=vo_0+ao*t)") using "A()>0 :: b()>0 :: t=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: -b()<=ar :: ar<=A() :: T_0=T :: vr_0=vr :: vo_0=vo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&T=T_0+t&vr=vr_0+ar*t&vo=vo_0+ao*t) :: nil"
                        ),
                      "[?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();][t:=0;][dyn{|^@|};](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)":
                        expand "dyn";
                        dC("t>=0&T=old(T)+t&vr>=old(vr)&vo=old(vo)+ao*t", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                          "Use":
                            dC("xr>=old(xr)+old(vr)*t&xo=old(xo)+old(vo)*t+ao*t^2/2", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr>=vr_0&vo=vo_0+ao*t}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                              "Use":
                                dW('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&((t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr>=vr_0&vo=vo_0+ao*t)&xr>=xr_0+vr_0*t&xo=xo_0+vo_0*t+ao*t^2/2}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)");
                                orR('R=="T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0");
                                andL('L)*;
                                hideL('L=="xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2 < ixo()|ixo() < xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep())");
                                edit("T>0&xr+vr*expand(max(0,D()-T))+A()/2*max(0,D()-T)^2>0", 'R=="T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0");
                                prop ; doall(QE),
                              "Show":
                                dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr>=vr_0&vo=vo_0+ao*t}](xr>=xr_0+vr_0*t&xo=xo_0+vo_0*t+ao*t^2/2)") using "A()>0 :: b()>0 :: Vmin()>0 :: t=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: 0<=ar :: ar<=A() :: T_0=T :: vr_0=vr :: vo_0=vo :: xr_0=xr :: xo_0=xo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr>=vr_0&vo=vo_0+ao*t}](xr>=xr_0+vr_0*t&xo=xo_0+vo_0*t+ao*t^2/2) :: nil"
                            ),
                          "Show":
                            dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&T=T_0+t&vr>=vr_0&vo=vo_0+ao*t)") using "A()>0 :: b()>0 :: Vmin()>0 :: t=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: 0<=ar :: ar<=A() :: T_0=T :: vr_0=vr :: vo_0=vo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&T=T_0+t&vr>=vr_0&vo=vo_0+ao*t) :: nil"
                        ),
                      "[?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;][t:=0;][dyn{|^@|};](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)":
                        expand "dyn";
                        dC("t>=0&T=old(T)+t&vr=old(vr)&vo=old(vo)+ao*t", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                          "Use":
                            dC("xr=old(xr)+old(vr)*t&xo=old(xo)+old(vo)*t+ao*t^2/2", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0&vo=vo_0+ao*t}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                              "Use":
                                dW('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&((t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0&vo=vo_0+ao*t)&xr=xr_0+vr_0*t&xo=xo_0+vo_0*t+ao*t^2/2}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)");
                                orR('R=="T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0");
                                andL('L)*;
                                edit("T>0&xr+vr*expand(max(0,D()-T))+A()/2*max(0,D()-T)^2>0", 'R=="T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0");
                                simplify('L=="!(vr_0>0&(xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2 < ixo()|ixo() < xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep())))") using "vr_0>0";
                                notOr('L=="!(xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2 < ixo()|ixo() < xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep()))");
                                notLess('L=="#!xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2 < ixo()#&!ixo() < xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep())");
                                notLess('L=="xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2>=ixo()&#!ixo() < xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep())#");
                                andR('R=="T<=0&xr+A()/2*(D()-ep())^2>0"); <(
                                  "T<=0":
                                    andR('R=="T>0&xr+vr*max_+A()/2*max_^2>0"); <(
                                      "T>0":
                                        QE using "T<=0 :: T>0 :: nil",
                                      "xr+vr*max_+A()/2*max_^2>0":
                                        prop ; doall(print("QE...") ; QE ; print("...done"))
                                    ),
                                  "xr+A()/2*(D()-ep())^2>0":
                                    andR('R=="T>0&xr+vr*max_+A()/2*max_^2>0"); <(
                                      "T>0":
                                        prop ; doall(print("QE...") ; QE ; print("...done")),
                                      "xr+vr*max_+A()/2*max_^2>0":
                                        edit("T_0<=0&xr_0+A()/2*(D()-ep())^2>0|T_0>0&xr_0+vr_0*max(0,D()-T_0)+A()/2*expand(max(0,D()-T_0))^2>0", 'L=="T_0<=0&xr_0+A()/2*(D()-ep())^2>0|T_0>0&xr_0+vr_0*max(0,D()-T_0)+A()/2*max(0,D()-T_0)^2>0");
                                        prop ; doall(print("QE...") ; QE ; print("...done"))
                                    )
                                ),
                              "Show":
                                dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0&vo=vo_0+ao*t}](xr=xr_0+vr_0*t&xo=xo_0+vo_0*t+ao*t^2/2)") using "Vmin()>0 :: ar=0 :: t=0 :: -b()<=ao :: ao<=A() :: vr_0>0 :: Vmin()<=vo_0 :: T_0=T :: vr_0=vr :: vo_0=vo :: xr_0=xr :: xo_0=xo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0&vo=vo_0+ao*t}](xr=xr_0+vr_0*t&xo=xo_0+vo_0*t+ao*t^2/2) :: nil"
                            ),
                          "Show":
                            dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&T=T_0+t&vr=vr_0&vo=vo_0+ao*t)") using "A()>0 :: b()>0 :: Vmin()>0 :: ar=0 :: t=0 :: -b()<=ao :: ao<=A() :: vr_0>0 :: Vmin()<=vo_0 :: T_0=T :: vr_0=vr :: vo_0=vo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&T=T_0+t&vr=vr_0&vo=vo_0+ao*t) :: nil"
                        ),
                      "[ar:=-b();][t:=0;][dyn{|^@|};](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)":
                        expand "dyn";
                        dC("t>=0&T=old(T)+t&vr=old(vr)-b()*t&vo=old(vo)+ao*t", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                          "Use":
                            dC("xr=old(xr)+old(vr)*t-b()*t^2/2&xo=old(xo)+old(vo)*t+ao*t^2/2", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0-b()*t&vo=vo_0+ao*t}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                              "Use":
                                dW('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&((t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0-b()*t&vo=vo_0+ao*t)&xr=xr_0+vr_0*t-b()*t^2/2&xo=xo_0+vo_0*t+ao*t^2/2}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)");
                                orR('R=="T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0");
                                andL('L)*;
                                edit("T>0&xr+vr*max(0,D()-T)+A()/2*expand(max(0,D()-T))^2>0", 'R=="T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0");
                                edit("T_0<=0&xr_0+A()/2*(D()-ep())^2>0|T_0>0&xr_0+vr_0*max(0,D()-T_0)+A()/2*expand(max(0,D()-T_0))^2>0", 'L=="T_0<=0&xr_0+A()/2*(D()-ep())^2>0|T_0>0&xr_0+vr_0*max(0,D()-T_0)+A()/2*max(0,D()-T_0)^2>0");
                                edit("vr_0>0|vr_0=0", 'L=="0<=vr_0");
                                orL('L=="vr_0>0|vr_0=0"); <(
                                  "vr_0>0":
                                    simplify('L=="!(vr_0>0&(xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2 < ixo()|ixo() < xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep())))") using "vr_0>0";
                                    simplify('L=="!(vr_0>0&ixo() < xo_0+Vmin()*(ixr()-xr_0)/vr_0)") using "vr_0>0";
                                    notOr('L=="!(xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2 < ixo()|ixo() < xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep()))");
                                    notLess('L=="#!xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2 < ixo()#&!ixo() < xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep())");
                                    notLess('L=="xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2>=ixo()&#!ixo() < xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep())#");
                                    andR('R=="T<=0&xr+A()/2*(D()-ep())^2>0"); <(
                                      "T<=0":
                                        andR('R=="T>0&xr+vr*max_+A()/2*max_^2>0"); <(
                                          "T>0":
                                            QE using "T<=0 :: T>0 :: nil",
                                          "xr+vr*max_+A()/2*max_^2>0":
                                            prop ; doall(print("QE...") ; QE ; print("...done"))
                                        ),
                                      "xr+A()/2*(D()-ep())^2>0":
                                        andR('R=="T>0&xr+vr*max_+A()/2*max_^2>0"); <(
                                          "T>0":
                                            prop ; doall(print("QE...") ; QE ; print("...done")),
                                          "xr+vr*max_+A()/2*max_^2>0":
                                            hideL('L=="xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2>=ixo()&ixo()>=xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep())");
                                            prop ; doall(print("QE...") ; QE ; print("...done"))
                                        )
                                    ),
                                  "vr_0=0":
                                    simplify('L=="!(vr_0>0&(xo_0+vo_0*(ixr()-xr_0)/vr_0+A()/2*((ixr()-xr_0)/vr_0)^2 < ixo()|ixo() < xo_0+Vmin()*(ixr()-xr_0)/(vr_0+A()*ep())))") using "vr_0=0";
                                    simplify('L=="!(vr_0>0&ixo() < xo_0+Vmin()*(ixr()-xr_0)/vr_0)") using "vr_0=0";
                                    prop ; doall(print("QE...") ; QE ; print("...done"))
                                ),
                              "Show":
                                dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0-b()*t&vo=vo_0+ao*t}](xr=xr_0+vr_0*t-b()*t^2/2&xo=xo_0+vo_0*t+ao*t^2/2)") using "A()>0 :: b()>0 :: Vmin()>0 :: ar=-b() :: t=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: Vmin()<=vo_0 :: T_0=T :: vr_0=vr :: vo_0=vo :: xr_0=xr :: xo_0=xo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0-b()*t&vo=vo_0+ao*t}](xr=xr_0+vr_0*t-b()*t^2/2&xo=xo_0+vo_0*t+ao*t^2/2) :: nil"
                            ),
                          "Show":
                            dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&T=T_0+t&vr=vr_0-b()*t&vo=vo_0+ao*t)") using "A()>0 :: b()>0 :: Vmin()>0 :: ar=-b() :: t=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: Vmin()<=vo_0 :: T_0=T :: vr_0=vr :: vo_0=vo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&T=T_0+t&vr=vr_0-b()*t&vo=vo_0+ao*t) :: nil"
                        ),
                      "[?vr=0;ar:=0;][t:=0;][dyn{|^@|};](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)":
                        expand "dyn";
                        dC("t>=0&T=old(T)+t&vr=old(vr)", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                          "Use":
                            dC("xr=old(xr)+old(vr)*t", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                              "Use":
                                dC("vo=old(vo)+ao*t", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&((t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0)&xr=xr_0+vr_0*t}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                                  "Use":
                                    dC("xo=old(xo)+old(vo)*t+ao*t^2/2", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(((t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0)&xr=xr_0+vr_0*t)&vo=vo_0+ao*t}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                                      "Use":
                                        dW('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&((((t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0)&xr=xr_0+vr_0*t)&vo=vo_0+ao*t)&xo=xo_0+vo_0*t+ao*t^2/2}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)");
                                        QE,
                                      "Show":
                                        dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(((t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0)&xr=xr_0+vr_0*t)&vo=vo_0+ao*t}]xo=xo_0+vo_0*t+ao*t^2/2") using "A()>0 :: b()>0 :: Vmin()>0 :: vr_0=0 :: ar=0 :: t=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: Vmin()<=vo_0 :: T_0=T :: vr_0=vr :: xr_0=xr :: vo_0=vo :: xo_0=xo :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(((t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0)&xr=xr_0+vr_0*t)&vo=vo_0+ao*t}]xo=xo_0+vo_0*t+ao*t^2/2 :: nil"
                                    ),
                                  "Show":
                                    dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&((t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0)&xr=xr_0+vr_0*t}]vo=vo_0+ao*t") using "A()>0 :: b()>0 :: Vmin()>0 :: vr_0=0 :: ar=0 :: t=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: Vmin()<=vo_0 :: T_0=T :: vr_0=vr :: xr_0=xr :: vo_0=vo :: nil"
                                ),
                              "Show":
                                dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0}]xr=xr_0+vr_0*t") using "A()>0 :: b()>0 :: Vmin()>0 :: vr_0=0 :: ar=0 :: t=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: Vmin()<=vo :: T_0=T :: vr_0=vr :: xr_0=xr :: nil"
                            ),
                          "Show":
                            dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&T=T_0+t&vr=vr_0)") using "A()>0 :: b()>0 :: Vmin()>0 :: vr_0=0 :: ar=0 :: t=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: Vmin()<=vo :: T_0=T :: vr_0=vr :: [{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&T=T_0+t&vr=vr_0) :: nil"
                        ),
                      "[?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();][t:=0;][dyn{|^@|};](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)":
                        expand "dyn";
                        dC("t>=0&T=old(T)+t&vr=old(vr)+A()*t", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                          "Use":
                            dC("xr=old(xr)+old(vr)*t+A()*t^2/2", 'R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0+A()*t}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)"); <(
                              "Use":
                                dW('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&((t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0+A()*t)&xr=xr_0+vr_0*t+A()*t^2/2}](T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max(0,D()-T)+A()/2*max(0,D()-T)^2>0)");
                                QE,
                              "Show":
                                dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&(t<=ep()&vr>=0&vo>=Vmin())&t>=0&T=T_0+t&vr=vr_0+A()*t}]xr=xr_0+vr_0*t+A()*t^2/2") using "A()>0 :: b()>0 :: Vmin()>0 :: ar=A() :: t=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: Vmin()<=vo :: T_0=T :: vr_0=vr :: xr_0=xr :: nil"
                            ),
                          "Show":
                            dIClose('R=="[{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}](t>=0&T=T_0+t&vr=vr_0+A()*t)") using "A()>0 :: b()>0 :: Vmin()>0 :: ar=A() :: t=0 :: 0<=vr_0 :: -b()<=ao :: ao<=A() :: Vmin()<=vo :: T_0=T :: vr_0=vr :: nil"
                        )
                    )
                )
            )
        )
    )
)
End.

End.

Theorem "IJRR17/Theorem 15: Cross intersection with deadline"

/*
 *	Robot must safely cross an intersection.
 *
 *  Robot
 * 	- must cross intersection safely
 *  - can only drive straight and forward
 *  - ensures progress towards intersection
 *
 *  Obstacle
 *  - Drives forward with minimum speed (does not block intersection)
 *
 *  Intersection
 *  - At position 0 (on both the robot's and the obstacle's path)
 *
 *  Liveness property:
 *  - Robot can cross intersection
 *
 *  Safety property:
 *  - Robot always crosses intersection before deadline
 *  - Robot and obstacle are not at the intersection at the same time
 *
 */

Definitions
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real Vmin;    /* obstacle minimum speed */
  Real ixr = 0; /* position of intersection on path of robot */
  Real ixo = 0; /* position of intersection on path of obstacle */
  Real D;       /* Deadline */

  Real minV = A*ep;

  Real stopDist(Real v) = v^2/(2*b);
  Real accComp(Real v)  = ( (A/b + 1)*(A/2*ep^2 + ep*v) );

  Bool OAfterX(Real xo) <-> xo>ixo;
  Bool RAfterX(Real xr) <-> xr>ixr;

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A > 0                                                                                         /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & Vmin > 0
    & D >= ep
  );

  /* Somewhere before intersection initially */
  Bool initialState(Real xr, Real vr, Real ixr, Real xo, Real vo, Real ixo, Real T) <-> (
    vr = 0
    & vo>=Vmin
    & xr < ixr
    & ixr-xr < A/2*(D-ep)^2
    & T = min(0, (xo-ixo)/Vmin) - ep
    & RAfterX(xr + A/2*(D - ep)^2)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real xr, Real vr, Real ixr, Real xo, Real vo, Real ixo, Real T) <->
    bounds() & initialState(xr, vr, ixr, xo, vo, ixo, T);

  Bool safetyloopinv(Real xr, Real vr, Real ixr, Real xo, Real vo, Real ixo) <-> (
    0 <= vr & Vmin<=vo & (RAfterX(xr) | OAfterX(xo) | xr + stopDist(vr) < ixr |
      (vr>0 & ( xo+vo*(ixr-xr)/vr+A/2*((ixr-xr)/vr)^2 < ixo
              | ixo < xo + Vmin*(ixr-xr)/vr))
    )
  );

  Bool deadlineloopinv(Real xr, Real vr, Real ixr, Real xo, Real vo, Real ixo, Real T) <-> (
    0 <= vr & Vmin<=vo
    & T <= (xo-ixo)/Vmin
    & ( T <= 0 & RAfterX(xr + A/2*(D - ep)^2)
      | T > 0 & RAfterX(xr + vr*(max(0,D-T)) + A/2*(max(0,D-T))^2) )
  );

  HP obstacle ::= { ao := *; ?-b<=ao&ao<=A; };

  HP robot ::= {
    if (OAfterX(xo)) {
      ar := A;
    } else { if (RAfterX(xr)) {
      ar := *; ?-b<=ar&ar<=A;
    } else { if (/*PassFaster*/ vr>0 & ( xo+vo*(ixr-xr)/vr+A/2*((ixr-xr)/vr)^2 < ixo
                                       | ixo < xo + Vmin*(ixr-xr)/(vr+A*ep) ) ) {
      ar := *; ?0<=ar&ar<=A;
    } else { if (/*PassCoast*/ vr>0 & ixo < xo + Vmin*(ixr-xr)/vr) {
      ar := 0;
    } else {         /* 1D Model 3 */
        ar := -b;
     ++ ?vr = 0; ar := 0;
     ++ ?xr + stopDist(vr) + accComp(vr) < ixr; ar := A;
    }}}}
  };

  HP dyn ::= { {xr' = vr, vr' = ar, xo'=vo, vo'=ao, t' = 1, T'=1 & t <= ep & vr >= 0 & vo>=Vmin } };

  HP dwcxd ::= {
    {
      obstacle;
      { robot; t := 0; }
      dyn;
    }*
  };

End.

ProgramVariables
  Real xr;   /* robot position: x */
  Real vr;   /* robot translational velocity */
  Real ar;   /* robot translational acceleration */
  Real xo;   /* obstacle position */
  Real vo;   /* obstacle velocity */
  Real ao;   /* obstacle acceleration */
  Real t;	   /* control cycle time */
  Real T;    /* remaining time until robot must start driving (i.e., until obstacle has passed the intersection) */
End.

Problem
  assumptions(xr, vr, ixr, xo, vo, ixo, T)
    ->
    /* safety */
    [ dwcxd; ]( (xr=ixr -> xo!=ixo) & (T>=D -> RAfterX(xr)) )
    &
    /* liveness */
    < dwcxd; >( RAfterX(xr) )
End.

/* todo: port tactic */
/*
Tactic "Proof Theorem 15: Cross intersection with deadline (single convergence condition)".
useSolver("Mathematica");

tactic leafQE as ( print("Proving arithmetic"); QE; done );

implyR(1) ; andR(1) ; <(
  useLemma("IJRR17/Lemma: Cross intersection with deadline - Safety", "prop"),
  con("v", "vo>=Vmin&vr>=0&(xo<=0->vr=0|xr>0)&\exists n (n>=2&xo+(v-n)*ep*Vmin>0&vr+(min((v,n-1))-(n-2))*ep*A>=A*ep&xr+min((v,n-2))*ep*(A*ep)>0)", 1) ; <(
    leafQE,
    leafQE,
    composed(1) ; composed(1.1) ; solve(1.1.1) ; composed(1) ; randomd(1) ; existsR("0", 1) ; testd(1) ; andR(1) ; <(
      leafQE,
      andL('L)* ;
      composed(1) ; choiced(1) ; orR(1) ; existsL(-10) ; andL('L)* ; implyL(-9) ; <(
        edit("!xo>0", 3) ; notR(3) ; composed(1) ; testd(1) ; simplify(1) ;
        hideR(2=="<?!xo>0;{?xr>0;ar:=*;?-b()<=ar&ar<=A();++?!xr>0;{?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))");
        chaseAt(1) ; existsR("ep()", 1) ; fullSimplify ; andR(1) ; <(
          leafQE,
          andR(1) ; <(
            leafQE,
            andR(1) ; <(
              leafQE,
              existsR("n", 1) ; QE
            )
          )
        ),
        composed(1) ; testd(1) ; composed(2) ; testd(2) ; andR(1) ; <(
          andR(2) ; <(
            prop,
            choiced(2) ; orR(2) ; composed(2) ; testd(2) ; composed(3) ; testd(3) ; orL(-9) ; <(
              andR(2) ; <(
                andR(3) ; <(
                  prop,
                  choiced(3) ; orR(3) ;
                  hideR(3=="<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                  composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ;
                  hideR(3=="<?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                  composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ;
                  hideR(3=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                  choiced(3) ; orR(3) ;
                  hideR(4=="<?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                  chaseAt(3) ; simplify(3) ; existsR("ep()", 3) ; fullSimplify ; existsR("n", 3) ; QE
                ),
                andR(3) ; <(
                  composed(2) ; randomd(2) ; existsR("0", 2) ; testd(2) ; andR(2) ; <(
                    leafQE,
                    assignd(2) ; existsR("ep", 2) ; fullSimplify ; existsR("n", 2) ; fullSimplify ; leafQE
                  ),
                  choiced(3) ; orR(3) ;
                  hideR(3=="<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                  composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ;
                  hideR(3=="<?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                  composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ;
                  hideR(3=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                  choiced(3) ; orR(3) ;
                  hideR(4=="<?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                  chaseAt(3) ; simplify(3) ; existsR("ep()", 3) ;
                  hideR(2=="<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                  simplify(2) ; existsR("n", 2) ; leafQE
                )
              ),
              simplify(2) ;
              hideR(3=="!xr>0&<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
              chaseAt(2) ; existsR("0", 2) ; andR(2) ; <(
                leafQE,
                existsR("ep()", 2) ; simplify(2) ; andR(2) ; <(
                  leafQE,
                  existsR("n", 2) ; leafQE
                )
              )
            )
          ),
          orL(-9) ; <(
            andR(2) ; <(
              assignd(1) ; assignd(1) ; existsR("ep", 1) ; fullSimplify ; andR(1) ; <(
                leafQE,
                andR(1) ; <(
                  leafQE,
                  andR(1) ; <(
                    leafQE,
                    existsR("n", 1) ; fullSimplify ; leafQE
                  )
                )
              ),
              choiced(2) ; orR(2) ; composed(2) ; testd(2) ; composed(3) ; testd(3) ; andR(2) ; <(
                andR(3) ; <(
                  prop,
                  choiced(3) ; orR(3) ;
                  hideR(3=="<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                  composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ;
                  hideR(3=="<?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                  composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ;
                  hideR(3=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                  choiced(3) ; orR(3) ;
                  hideR(4=="<?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                  chaseAt(3) ; simplify(3) ; chaseAt(1) ; existsR("ep()", 1) ; existsR("ep()", 3) ; fullSimplify ;
                  andR(1) ; <(
                    leafQE,
                    andR(1) ; <(
                      leafQE,
                      andR(1) ; <(
                        leafQE,
                        existsR("n", 1) ; existsR("n", 3) ; fullSimplify ; leafQE
                      )
                    )
                  )
                ),
                hideR(1=="<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                chaseAt(1) ; existsR("A()", 1) ; andR(1) ; <(
                  hideR(2=="!xr>0&<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                  leafQE,
                  existsR("ep()", 1) ; simplify(1) ; andR(1) ; <(
                    hideR(2=="!xr>0&<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                    leafQE,
                    andR(1) ; <(
                      hideR(2=="!xr>0&<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                      leafQE,
                      andR(1) ; <(
                        andR(2) ; <(
                          leafQE,
                          choiced(2) ; orR(2) ;
                          hideR(2=="<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                          composed(2) ; testd(2) ; simplify(2) ; choiced(2) ; orR(2) ;
                          hideR(2=="<?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                          composed(2) ; testd(2) ; simplify(2) ; choiced(2) ; orR(2) ;
                          hideR(2=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                          choiced(2) ; orR(2) ;
                          hideR(3=="<?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                          chaseAt(2) ; simplify(2) ; existsR("ep()", 2) ; simplify(2) ; existsR("n", 2) ; leafQE
                        ),
                        hideR(2=="!xr>0&<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                        existsR("n", 1) ; leafQE
                      )
                    )
                  )
                )
              )
            ),
            chase(1) ; existsR("ep", 1) ; simplify(1) ; andR(1) ; <(
              hideR(2=="!xo>0&<?xr>0;ar:=*;?-b()<=ar&ar<=A();++?!xr>0;{?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
              leafQE
              ,
              andR(1) ; <(
                hideR(2=="!xo>0&<?xr>0;ar:=*;?-b()<=ar&ar<=A();++?!xr>0;{?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                leafQE
                ,
                hideR(2=="!xo>0&<?xr>0;ar:=*;?-b()<=ar&ar<=A();++?!xr>0;{?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo<=0->ar*t_+vr=0|ar*(t_^2/2)+vr*t_+xr>0)&\exists n (n>=2&0*(t_^2/2)+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min(v-1,n-1)-(n-2))*ep()*A()>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+min(v-1,n-2)*ep()*(A()*ep())>0))") ;
                andR(1) ; <(
                  QE,
                  existsR("n", 1) ; QE
                  )
                )
              )
            )
          )
        )
      )
    )
  )
End.
*/

Tactic "IJRR17/Proof Theorem 15: Cross intersection with deadline (loop split and unroll)".
useSolver("Mathematica");
implyR('R=="assumptions(xr,vr,ixr(),xo,vo,ixo(),T)->[dwcxd{|^@|};]((xr=ixr()->xo!=ixo())&(T>=D()->RAfterX(xr)))&<dwcxd{|^@|};>RAfterX(xr)");
andR('R=="[dwcxd{|^@|};]((xr=ixr()->xo!=ixo())&(T>=D()->RAfterX(xr)))&<dwcxd{|^@|};>RAfterX(xr)"); <(
  "[dwcxd{|^@|};]((xr=ixr()->xo!=ixo())&(T>=D()->RAfterX(xr)))":
    useLemma("IJRR17/Lemma: Cross intersection with deadline - Safety", "prop"),
  "<dwcxd{|^@|};>RAfterX(xr)":
    expand "dwcxd";
    useAt("<*> merge", "1", 'R=="<{obstacle{|^@|};{robot{|^@|};t:=0;}dyn{|^@|};}*>RAfterX(xr)");
    expand "obstacle";
    expand "robot";
    expand "dyn";
    expand "assumptions";
    andL('L=="bounds()&initialState(xr,vr,ixr(),xo,vo,ixo(),T)");
    con("v", "vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+v*ep()*Vmin()>0", 'R=="<{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)"); <(
      "Init":
        QE,
      "Post":
        expand "bounds";
        andL('L)*;
        edit("xo>0", 'L=="xo+v*ep()*Vmin()>0") using "v<=0 :: ep()>0 :: Vmin()>0 :: nil";
        hideL('L=="v<=0");
        iterated('R=="<{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
        orR('R=="RAfterX(xr)|<{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
        composed('R=="<{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
        composed('R=="<ao:=*;?-b()<=ao&ao<=A();><{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
        randomd('R=="<ao:=*;><?-b()<=ao&ao<=A();><{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
        existsR("0", 'R=="\exists ao <?-b()<=ao&ao<=A();><{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
        testd('R=="<?-b()<=0&0<=A();><{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
        andR('R=="(-b()<=0&0<=A())&<{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)"); <(
          "-b()<=0&0<=A()":
            QE using "A()>0 :: b()>0 :: -b()<=0&0<=A() :: nil",
          "<{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)":
            composed('R=="<{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
            composed('R=="<{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
            choiced('R=="<?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
            orR('R=="<?OAfterX(xo);ar:=A();><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)|<?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
            hideR('R=="<?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
            composed('R=="<?OAfterX(xo);ar:=A();><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
            testd('R=="<?OAfterX(xo);><ar:=A();><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
            andR('R=="OAfterX(xo)&<ar:=A();><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)"); <(
              "OAfterX(xo)":
                QE,
              "<ar:=A();><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)":
                assignd('R=="<ar:=A();><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
                assignd('R=="<t:=0;><{xr'=vr,vr'=A(),xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
                solve('R=="<{xr'=vr,vr'=A(),xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)");
                existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr_1>=0)&\forall T (T=t_+T_1->\forall vo (vo=vo_1->\forall vr (vr=A()*t_+vr_1->\forall xo (xo=vo_1*t_+xo_1->\forall xr (xr=A()*(t_^2/2)+vr_1*t_+xr_1-><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)))))))");
                simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+t<=ep()&A()*s_+vr_1>=0)&\forall T (T=ep()+T_1->\forall vo (vo=vo_1->\forall vr (vr=A()*ep()+vr_1->\forall xo (xo=vo_1*ep()+xo_1->\forall xr (xr=A()*(ep()^2/2)+vr_1*ep()+xr_1-><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr))))))") using "ep()>0";
                andR('R=="\forall s_ (0<=s_&s_<=ep()->s_+t<=ep()&A()*s_+vr_1>=0)&\forall T (T=ep()+T_1->\forall vo (vo=vo_1->\forall vr (vr=A()*ep()+vr_1->\forall xo (xo=vo_1*ep()+xo_1->\forall xr (xr=A()*(ep()^2/2)+vr_1*ep()+xr_1-><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr))))))"); <(
                  "\forall s_ (0<=s_&s_<=ep()->s_+t<=ep()&A()*s_+vr_1>=0)":
                    QE using "A()>0 :: vr_1>=0 :: ep()>0 :: t=0 :: \forall s_ (0<=s_&s_<=ep()->s_+t<=ep()&A()*s_+vr_1>=0) :: nil",
                  "\forall T (T=ep()+T_1->\forall vo (vo=vo_1->\forall vr (vr=A()*ep()+vr_1->\forall xo (xo=vo_1*ep()+xo_1->\forall xr (xr=A()*(ep()^2/2)+vr_1*ep()+xr_1-><{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr))))))":
                    (allR(2) ; implyR(2))*5;
                    edit("vr>=A()*ep()", 'L=="vr=A()*ep()+vr_1") using "A()>0 :: vr_1>=0 :: ep()>0 :: nil";
                    edit("xo>0", 'L=="xo=vo_1*ep()+xo_1") using "vo_1>=Vmin() :: xo_1>0 :: ep()>0 :: Vmin()>0 :: vo=vo_1 :: nil";
                    edit("xr>=xr_1", 'L=="xr=A()*(ep()^2/2)+vr_1*ep()+xr_1") using "A()>0 :: vr_1>=0 :: ep()>0 :: nil";
                    con("w", "vo>=Vmin()&xo>0&vr>=A()*ep()&xr+w*ep()*(A()*ep())>0", 'R=="<{{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>RAfterX(xr)"); <(
                      "Init":
                        QE,
                      "Post":
                        QE,
                      "Step":
                        composed('R=="<{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}>(vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)");
                        composed('R=="<ao:=*;?-b()<=ao&ao<=A();><{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}>(vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)");
                        randomd('R=="<ao:=*;><?-b()<=ao&ao<=A();><{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}>(vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)");
                        existsR("0", 'R=="\exists ao <?-b()<=ao&ao<=A();><{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}>(vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)");
                        testd('R=="<?-b()<=0&0<=A();><{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}>(vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)");
                        andR('R=="(-b()<=0&0<=A())&<{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}>(vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)"); <(
                          "-b()<=0&0<=A()":
                            QE using "A()>0 :: b()>0 :: -b()<=0&0<=A() :: nil",
                          "<{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}>(vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)":
                            composed('R=="<{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}>(vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)");
                            solve('R=="<{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;>#<{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}>(vo>=Vmin()&xo>0&vr>=A()*ep()&xr+(w-1)*ep()*(A()*ep())>0)#");
                            composed('R=="<{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                            choiced('R=="<?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                            orR('R=="<?OAfterX(xo);ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)|<?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                            hideR('R=="<?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                            composed('R=="<?OAfterX(xo);ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                            testd('R=="<?OAfterX(xo);><ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                            andR('R=="OAfterX(xo)&<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)"); <(
                              "OAfterX(xo)":
                                QE,
                              "<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)":
                                assignd('R=="<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                                assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&A()*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&vo*t_+xo>0&A()*t_+vr>=A()*ep()&A()*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                                existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&A()*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&vo*t_+xo>0&A()*t_+vr>=A()*ep()&A()*(t_^2/2)+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)");
                                andL('L)*;
                                simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&A()*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&vo*ep()+xo>0&A()*ep()+vr>=A()*ep()&A()*(ep()^2/2)+vr*ep()+xr+(w-1)*ep()*(A()*ep())>0") using "ep()>0 :: Vmin()>0 :: vo>=Vmin() :: xo>0 :: nil";
                                QE
                            )
                        )
                    )
                )
            )
        ),
      "Step":
        expand "bounds";
        andL('L)*;
        composed('R=="<{ao:=*;?-b()<=ao&ao<=A();}{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}>(vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+(v-1)*ep()*Vmin()>0)");
        composed('R=="<ao:=*;?-b()<=ao&ao<=A();>#<{{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}>(vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+(v-1)*ep()*Vmin()>0)#");
        solve('R=="<ao:=*;?-b()<=ao&ao<=A();><{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;>#<{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}>(vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+(v-1)*ep()*Vmin()>0)#");
        composed('R=="<ao:=*;?-b()<=ao&ao<=A();><{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&ao*s_+vo>=Vmin())&ao*t_+vo>=Vmin()&ar*t_+vr>=0&(ao*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&ao*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
        randomd('R=="<ao:=*;><?-b()<=ao&ao<=A();><{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&ao*s_+vo>=Vmin())&ao*t_+vo>=Vmin()&ar*t_+vr>=0&(ao*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&ao*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
        existsR("0", 'R=="\exists ao <?-b()<=ao&ao<=A();><{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&ao*s_+vo>=Vmin())&ao*t_+vo>=Vmin()&ar*t_+vr>=0&(ao*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&ao*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
        testd('R=="<?-b()<=0&0<=A();><{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
        andR('R=="(-b()<=0&0<=A())&<{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
          "-b()<=0&0<=A()":
            QE using "A()>0 :: b()>0 :: -b()<=0&0<=A() :: nil",
          "<{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)":
            composed('R=="<{?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}}t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
            choiced('R=="<?OAfterX(xo);ar:=A();++?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
            orR('R=="<?OAfterX(xo);ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
            composed('R=="<?OAfterX(xo);ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
            testd('R=="<?OAfterX(xo);><ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
            orL('L=="xo>0|vr=0"); <(
              "xo>0":
                andR('R=="OAfterX(xo)&<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                  "OAfterX(xo)":
                    QE using "xo>0 :: OAfterX(xo) :: nil",
                  "<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                    hideR('R=="<?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                    chaseAt('R=="<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                    existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|A()*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                    simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&0*ep()+vo>=Vmin()&A()*ep()+vr>=0&(0*(ep()^2/2)+vo*ep()+xo>0|A()*ep()+vr=0)&0*(ep()^2/2)+vo*ep()+xo+(v-1)*ep()*Vmin()>0") using "ep()>0";
                    QE
                ),
              "vr=0":
                composed('R=="<?!OAfterX(xo);{?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                testd('R=="<?!OAfterX(xo);><?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                andR('R=="OAfterX(xo)&<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                  "OAfterX(xo)":
                    andR('R=="!OAfterX(xo)&<?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                      "!OAfterX(xo)":
                        notR('R=="!OAfterX(xo)");
                        id using "OAfterX(xo) :: OAfterX(xo) :: nil",
                      "<?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                        choiced('R=="<?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        orR('R=="<?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        composed('R=="<?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        testd('R=="<?RAfterX(xr);><ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        composed('R=="<?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        testd('R=="<?!RAfterX(xr);><?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        andR('R=="RAfterX(xr)&<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                          "RAfterX(xr)":
                            andR('R=="!RAfterX(xr)&<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                              "!RAfterX(xr)":
                                notR('R=="!RAfterX(xr)");
                                id using "RAfterX(xr) :: RAfterX(xr) :: nil",
                              "<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                                choiced('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                orR('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                hideR('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                composed('R=="<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                testd('R=="<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));><?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                simplify('R=="!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())))&<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                choiced('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                orR('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                hideR('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                composed('R=="<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                testd('R=="<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);><ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                simplify('R=="!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr)&<ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                choiced('R=="<ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                orR('R=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                hideR('R=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                choiced('R=="<?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                orR('R=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                hideR('R=="<?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                chaseAt('R=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                simplify('R=="vr=0&\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&0*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo>0|0*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)") using "vr=0";
                                existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_<=ep()&vo>=Vmin())&vo>=Vmin()&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_<=ep()&vo>=Vmin())&vo>=Vmin()&vo*ep()+xo+(v-1)*ep()*Vmin()>0") using "vo>=Vmin() :: ep()>0 :: nil";
                                QE
                            ),
                          "<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                            composed('R=="<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                            randomd('R=="<ar:=*;><?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                            existsR("0", 'R=="\exists ar <?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                            testd('R=="<?-b()<=0&0<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|0*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                            hideR('R=="!RAfterX(xr)&<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                            andR('R=="(-b()<=0&0<=A())&<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|0*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                              "-b()<=0&0<=A()":
                                QE using "A()>0 :: b()>0 :: -b()<=0&0<=A() :: nil",
                              "<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|0*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                                chaseAt('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|0*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|0*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&0*ep()+vo>=Vmin()&0*ep()+vr>=0&(0*(ep()^2/2)+vo*ep()+xo>0|0*ep()+vr=0)&0*(ep()^2/2)+vo*ep()+xo+(v-1)*ep()*Vmin()>0") using "vo>=Vmin() :: ep()>0 :: nil";
                                QE
                            )
                        )
                    ),
                  "<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                    andR('R=="!OAfterX(xo)&<?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                      "!OAfterX(xo)":
                        chaseAt('R=="<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|A()*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&0*ep()+vo>=Vmin()&A()*ep()+vr>=0&(0*(ep()^2/2)+vo*ep()+xo>0|A()*ep()+vr=0)&0*(ep()^2/2)+vo*ep()+xo+(v-1)*ep()*Vmin()>0") using "vo>=Vmin() :: ep()>0 :: nil";
                        QE,
                      "<?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                        chaseAt('R=="<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&A()*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|A()*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&A()*s_+vr>=0&0*s_+vo>=Vmin())&0*ep()+vo>=Vmin()&A()*ep()+vr>=0&(0*(ep()^2/2)+vo*ep()+xo>0|A()*ep()+vr=0)&0*(ep()^2/2)+vo*ep()+xo+(v-1)*ep()*Vmin()>0") using "vo>=Vmin() :: ep()>0 :: nil";
                        choiced('R=="<?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();++?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        orR('R=="<?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        composed('R=="<?RAfterX(xr);ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        testd('R=="<?RAfterX(xr);><ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        composed('R=="<?!RAfterX(xr);{?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        testd('R=="<?!RAfterX(xr);><?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                        andR('R=="RAfterX(xr)&<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                          "RAfterX(xr)":
                            andR('R=="!RAfterX(xr)&<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                              "!RAfterX(xr)":
                                notR('R=="!RAfterX(xr)");
                                id using "RAfterX(xr) :: RAfterX(xr) :: nil",
                              "<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                                choiced('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                orR('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                hideR('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                composed('R=="<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                testd('R=="<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));><?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                simplify('R=="!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())))&<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                choiced('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                orR('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                hideR('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                composed('R=="<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                testd('R=="<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);><ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                simplify('R=="!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr)&<ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                choiced('R=="<ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                orR('R=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                hideR('R=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                choiced('R=="<?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                orR('R=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                hideR('R=="<?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                chaseAt('R=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                simplify('R=="vr=0&\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&0*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo>0|0*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)") using "vr=0";
                                existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_<=ep()&vo>=Vmin())&vo>=Vmin()&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_<=ep()&vo>=Vmin())&vo>=Vmin()&vo*ep()+xo+(v-1)*ep()*Vmin()>0") using "vo>=Vmin() :: ep()>0 :: nil";
                                QE using "v>0 :: vo>=Vmin() :: A()>0 :: vr>=0 :: b()>0 :: vr=0 :: xo+v*ep()*Vmin()>0 :: ep()>0 :: Vmin()>0 :: D()>=ep() :: RAfterX(xr) :: vo*ep()+xo+(v-1)*ep()*Vmin()>0 :: nil"
                            ),
                          "<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                            andR('R=="!RAfterX(xr)&<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                              "!RAfterX(xr)":
                                composed('R=="<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                randomd('R=="<ar:=*;><?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                existsR("0", 'R=="\exists ar <?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                testd('R=="<?-b()<=0&0<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|0*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                andR('R=="(-b()<=0&0<=A())&<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|0*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)"); <(
                                  "-b()<=0&0<=A()":
                                    QE using "A()>0 :: b()>0 :: -b()<=0&0<=A() :: nil",
                                  "<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|0*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                                    assignd('R=="<t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|0*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                    existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&0*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|0*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                    simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&0*s_+vr>=0&0*s_+vo>=Vmin())&0*ep()+vo>=Vmin()&0*ep()+vr>=0&(0*(ep()^2/2)+vo*ep()+xo>0|0*ep()+vr=0)&0*(ep()^2/2)+vo*ep()+xo+(v-1)*ep()*Vmin()>0") using "vo>=Vmin() :: ep()>0 :: nil";
                                    QE
                                ),
                              "<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)":
                                choiced('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                orR('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                hideR('R=="<?vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                composed('R=="<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));{?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                testd('R=="<?!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())));><?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                simplify('R=="!(vr>0&(xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()|ixo() < xo+Vmin()*(ixr()-xr)/(vr+A()*ep())))&<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&0*t_+vo>=Vmin()&ar*t_+vr>=0&(0*(t_^2/2)+vo*t_+xo>0|ar*t_+vr=0)&0*(t_^2/2)+vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                choiced('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;++?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                orR('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                hideR('R=="<?vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                composed('R=="<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                testd('R=="<?!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr);><ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                simplify('R=="!(vr>0&ixo() < xo+Vmin()*(ixr()-xr)/vr)&<ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                choiced('R=="<ar:=-b();++?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                orR('R=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                hideR('R=="<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                choiced('R=="<?vr=0;ar:=0;++?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                orR('R=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)|<?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                hideR('R=="<?xr+stopDist(vr)+accComp(vr) < ixr();ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                composed('R=="<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                testd('R=="<?vr=0;><ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                simplify('R=="vr=0&<ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)") using "vr=0";
                                chaseAt('R=="<ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&ar*t_+vr>=0&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                existsR("ep()", 'R=="\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&0*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&0*t_+vr>=0&(vo*t_+xo>0|0*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)");
                                simplify('R=="ep()>=0&\forall s_ (0<=s_&s_<=ep()->s_+0<=ep()&0*s_+vr>=0&vo>=Vmin())&vo>=Vmin()&0*ep()+vr>=0&(vo*ep()+xo>0|0*ep()+vr=0)&vo*ep()+xo+(v-1)*ep()*Vmin()>0") using "vo>=Vmin() :: ep()>0 :: nil";
                                QE using "v>0 :: vo>=Vmin() :: A()>0 :: vr>=0 :: b()>0 :: vr=0 :: xo+v*ep()*Vmin()>0 :: ep()>0 :: Vmin()>0 :: D()>=ep() :: \forall s_ (0<=s_&s_<=ep()->vr>=0)&vr>=0&(vo*ep()+xo>0|vr=0)&vo*ep()+xo+(v-1)*ep()*Vmin()>0 :: nil"
                            )
                        )
                    )
                )
            )
        )
    )
)
End.

End.

Theorem "Theorem 1: Static safety".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = (v^2 / (2*b())).            /* The straight-line stopping distance from brake start to full stop. */
  R accelComp(R v) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*v))./* Straight-line distance to compensate acceleration */
  R admissibleSeparation(R v) = (stopDist(v) + accelComp(v)).   /* Separation that allows accelerating on a new curve */

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      {
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        t' = 1 & t <= ep & v >= 0
      }@invariant(t>=0, isWellformedDir(),
         (v'=-b() -> v = old(v) - b()*t),
         (v'=-b() -> (-t * (old(v) - b()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - b()/2*t))),
         (v'=-b() -> (-t * (old(v) - b()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - b()/2*t))),
         (v'=0 -> v = old(v)),
         (v'=0 -> x = old(x)),
         (v'=0 -> y = old(y)),
         (v'=A() -> v = old(v) + A()*t),
         (v'=A() -> (-t * (old(v) + A()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t))),
         (v'=A() -> (-t * (old(v) + A()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t)))
       )
      }
    }*@invariant(loopinv())
  ](x - xo)^2 + (y - yo)^2 > 0
End.

Tactic "Proof Theorem 1: Static safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo)>v_0^2/(2*b())+(A()/b()+1)*(A()/2*t^2+t*v_0)`}, 'L=={`abs(x_0-xo)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo)>v_0^2/(2*b())+(A()/b()+1)*(A()/2*t^2+t*v_0)`}, 'L=={`abs(y_0-yo)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`abs(x-xo_0)>stopDist(v)|abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

Tactic "Proof Theorem 1: Static safety from annotations".
  master
End.

End.

ArchiveEntry "Corollary 1.1: Velocity-controlled passive safety".

Functions.
  R ep().      /* time limit for control decisions */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = (0).
  R accelComp(R v) = (ep()*(v+V())).
  R admissibleSeparation(R v) = (stopDist(v) + accelComp(v)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { v := 0; w := 0; }
          ++
          /* or choose a new safe curve */
          { v := *; ?0<=v;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      {
      { x' = v * dx, y' = v * dy,                /* move */
        dx' = -w * dy, dy' = w * dx,             /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }@invariant(t>=0, isWellformedDir(),
        (-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()),
        (-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()),
        (x'=0*dx -> x = old(x)),
        (x'=0*dx -> y = old(y)),
        (x'=v*dx -> -t * v <= x - old(x) & x - old(x) <= t * v),
        (x'=v*dx -> -t * v <= y - old(y) & y - old(y) <= t * v)
      )
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Corollary 1: Velocity-controlled passive safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`-t * v <= x - old(x) & x - old(x) <= t * v`}, 1);
    diffInvariant({`-t * v <= y - old(y) & y - old(y) <= t * v`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v_0>0 -> abs(x-xo_0)>stopDist(v_0) | abs(y-yo_0)>stopDist(v_0)`});
      dia; dw; prop; doall(smartQE); print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Corollary 1.2: Static safety with margin for imperfect trajectories".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R Ud().      /* direction uncertainty */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = ((1+Ud()) * v^2 / (2*b())).            /* The straight-line stopping distance from brake start to full stop. */
  R accelComp(R v) = ((1+Ud()) * (A()/b() + 1) * (A()/2 * ep()^2 + ep()*v)). /* Straight-line distance to compensate acceleration */
  R admissibleSeparation(R v) = (stopDist(v) + accelComp(v)).   /* Separation that allows accelerating on a new curve */

  B isWellformedDir() <-> (1-Ud() <= dx^2+dy^2 & dx^2 + dy^2 <= 1+Ud()). /* The orientation of the robot is approximately a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & 0<=Ud() & Ud() <= 1
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      {
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        t' = 1 & t <= ep & v >= 0
      }@invariant(t>=0, isWellformedDir(),
         (v'=-b() -> v <= old(v) - b()*t),
         (v'=-b() -> (-t * (old(v) - b()/2*t) * (1+Ud()) <= x - old(x) & x - old(x) <= t * (old(v) - b()/2*t) * (1+Ud()))),
         (v'=-b() -> (-t * (old(v) - b()/2*t) * (1+Ud()) <= y - old(y) & y - old(y) <= t * (old(v) - b()/2*t) * (1+Ud()))),
         (v'=0 -> v = old(v)),
         (v'=0 -> x = old(x)),
         (v'=0 -> y = old(y)),
         (v'=A() -> v <= old(v) + A()*t),
         (v'=A() -> (-t * (old(v) + A()/2*t) * (1+Ud()) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t) * (1+Ud()))),
         (v'=A() -> (-t * (old(v) + A()/2*t) * (1+Ud()) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t) * (1+Ud())))
       )
      }
    }*@invariant(loopinv())
  ](x - xo)^2 + (y - yo)^2 > 0
End.

Tactic "Proof Theorem 1: Static safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v <= old(v) - b()*t`}, 1);
    diffInvariant({`-t * (old(v) - b()/2*t) * (1+Ud()) <= x - old(x) & x - old(x) <= t * (old(v) - b()/2*t) * (1+Ud())`}, 1);
    diffInvariant({`-t * (old(v) - b()/2*t) * (1+Ud()) <= y - old(y) & y - old(y) <= t * (old(v) - b()/2*t) * (1+Ud())`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v <= old(v) + A()*t`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) * (1+Ud()) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t) * (1+Ud())`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) * (1+Ud()) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t) * (1+Ud())`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo)>(1+Ud())*(v_0^2/(2*b())+(A()/b()+1)*(A()/2*t^2+t*v_0))`}, 'L=={`abs(x_0-xo)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo)>(1+Ud())*(v_0^2/(2*b())+(A()/b()+1)*(A()/2*t^2+t*v_0))`}, 'L=={`abs(y_0-yo)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`abs(x-xo_0)>stopDist(v)|abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Corollary 1.3: Static safety with margin for imperfect trajectories (no division)".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R Ud().      /* direction uncertainty */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = ((1+Ud()) * v^2).            /* The straight-line stopping distance from brake start to full stop. */
  R accelComp(R v, R t) = ((1+Ud()) * (A() + b()) * (A() * t^2 + 2*t*v)). /* Straight-line distance to compensate acceleration */
  R admissibleSeparation(R v, R t) = (stopDist(v) + accelComp(v,t)).   /* Separation that allows accelerating on a new curve */

  B isWellformedDir() <-> (1-Ud() <= dx^2+dy^2 & dx^2 + dy^2 <= 1+Ud()). /* The orientation of the robot is approximately a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & 0<=Ud() & Ud() <= 1
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0 & a = 0 & w = 0 & r = 1 & t = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (2*b()*abs(x-xo) > stopDist(v) | 2*b()*abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        {
          /* brake on current curve or remain stopped */
          { a := -b(); }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? 2*b()*abs(x-xo) > admissibleSeparation(v,ep)
            | 2*b()*abs(y-yo) > admissibleSeparation(v,ep);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      {
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        t' = 1 & t <= ep & v >= 0
      }@invariant(t>=0, isWellformedDir(),
         (v'=-b() -> v <= old(v) - b()*(t-old(t))),
         (v'=-b() -> (-(t-old(t)) * (2*old(v) - b()*(t-old(t))) * (1+Ud()) <= 2*(x - old(x)) & 2*(x - old(x)) <= (t-old(t)) * (2*old(v) - b()*(t-old(t))) * (1+Ud()))),
         (v'=-b() -> (-(t-old(t)) * (2*old(v) - b()*(t-old(t))) * (1+Ud()) <= 2*(y - old(y)) & 2*(y - old(y)) <= (t-old(t)) * (2*old(v) - b()*(t-old(t))) * (1+Ud()))),
         (v'=0 -> v = old(v)),
         (v'=0 -> x = old(x)),
         (v'=0 -> y = old(y)),
         (v'=0 -> w = old(w)), /* may not be necessary if we remove w=0 from throughout inv */
         (v'=A() -> v <= old(v) + A()*(t-old(t))),
         (v'=A() -> (-(t-old(t)) * (2*old(v) + A()*(t-old(t))) * (1+Ud()) <= 2*(x - old(x)) & 2*(x - old(x)) <= (t-old(t)) * (2*old(v) + A()*(t-old(t))) * (1+Ud()))),
         (v'=A() -> (-(t-old(t)) * (2*old(v) + A()*(t-old(t))) * (1+Ud()) <= 2*(y - old(y)) & 2*(y - old(y)) <= (t-old(t)) * (2*old(v) + A()*(t-old(t))) * (1+Ud())))
       )
      }
    }*@invariant(loopinv())
  ](x - xo)^2 + (y - yo)^2 > 0
End.

Tactic "Proof Theorem 1: Static safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v <= old(v) - b()*t`}, 1);
    diffInvariant({`-t * (2*old(v) - b()*t) * (1+Ud()) <= 2*(x - old(x)) & 2*(x - old(x)) <= t * (2*old(v) - b()*t) * (1+Ud())`}, 1);
    diffInvariant({`-t * (2*old(v) - b()*t) * (1+Ud()) <= 2*(y - old(y)) & 2*(y - old(y)) <= t * (2*old(v) - b()*t) * (1+Ud())`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v <= old(v) + A()*t`}, 1);
    diffInvariant({`-t * (2*old(v) + A()*t) * (1+Ud()) <= 2*(x - old(x)) & 2*(x - old(x)) <= t * (2*old(v) + A()*t) * (1+Ud())`}, 1);
    diffInvariant({`-t * (2*old(v) + A()*t) * (1+Ud()) <= 2*(y - old(y)) & 2*(y - old(y)) <= t * (2*old(v) + A()*t) * (1+Ud())`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`2*b()*abs(x_0-xo)>(1+Ud())*(v_0^2+(A()+b())*(A()*t^2+2*t*v_0))`}, 'L=={`2*b()*abs(x_0-xo)>admissibleSeparation(v_0,ep())`});
    hideR('R=={`2*b()*abs(y-yo)>stopDist(v)`});
    hideL('L=={`1-Ud()<=dx^2+dy^2`});
    hideL('L=={`dx^2+dy^2<=1+Ud()`});
    hideL('L=={`1-Ud()<=dx_0^2+dy_0^2`});
    hideL('L=={`dx_0^2+dy_0^2<=1+Ud()`});
    hideL('L=={`-W()<=w_0`});
    hideL('L=={`w_0<=W()`});
    hideL('L=={`r!=0`});
    hideL('L=={`r*w_0=v_0`});
    hideL('L=={`t_0=0`});
    hideL('L=={`t<=ep()`});
    hideL('L=={`ep()>0`});
    print({`Transformed`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`2*b()*abs(y_0-yo)>(1+Ud())*(v_0^2+(A()+b())*(A()*t^2+2*t*v_0))`}, 'L=={`2*b()*abs(y_0-yo)>admissibleSeparation(v_0,ep())`});
    hideR('R=={`2*b()*abs(x-xo)>stopDist(v)`});
    hideL('L=={`1-Ud()<=dx^2+dy^2`});
    hideL('L=={`dx^2+dy^2<=1+Ud()`});
    hideL('L=={`1-Ud()<=dx_0^2+dy_0^2`});
    hideL('L=={`dx_0^2+dy_0^2<=1+Ud()`});
    hideL('L=={`-W()<=w_0`});
    hideL('L=={`w_0<=W()`});
    hideL('L=={`r!=0`});
    hideL('L=={`r*w_0=v_0`});
    hideL('L=={`t_0=0`});
    hideL('L=={`t<=ep()`});
    hideL('L=={`ep()>0`});
    print({`Transformed`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`2*b()*abs(x-xo_0)>stopDist(v)|2*b()*abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

Tactic "Proof with throughout invariant".
implyR(1) ; throughout({`(v>=0&(1-Ud()<=dx^2+dy^2&dx^2+dy^2<=1+Ud())&(2*b()*abs(x-xo)>(1+Ud())*v^2|2*b()*abs(y-yo)>(1+Ud())*v^2))&t>=0&(a=-b()|v=0&a=0|a=A()&(2*b()*abs(x-xo)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)|2*b()*abs(y-yo)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)))`}, 1) ; <(
  simplify(1) ; smartQE,
  andL(-1) ; hideL(-7=={`t>=0&(a=-b()|v=0&a=0|a=A()&(2*b()*abs(x-xo)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)|2*b()*abs(y-yo)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)))`}) ; andL(-6) ; andL(-7) ; hideL(-7=={`1-Ud()<=dx^2+dy^2&dx^2+dy^2<=1+Ud()`}) ; QE,
  chase(1) ; simplify(1) ; andR(1) ; <(
    prop,
    allR(1) ; implyR(1) ; allR(1) ; allR(1) ; allR(1) ; implyR(1) ; implyR(1) ; orR(1) ; andL(-1) ; andL(-9) ; hideL(-11=={`(1-Ud()<=dx^2+dy^2&dx^2+dy^2<=1+Ud())&(2*b()*abs(x-xo_0)>(1+Ud())*v^2|2*b()*abs(y-yo_0)>(1+Ud())*v^2)`}) ; hideL(-9=={`t>=0&(a=-b()|v=0&a=0|a=A()&(2*b()*abs(x-xo_0)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)|2*b()*abs(y-yo_0)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)))`}) ; smartQE
    ),
  andL('L)* ; orL(-5) ; <(
    allL2R(-5) ; hideL(-5=={`a=-b()`}) ; dC({`t>=old(t)`}, 1) ; <(
      dC({`1-Ud()<=dx^2+dy^2&dx^2+dy^2<=1+Ud()`}, 1) ; <(
        dC({`v<=old(v)-b()*(t-old(t))`}, 1) ; <(
          dC({`-(t-old(t))*(2*old(v)-b()*(t-old(t)))*(1+Ud())<=2*(x-old(x))&2*(x-old(x))<=(t-old(t))*(2*old(v)-b()*(t-old(t)))*(1+Ud())`}, 1) ; <(
            dC({`-(t-old(t))*(2*old(v)-b()*(t-old(t)))*(1+Ud())<=2*(y-old(y))&2*(y-old(y))<=(t-old(t))*(2*old(v)-b()*(t-old(t)))*(1+Ud())`}, 1) ; <(
              dW(1) ; simplify(1) ; implyR(1) ; andR(1) ; <(
                andL('L)* ; orR(1) ; hideL(-22=={`t<=ep()`}) ; hideL(-21=={`dx^2+dy^2<=1+Ud()`}) ; hideL(-20=={`1-Ud()<=dx^2+dy^2`}) ; hideL(-11=={`ep()>0`}) ; hideL(-9=={`dx_0^2+dy_0^2<=1+Ud()`}) ; hideL(-8=={`1-Ud()<=dx_0^2+dy_0^2`}) ; hideL(-7=={`A()>=0`}) ; hideL(-5=={`dx_0^2+dy_0^2<=1+Ud()`}) ; hideL(-3=={`v_0>=0`}) ; hideL(-2=={`1-Ud()<=dx_0^2+dy_0^2`}) ; orL(-3) ; <(
                  hideR(2=={`2*b()*abs(y-yo)>(1+Ud())*v^2`}) ; hideL(-8=={`2*(y-y_0)<=(t-t_0)*(2*v_0-b()*(t-t_0))*(1+Ud())`}) ; hideL(-7=={`-(t-t_0)*(2*v_0-b()*(t-t_0))*(1+Ud())<=2*(y-y_0)`}) ; smartQE,
                  hideR(1=={`2*b()*abs(x-xo)>(1+Ud())*v^2`}) ; hideL(-11=={`2*(x-x_0)<=(t-t_0)*(2*v_0-b()*(t-t_0))*(1+Ud())`}) ; hideL(-10=={`-(t-t_0)*(2*v_0-b()*(t-t_0))*(1+Ud())<=2*(x-x_0)`}) ; smartQE
                  ),
                QE
                ),
              hideL(-6=={`2*b()*abs(x_0-xo)>(1+Ud())*v_0^2|2*b()*abs(y_0-yo)>(1+Ud())*v_0^2`}) ; dI(1)
              ),
            dI(1)
            ),
          dI(1)
          ),
        dI(1)
        ),
      dI(1)
      ),
    orL(-5) ; <(
      andL(-5) ; allL2R(-15) ; hideL(-15=={`a=0`}) ; dC({`t>=old(t)`}, 1) ; <(
        dC({`1-Ud()<=dx^2+dy^2&dx^2+dy^2<=1+Ud()`}, 1) ; <(
          dC({`v=old(v)`}, 1) ; <(
            dC({`x=old(x)`}, 1) ; <(
              dC({`y=old(y)`}, 1) ; <(
                dW(1) ; implyR(1) ; andR(1) ; <(
                  andL('L)* ; allL2R(-17) ; hideL(-17=={`v=v_0`}) ; allL2R(-16) ; hideL(-16=={`x=x_0`}) ; allL2R(-15) ; hideL(-15=={`y=y_0`}) ; simplify(1) ; closeTrue,
                  andR(1) ; <(
                    QE,
                    orR(1) ; orR(2) ; hideR(3=={`0=A()&(2*b()*abs(x-xo)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)|2*b()*abs(y-yo)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v))`}) ; hideR(1=={`0=-b()`}) ; simplify(1) ; QE
                    )
                  ),
                dI(1)
                ),
              dI(1)
              ),
            dI(1)
            ),
          dI(1)
          ),
        dI(1)
        ),
      andL(-5) ; allL2R(-14) ; hideL(-14=={`a=A()`}) ; hideL(-6=={`2*b()*abs(x-xo)>(1+Ud())*v^2|2*b()*abs(y-yo)>(1+Ud())*v^2`}) ; dC({`t>=old(t)`}, 1) ; <(
        dC({`1-Ud()<=dx^2+dy^2&dx^2+dy^2<=1+Ud()`}, 1) ; <(
          dC({`v<=old(v)+A()*(t-old(t))`}, 1) ; <(
            dC({`-(t-old(t))*(2*old(v)+A()*(t-old(t)))*(1+Ud())<=2*(x-old(x))&2*(x-old(x))<=(t-old(t))*(2*old(v)+A()*(t-old(t)))*(1+Ud())`}, 1) ; <(
              dC({`-(t-old(t))*(2*old(v)+A()*(t-old(t)))*(1+Ud())<=2*(y-old(y))&2*(y-old(y))<=(t-old(t))*(2*old(v)+A()*(t-old(t)))*(1+Ud())`}, 1) ; <(
                dW(1) ; implyR(1) ; andL('L)* ; andR(1) ; <(
                  andR(1) ; <(
                    hideL(-13=={`2*b()*abs(x_0-xo)>(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0)|2*b()*abs(y_0-yo)>(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0)`}) ; QE,
                    andR(1) ; <(
                      prop,
                      orR(1) ; hideL(-21=={`dx^2+dy^2<=1+Ud()`}) ; hideL(-20=={`1-Ud()<=dx^2+dy^2`}) ; hideL(-8=={`dx_0^2+dy_0^2<=1+Ud()`}) ; hideL(-7=={`1-Ud()<=dx_0^2+dy_0^2`}) ; hideL(-5=={`dx_0^2+dy_0^2<=1+Ud()`}) ; hideL(-3=={`v_0>=0`}) ; hideL(-2=={`1-Ud()<=dx_0^2+dy_0^2`}) ; orL(-8) ; <(
                        hideL(-9=={`-(t-t_0)*(2*v_0+A()*(t-t_0))*(1+Ud())<=2*(y-y_0)`}) ; hideL(-9=={`2*(y-y_0)<=(t-t_0)*(2*v_0+A()*(t-t_0))*(1+Ud())`}) ; edit({`2*b()*abs(x_0-xo)>(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(t-t_0)^2+2*(t-t_0)*v_0)`}, -8) ; hideR(2=={`2*b()*abs(y-yo)>(1+Ud())*v^2`}) ; hideL(-13=={`t<=ep()`}) ; hideL(-5=={`ep()>0`}) ; smartQE,
                        hideR(1=={`2*b()*abs(x-xo)>(1+Ud())*v^2`}) ; hideL(-13=={`2*(x-x_0)<=(t-t_0)*(2*v_0+A()*(t-t_0))*(1+Ud())`}) ; hideL(-12=={`-(t-t_0)*(2*v_0+A()*(t-t_0))*(1+Ud())<=2*(x-x_0)`}) ; edit({`2*b()*abs(y_0-yo)>(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(t-t_0)^2+2*(t-t_0)*v_0)`}, -8) ; hideL(-13=={`t<=ep()`}) ; hideL(-5=={`ep()>0`}) ; smartQE
                        )
                      )
                    ),
                  andR(1) ; <(
                    QE,
                    orR(1) ; orR(2) ; hideR(1=={`A()=-b()`}) ; hideR(1=={`v=0&A()=0`}) ; simplify(1) ; orR(1) ; orL(-13) ; <(
                      hideR(2=={`2*b()*abs(y-yo)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)`}) ; hideL(-21=={`dx^2+dy^2<=1+Ud()`}) ; hideL(-20=={`1-Ud()<=dx^2+dy^2`}) ; hideL(-8=={`dx_0^2+dy_0^2<=1+Ud()`}) ; hideL(-7=={`1-Ud()<=dx_0^2+dy_0^2`}) ; hideL(-5=={`dx_0^2+dy_0^2<=1+Ud()`}) ; hideL(-3=={`v_0>=0`}) ; hideL(-2=={`1-Ud()<=dx_0^2+dy_0^2`}) ; hideL(-9=={`-(t-t_0)*(2*v_0+A()*(t-t_0))*(1+Ud())<=2*(y-y_0)`}) ; hideL(-9=={`2*(y-y_0)<=(t-t_0)*(2*v_0+A()*(t-t_0))*(1+Ud())`}) ; cut({`(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)+b()*(t-t_0)*(1+Ud())*(A()*(t-t_0)+2*v_0)<=(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0)`}) ; <(
                        edit({`(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)+b()*(t-t_0)*(1+Ud())*(A()*(t-t_0)+2*v_0)<=abbrv((1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0))`}, -15) ; edit({`abbrv((1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v))+b()*(t-t_0)*(1+Ud())*(A()*(t-t_0)+2*v_0)<=abbrv`}, -15) ; hideL(-16=={`abbrv=(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0)`}) ; hideL(-16=={`abbrv_0=(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)`}) ; smartQE,
                        hideR(1=={`2*b()*abs(x-xo)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)`}) ; hideL(-8=={`2*b()*abs(x_0-xo)>(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0)`}) ; QE
                        ),
                      hideR(1=={`2*b()*abs(x-xo)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)`}) ; hideL(-17=={`-(t-t_0)*(2*v_0+A()*(t-t_0))*(1+Ud())<=2*(x-x_0)`}) ; hideL(-17=={`2*(x-x_0)<=(t-t_0)*(2*v_0+A()*(t-t_0))*(1+Ud())`}) ; hideL(-19=={`dx^2+dy^2<=1+Ud()`}) ; hideL(-18=={`1-Ud()<=dx^2+dy^2`}) ; hideL(-8=={`dx_0^2+dy_0^2<=1+Ud()`}) ; hideL(-7=={`1-Ud()<=dx_0^2+dy_0^2`}) ; hideL(-5=={`dx_0^2+dy_0^2<=1+Ud()`}) ; hideL(-3=={`v_0>=0`}) ; hideL(-2=={`1-Ud()<=dx_0^2+dy_0^2`}) ; cut({`(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)+b()*(t-t_0)*(1+Ud())*(A()*(t-t_0)+2*v_0)<=(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0)`}) ; <(
                        edit({`(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)+b()*(t-t_0)*(1+Ud())*(A()*(t-t_0)+2*v_0)<=abbrv((1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0))`}, -15) ; edit({`abbrv((1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v))+b()*(t-t_0)*(1+Ud())*(A()*(t-t_0)+2*v_0)<=abbrv`}, -15) ; hideL(-16=={`abbrv=(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0)`}) ; hideL(-16=={`abbrv_0=(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)`}) ; smartQE,
                        hideR(1=={`2*b()*abs(y-yo)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t)^2+2*(ep()-t)*v)`}) ; hideL(-8=={`2*b()*abs(y_0-yo)>(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0)`}) ; QE
                        )
                      )
                    )
                  ),
                hideL(-13=={`2*b()*abs(x_0-xo)>(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0)|2*b()*abs(y_0-yo)>(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0)`}) ; dI(1)
                ),
              hideL(-13=={`2*b()*abs(x_0-xo)>(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0)|2*b()*abs(y-yo)>(1+Ud())*v_0^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v_0)`}) ; dI(1)
              ),
            dI(1)
            ),
          hideL(-13=={`2*b()*abs(x-xo)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v)|2*b()*abs(y-yo)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v)`}) ; dI(1)
          ),
        hideL(-13=={`2*b()*abs(x-xo)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v)|2*b()*abs(y-yo)>(1+Ud())*v^2+(1+Ud())*(A()+b())*(A()*(ep()-t_0)^2+2*(ep()-t_0)*v)`}) ; dI(1)
        )
      )
    )
  )
End.

End.

Theorem "Theorem 2: Passive safety".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = (v^2 / (2*b()) + V()*v/b()).
  R accelComp(R v) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*(v+V))).
  R admissibleSeparation(R v) = (stopDist(v) + accelComp(v)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      {
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }@invariant(t>=0, isWellformedDir(),
          (-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()),
          (-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()),
          (v'=-b() -> v = old(v) - b()*t),
          (v'=-b() -> (-t * (old(v) - b()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - b()/2*t))),
          (v'=-b() -> (-t * (old(v) - b()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - b()/2*t))),
          (v'=0 -> v = old(v)),
          (v'=0 -> x = old(x)),
          (v'=0 -> y = old(y)),
          (v'=A() -> v = old(v) + A()*t),
          (v'=A() -> (-t * (old(v) + A()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t))),
          (v'=A() -> (-t * (old(v) + A()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t)))
        )
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 2: Passive safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

ArchiveEntry "Corollary 2: Velocity-controlled passive orientation safety".
Functions.
  R ep().      /* time limit for control decisions */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Gamma().   /* Sensor range in radian */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v)   = ( 0 ).
  R stopMargin(R v) = ( stopDist(v) ).
  R accelComp(R v)  = ( ep()*v ).
  R accelMargin(R v)  = ( accelComp(v) + ep()*V() ).
  R admissibleSeparation(R v) = ( stopMargin(v) + accelMargin(v) ).
  R admissibleTurnLength(R v) = ( stopDist(v) + accelComp(v) ).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B isVisible(R) <-> ((.)>0).      /* Indicates whether or not the obstacle is visible for the robot at the decision. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & Gamma() > 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & beta = 0
    & r != 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & r != 0
    & (v>0 -> ( (abs(x-xo) > stopMargin(v) | abs(y-yo) > stopMargin(v))
              | (!isVisible(visDeg) & abs(beta) + stopDist(v)/abs(r) < Gamma() )) )
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
  R beta. /* Angle that the robot traveled since it last chose a new curve */
  R visDeg. /* Indicates the "degree" to which the obstacle is visible to the robot (input to isVisible) */
End.

Problem.
  assumptions() -> [
      {
        {
        /* obstacle control */
        {
          vxo := *;
          vyo := *;
          ?vxo^2+vyo^2 <= V()^2;
        }

        /* robot control */
        {
           /* brake on current curve. If the velocity is zero this just means that the robot remains stopped */
           {v := 0; w := 0;}
        ++ /* or choose a new safe curve */
           {v := *;
            beta := 0;
            r :=*; ?r!=0;

            /* measure obstacle position and whether or not it is visible to the robot */
            xo := *; yo := *; visDeg := *;
            ?(isVisible(visDeg) ->
               ( abs(x-xo) > admissibleSeparation(v)
               | abs(y-yo) > admissibleSeparation(v)) );
            ?admissibleTurnLength(v) < Gamma()*abs(r);
            }
        }

        /* Reset the clocks */
        t := 0;
        /* Set w according to physics (rigid body motion) */
        w :=*; ?w*r = v;
        }

        {x' = v * dx, y' = v * dy, dx' = -w * dy, dy' = w * dx, beta'=w,
                      xo' = vxo, yo' = vyo, t' = 1 & (t <= ep & v >= 0)}
      }*
    ] (v > 0 -> ((x - xo)^2 + (y - yo)^2 > 0 | (!isVisible(visDeg) & (abs(beta) < Gamma()))) )
End.

Tactic "Proof Corollary 2: Velocity-controlled passive orientation safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`beta = old(beta)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`beta = old(beta) + t*v/r`}, 1);
    diffInvariant({`-t * v <= x - old(x) & x - old(x) <= t * v`}, 1);
    diffInvariant({`-t * v <= y - old(y) & y - old(y) <= t * v`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v_0>0->((abs(x-xo_0)>stopMargin(v_0)|abs(y-yo_0)>stopMargin(v_0))|!isVisible(visDeg_0)&abs(beta_0)+stopDist(v_0)/abs(r_0) < Gamma())`});
      unfold;
      dia; dw;
      print({`Acceleration arithmetic`});
      implyR(1) ; andL('L)* ; simplify(1); implyR(1) ; orR(1) ; orR(1) ;
      implyL('L=={`isVisible(visDeg) -> ( abs(x_0-xo_0) > admissibleSeparation(v) | abs(y_0-yo_0) > admissibleSeparation(v))`}) ; <(
        hideR('R=={`abs(x-xo)>stopMargin(v)`}) ; hideR('R=={`abs(y-yo)>stopMargin(v)`}) ; fullSimplify ; andR(1) ; doall(smartQE)
        ,
        print({`Acc Distance`});
        hideL('L=={`admissibleTurnLength(v) < Gamma()*abs(r)`}) ;
        hideR('R=={`visDeg<=0 & abs(beta) + stopDist(v)/abs(r) < Gamma()`});
        hideL('L=={`r_0!=0`});
        hideL('L=={`vxo^2+vyo^2<=V()^2`});
        hideL('L=={`dx^2+dy^2=1`});
        hideL('L=={`Gamma()>0`});
        hideL('L=={`beta_0=0`});
        hideL('L=={`w*r=v`});
        hideL('L=={`beta=beta_0+t*v/r`});
        orL('L=={`abs(x_0-xo_0)>admissibleSeparation(v) | abs(y_0-yo_0)>admissibleSeparation(v)`}); <(
          fullSimplify ; smartQE
          ,
          fullSimplify ; smartQE
        )
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 3: Passive Friendly Safety".
Functions.
  R ep().      /* time limit for control decisions */
  R tau().     /* time limit for obstacle reaction */
  R b().       /* minimum braking capability of the robot */
  R bo().      /* obstacle brakes */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R friendlyMargin(R v) = ( v^2/(2*bo()) + tau()*v ).
  R stopDist(R v) = (v^2 / (2*b()) + V()*v/b()).
  R accelComp(R v) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*(v+V))).
  R admissibleSeparation(R v) = (stopDist(v) + friendlyMargin(V()) + accelComp(v)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & tau() >= 0
    & bo() > 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (abs(x-xo) > friendlyMargin(V()) | abs(y-yo) > friendlyMargin(V()))
    & vxo^2+vyo^2<=V()^2
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v)+friendlyMargin(V()) | abs(y-yo) > stopDist(v)+friendlyMargin(V()))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R vo.   /* refined obstacle: speed, acceleration, and direction */
  R ao.
  R dxo.
  R dyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V()^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep() & v >= 0
      }
    }*@invariant(loopinv())
  ](  (v>0 -> (x - xo)^2 + (y - yo)^2 > (friendlyMargin(V()))^2)                     /* robot ensures friendly margin */
    & (  0<=vo & vo^2=vxo^2+vyo^2 & dxo*vo=vxo & dyo*vo=vyo                                      /* obstacle can stop */
       & (x - xo)^2 + (y - yo)^2 > (friendlyMargin(V()))^2
       ->
        <{
          ao := *; ?-bo() <= ao & vo + ao*ep() <= V();
          t := 0;
          {xo'=vo*dxo, yo'=vo*dyo, vo'=ao, t'=1 & vo>=0 & t<=ep()}
         }*>((x-xo)^2 + (y-yo)^2 > 0 & vo=0))
  )
End.

Tactic "Proof Theorem 3: Passive Friendly Safety".
  tactic obstacleCanStop as (
    unfold ; cut({`vo=0|dxo^2+dyo^2=1`}) ; <(
      cut({`vo<=V()`}) ; <(
        hideL('L=={`vo^2=vxo^2+vyo^2`}) ; hideL('L=={`vxo^2+vyo^2<=V()^2`});
        con({`v`}, {`(vo=0|dxo^2+dyo^2=1)&bo()>0&ep()>0&(x-xo)^2+(y-yo)^2>(vo^2/(2*bo()))^2&0<=vo&vo<=V()&(v*ep()*bo()>=vo|vo=0)`}, 1); <(
          QE,
          QE,
          unfold ; existsR({`-bo()`}, 1) ; unfold ; <(
            fullSimplify ; closeTrue
            ,
            solve(1) ; existsR({`min((vo/bo(),ep()))`}, 1) ; abbrv({`min((vo/bo(),ep()))`}, {`minT`}) ; minmax(-14.1) ;
            orL('L=={`vo=0|dxo^2+dyo^2=1`}) ; doall(QE)
            ,
            QE
          )
        )
        ,
        hideR(1) ; QE
      ),
      hideR(1) ; QE
    )
  );

  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+fm+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+fm+(A()/b()+1)*(A()/2*ep()^2+ep()*(v_0+V()))`});
    hideR('R=={`abs(y-yo)>stopDist(v)+fm`});
    smartQE; /* needs QE({`Mathematica`}) */
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+fm+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+fm+(A()/b()+1)*(A()/2*ep()^2+ep()*(v_0+V()))`});
    hideR('R=={`abs(x-xo)>stopDist(v)+fm`});
    smartQE; /* needs QE({`Mathematica`}) */
    print({`Proved acc arithmetic`})
  );

  tactic robotAlwaysStops as (
    loop({`loopinv()`}, 1); <(
      print({`Base case...`}); smartQE; print({`Base case done`})
      ,
      print({`Use case...`}); smartQE; print({`Use case done`})
      ,
      print({`Induction step`}); unfold; <(
        print({`Braking branch`});
        abbrv({`(V()^2/(2*bo())+tau()*V())`}, {`fm`});
        cut({`fm>=0`}); <(hideL('L=={`fm=(V()^2/(2*bo())+tau()*V())`}), hideR(1); QE);
        dib; dw; prop; doall(smartQE); print({`Braking branch done`})
        ,
        print({`Stopped branch`});
        abbrv({`(V()^2/(2*bo())+tau()*V())`}, {`fm`});
        cut({`fm>=0`}); <(hideL('L=={`fm=(V()^2/(2*bo())+tau()*V())`}), hideR(1); QE);
        di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
        ,
        print({`Acceleration branch`});
        hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v)+friendlyMargin(V()) | abs(y-yo_0)>stopDist(v)+friendlyMargin(V())`});
        abbrv({`(V()^2/(2*bo())+tau()*V())`}, {`fm`});
        cut({`fm>=0`}); <(hideL('L=={`fm=(V()^2/(2*bo())+tau()*V())`}), hideR(1); QE);
        dia; dw;
        prop; <(
          xAccArith,
          yAccArith
        );
        print({`Acceleration branch done`})
      );
      print({`Induction step done`})
    );
    done;
    print({`Robot done`})
  );

  implyR(1) ; andL('L)* ; boxAnd(1) ; andR(1) ; <(
    robotAlwaysStops
    ,
    MR({`vxo^2+vyo^2<=V()^2`},1); <(
      loop({`vxo^2+vyo^2<=V()^2`}, 1) ; <(
        closeId,
        closeId,
        composeb(1) ; GV(1.1) ; composeb(1) ; GV(1.1) ; master
      )
      ,
      andL('L)* ;
      hideL('L=={`A()>=0`});
      hideL('L=={`b()>0`});
      obstacleCanStop
    )

  )
End.

End.

Theorem "Theorem 4: Passive orientation safety".
Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Gamma().   /* Sensor range in radian */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v)   = ( v^2 / (2*b()) ).
  R stopMargin(R v) = ( stopDist(v) + V()*v/b() ).
  R accelComp(R v)  = ( (A()/b() + 1) * (A()/2 * ep()^2 + ep()*v) ).
  R accelMargin(R v)  = ( accelComp(v) + (A()/b() + 1)*ep()*V() ).
  R admissibleSeparation(R v) = ( stopMargin(v) + accelMargin(v) ).
  R admissibleTurnLength(R v) = ( stopDist(v) + accelComp(v) ).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B isVisible(R) <-> ((.)>0).      /* Indicates whether or not the obstacle is visible for the robot at the decision. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & Gamma() > 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & beta = 0
    & r != 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & r != 0
    & (v>0 -> ( (abs(x-xo) > stopMargin(v) | abs(y-yo) > stopMargin(v))
              | (!isVisible(visDeg) & abs(beta) + stopDist(v)/abs(r) < Gamma() )) )
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
  R beta. /* Angle that the robot traveled since it last chose a new curve */
  R visDeg. /* Indicates the "degree" to which the obstacle is visible to the robot (input to isVisible) */
End.

Problem.
  assumptions() -> [
      {
        {
        /* obstacle control */
        {
          vxo := *;
          vyo := *;
          ?vxo^2+vyo^2 <= V()^2;
        }

        /* robot control */
        {
           /* brake on current curve. If the velocity is zero this just means that the robot remains stopped */
           {a := -b();}
        ++ /* When we are stopped, both translational and rotational acceleration are 0 */
           {?v=0; a := 0; w := 0;}
        ++ /* or choose a new safe curve */
           {a := A();
            beta := 0;
            r :=*; ?r!=0;

            /* measure obstacle position and whether or not it is visible to the robot */
            xo := *; yo := *; visDeg := *;
            ?(isVisible(visDeg) ->
               ( abs(x-xo) > admissibleSeparation(v)
               | abs(y-yo) > admissibleSeparation(v)) );
            ?admissibleTurnLength(v) < Gamma()*abs(r);
            }
        }

        /* Reset the clocks */
        t := 0;
        /* Set w according to physics (rigid body motion) */
        w :=*; ?w*r = v;
        }

        {x' = v * dx, y' = v * dy, dx' = -w * dy, dy' = w * dx, v' = a, w' = a/r, beta'=w,
                      xo' = vxo, yo' = vyo, t' = 1 & (t <= ep & v >= 0)}
      }*
    ] (v > 0 -> ((x - xo)^2 + (y - yo)^2 > 0 | (!isVisible(visDeg) & (abs(beta) < Gamma()))) )
End.

Tactic "Proof Theorem 4: Passive orientation safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1);
    diffInvariant({`w*r=v`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`beta = old(beta) + t/r*(v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`beta = old(beta)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`beta = old(beta) + t/r*(v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    hideR('R=={`abs(y-yo)>stopMargin(v)`});
    hideL('L=={`-t*(v-A()/2*t)<=y-y_0`});
    hideL('L=={`y-y_0<=t*(v-A()/2*t)`});
    hideL('L=={`-t*V()<=yo-yo_0`});
    hideL('L=={`yo-yo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+((A()/b()+1)*(A()/2*t^2+t*v_0)+(A()/b()+1)*t*V())`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    hideR('R=={`abs(x-xo)>stopMargin(v)`});
    hideL('L=={`-t*(v-A()/2*t)<=x-x_0`});
    hideL('L=={`x-x_0<=t*(v-A()/2*t)`});
    hideL('L=={`-t*V()<=xo-xo_0`});
    hideL('L=={`xo-xo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+((A()/b()+1)*(A()/2*t^2+t*v_0)+(A()/b()+1)*t*V())`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop ; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0->((abs(x-xo_0)>stopMargin(v)|abs(y-yo_0)>stopMargin(v))|!isVisible(visDeg_0)&abs(beta_0)+stopDist(v)/abs(r_0) < Gamma())`});
      unfold;
      dia; dw;
      print({`Acceleration arithmetic`});
      implyR(1) ; andL('L)* ; fullSimplify ; implyR(1) ; orR(1) ; orR(1) ;
      implyL('L=={`isVisible(visDeg) -> ( abs(x_0-xo_0) > admissibleSeparation(v_0) | abs(y_0-yo_0) > admissibleSeparation(v_0))`}) ; <(
        hideR('R=={`abs(x-xo)>stopMargin(v)`}) ; hideR('R=={`abs(y-yo)>stopMargin(v)`}) ; andR(1) ; doall(smartQE)
        ,
        print({`Acc Distance`});
        hideL('L=={`admissibleTurnLength(v_0) < Gamma()*abs(r)`}) ;
        hideR('R=={`visDeg<=0 & abs(beta) + stopDist(v)/abs(r) < Gamma()`});
        hideL('L=={`r_0!=0`});
        hideL('L=={`vxo^2+vyo^2<=V()^2`});
        hideL('L=={`dx^2+dy^2=1`});
        hideL('L=={`Gamma()>0`});
        hideL('L=={`beta_0=0`});
        hideL('L=={`w*r=v`});
        hideL('L=={`beta=beta_0+t/r*(v-A()/2*t)`});
        orL('L=={`abs(x_0-xo_0)>admissibleSeparation(v_0) | abs(y_0-yo_0)>admissibleSeparation(v_0)`}); <(
          xAccArith
          ,
          yAccArith
        )
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 5: Passive safety with actual acceleration".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = (v^2 / (2*b()) + V()*v/b()).
  R accelComp(R v, R a) = ((a/b() + 1) * (a/2 * ep()^2 + ep()*(v+V))).
  R admissibleSeparationG(R v, R a) = (stopDist(v) + accelComp(v,a)).
  R admissibleSeparationL(R v, R a) = (-v^2/(2*a)-V*v/a).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := *; ?-b<=a & a<=A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            if (v+a*ep>=0) { ?abs(x-xo) > admissibleSeparationG(v,a) | abs(y-yo) > admissibleSeparationG(v,a); }
            else           { ?abs(x-xo) > admissibleSeparationL(v,a) | abs(y-yo) > admissibleSeparationL(v,a); }
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 5: Passive safety with actual acceleration".
  tactic diall as (
    diffInvariant({`t>=0`}, 'R);
    diffInvariant({`isWellformedDir()`}, 'R);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 'R);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 'R)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 'R);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 'R);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 'R)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 'R);
    diffInvariant({`x = old(x)`}, 'R);
    diffInvariant({`y = old(y)`}, 'R)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + a*t`}, 'R);
    diffInvariant({`-t * (v - a/2*t) <= x - old(x) & x - old(x) <= t * (v - a/2*t)`}, 'R);
    diffInvariant({`-t * (v - a/2*t) <= y - old(y) & y - old(y) <= t * (v - a/2*t)`}, 'R)
  );

  tactic dw as (andL('L)*; dW('R));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    ?(transform({`abs(x_0-xo_0)>stopDist(v_0) + (a/b+1)*(a/2*t^2 + t*(v_0+V))`}, 'L=={`abs(x_0-xo_0)>stopDist(v_0) + (a/b+1)*(a/2*ep^2 + ep*(v_0+V))`}));
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    ?(transform({`abs(y_0-yo_0)>stopDist(v_0) + (a/b+1)*(a/2*t^2 + t*(v_0+V))`}, 'L=={`abs(y_0-yo_0)>stopDist(v_0) + (a/b+1)*(a/2*ep^2 + ep*(v_0+V))`}));
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Free driving non-stopping branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Free driving non-stopping branch done`})
      ,
      print({`Free driving stopping branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Free driving stopping branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 6: Passive safety despite location uncertainty".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Dp().      /* maximum location uncertainty */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = (v^2 / (2*b()) + V()*v/b()).
  R accelComp(R v) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*(v+V())) + Dp()).
  R admissibleSeparation(R v) = (stopDist(v) + accelComp(v)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & Dp() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R mx.   /* robot measured position: x */
  R my.   /* robot measured position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* locate */
        {
          mx := *; my := *;
          ?(mx-x)^2+(my-y)^2 <= Dp()^2;
        }
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(mx-xo) > admissibleSeparation(v)
            | abs(my-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 6: Passive safety despite location uncertainty".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(mx-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))+Dp()`}, 'L=={`abs(mx-xo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(my-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))+Dp()`}, 'L=={`abs(my-yo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 7: Passive safety despite actuator perturbation".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Da().      /* maximum actuator perturbation 0< Da <= 1 (robot will not loose brakes entirely) */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = ( v^2 / (2*(b()*Da())) + V()*v/(b()*Da()) ).
  R accelComp(R v) = ( (A()/(b()*Da()) + 1) * (A()/2 * ep()^2 + ep()*(v+V())) ).
  R admissibleSeparation(R v) = (stopDist(v) + accelComp(v)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & 0 < Da() & Da() <= 1
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot control choice: translational acceleration */
  R da.   /* robot actuator disturbance */
  R acc.  /* robot actual translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
        /* actuator perturbation */
        {
          da := *; ?(Da<=da & da<=1); acc := da*a;
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = acc,      /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = acc/r, /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 7: Passive safety despite actuator perturbation".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v <= old(v) - (b()*Da())*t`}, 1);
    diffInvariant({`-t * (old(v) - (b()*Da())/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - (b()*Da())/2*t)`}, 1);
    diffInvariant({`-t * (old(v) - (b()*Da())/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - (b()*Da())/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v <= old(v) + A()*t`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t)`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*(b()*Da()))+V()*v_0/(b()*Da())+(A()/(b()*Da())+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    abbrv({`b*Da()`},{`actB`}); cut({`actB>0`}); <(hideL('L=={`actB=b*Da()`}), hideR(1); smartQE);
    hideL('L=={`t<=ep()`});
    hideL('L=={`b()>0`});
    hideL('L=={`ep()>0`});
    hideL('L=={`0<Da()`});
    hideL('L=={`Da()<=1`});
    hideL('L=={`Da()<=da`});
    hideL('L=={`da<=1`});
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=y-y_0`});
    hideL('L=={`y-y_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=yo-yo_0`});
    hideL('L=={`yo-yo_0<=t*V()`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*(b()*Da()))+V()*v_0/(b()*Da())+(A()/(b()*Da())+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    abbrv({`b*Da()`},{`actB`}); cut({`actB>0`}); <(hideL('L=={`actB=b*Da()`}), hideR(1); smartQE);
    hideL('L=={`t<=ep()`});
    hideL('L=={`b()>0`});
    hideL('L=={`ep()>0`});
    hideL('L=={`0<Da()`});
    hideL('L=={`Da()<=1`});
    hideL('L=={`Da()<=da`});
    hideL('L=={`da<=1`});
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=x-x_0`});
    hideL('L=={`x-x_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=xo-xo_0`});
    hideL('L=={`xo-xo_0<=t*V()`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; abbrv({`b*Da()`},{`actB`}); cut({`actB>0`}); <(hideL('L=={`actB=b*Da()`}), hideR(1); smartQE); prop; doall(print({`Braking QE`}); smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 8: Passive safety despite velocity uncertainty".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Dv().      /* maximum velocity uncertainty */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = ( v^2 / (2*b()) + V()*v/b() ).
  R accelComp(R v) = ( (A()/b() + 1) * (A()/2 * ep()^2 + ep()*(v+V())) ).
  R admissibleSeparation(R v) = (stopDist(v) + accelComp(v)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & Dv() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R mv.   /* robot measured velocity */
  R a.    /* robot control choice: translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* sense */
        {
          mv := *; ?0<=mv & v-Dv()<=mv & mv<=v+Dv();
        }
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(mv+Dv())
            | abs(y-yo) > admissibleSeparation(mv+Dv());
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 8: Passive safety despite velocity uncertainty".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v <= old(v) - b()*t`}, 1);
    diffInvariant({`-t * (old(v) - b()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - b()/2*t)`}, 1);
    diffInvariant({`-t * (old(v) - b()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v <= old(v) + A()*t`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t)`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=y-y_0`});
    hideL('L=={`y-y_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=yo-yo_0`});
    hideL('L=={`yo-yo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(mv+Dv())`});
    hideL('L=={`t<=ep()`});
    hideL('L=={`ep()>0`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=x-x_0`});
    hideL('L=={`x-x_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=xo-xo_0`});
    hideL('L=={`xo-xo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(mv+Dv())`});
    hideL('L=={`t<=ep()`});
    hideL('L=={`ep()>0`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(print({`Braking QE`}); smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 9: Passive safety for asynchronous controllers".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = (v^2 / (2*b()) + V()*v/b()).
  R accelComp(R v) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*(v+V))).
  R admissibleSeparation(R v) = (stopDist(v) + accelComp(v)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).

  /* todo invariant lookup for inner fails */
  B innerloopinv() <-> (
    0<=t & t<=ep()
    & v >= 0
    & isWellformedDir()
    & -t*V() <= xo - old(xo) & xo - old(xo) <= t*V() /* todo: old(.) support in loop invariants */
    & -t*V() <= yo - old(yo) & yo - old(yo) <= t*V()
    & -t * (v - a/2*t) <= x - old(x) & x - old(x) <= t * (v - a/2*t)
    & -t * (v - a/2*t) <= y - old(y) & y - old(y) <= t * (v - a/2*t)
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        };
        /* dynamics */
        { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
          dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
          xo' = vxo, yo' = vyo,                    /* obstacle moves */
          t' = 1 & t <= ep & v >= 0
        }
      }*@invariant(innerloopinv())
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 9: Passive safety for asynchronous controllers".
  tactic diall as (
    diffInvariant({`t>=old(t)`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-(t-old(t))*V() <= xo - old(xo) & xo - old(xo) <= (t-old(t))*V()`}, 1);
    diffInvariant({`-(t-old(t))*V() <= yo - old(yo) & yo - old(yo) <= (t-old(t))*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*(t-old(t))`}, 1);
    diffInvariant({`-(t-old(t)) * (v + b()/2*(t-old(t))) <= x - old(x) & x - old(x) <= (t-old(t)) * (v + b()/2*(t-old(t)))`}, 1);
    diffInvariant({`-(t-old(t)) * (v + b()/2*(t-old(t))) <= y - old(y) & y - old(y) <= (t-old(t)) * (v + b()/2*(t-old(t)))`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*(t-old(t))`}, 1);
    diffInvariant({`-(t-old(t)) * (v - A()/2*(t-old(t))) <= x - old(x) & x - old(x) <= (t-old(t)) * (v - A()/2*(t-old(t)))`}, 1);
    diffInvariant({`-(t-old(t)) * (v - A()/2*(t-old(t))) <= y - old(y) & y - old(y) <= (t-old(t)) * (v - A()/2*(t-old(t)))`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic ghosts as (
    discreteGhost({`v`}, 1) ; discreteGhost({`x`}, 1) ; discreteGhost({`y`}, 1) ; discreteGhost({`xo`}, 1) ;
    discreteGhost({`yo`}, 1) ; (assignEquality(1) ; allR2L('Llast))*5
  );

  tactic innerUseCase as (
    andR(1) ; <(
    prop,
    andR(1) ; <(
      prop,
      implyR(1) ; orR(1) ; implyL('L=={`v_0>0 -> abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)`}) ; <(
        QE,
        orL('L=={`abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)`}) ; <(
          hideR('R=={`abs(y-yo) > stopDist(v)`}); smartQE,
          hideR('R=={`abs(x-xo) > stopDist(v)`}); smartQE
          )
        )
      )
    )
  );

  tactic brakingInnerLoop as (
    ghosts;
    loop({`0<=t&t<=ep()&v>=0&dx^2+dy^2=1&v=v_0-b()*t&-t*V()<=xo-xo_0&xo-xo_0<=t*V()&-t*V()<=yo-yo_0&yo-yo_0<=t*V()&-t*(v+b()/2*t)<=x-x_0&x-x_0<=t*(v+b()/2*t)&-t*(v+b()/2*t)<=y-y_0&y-y_0<=t*(v+b()/2*t)`}, 1) ; <(
      QE,
      innerUseCase,
      unfold;
      hideL('L=={`v_0>0 -> abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)`});
      dib; dw; unfold; doall(smartQE)
    )
  );

  tactic stoppedInnerLoop as (
    ghosts;
    loop({`0<=t&t<=ep()&v>=0&dx^2+dy^2=1&v=v_0&-t*V()<=xo-xo_0&xo-xo_0<=t*V()&-t*V()<=yo-yo_0&yo-yo_0<=t*V()&x=x_0&y=y_0`}, 1) ; <(
      QE,
      innerUseCase,
      unfold;
      hideL('L=={`v_0>0 -> abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)`});
      di0; dw; unfold; doall(smartQE)
    )
  );

  tactic accInnerLoop as (
    hideL('L=={`v>0 -> abs(x-xo_0) > stopDist(v) | abs(y-yo_0) > stopDist(v)`}) ;
    ghosts;
    loop({`0<=t&t<=ep()&v>=0&dx^2+dy^2=1&v=v_0+A()*t&-t*V()<=xo-xo_0&xo-xo_0<=t*V()&-t*V()<=yo-yo_0&yo-yo_0<=t*V()&-t*(v-A()/2*t)<=x-x_0&x-x_0<=t*(v-A()/2*t)&-t*(v-A()/2*t)<=y-y_0&y-y_0<=t*(v-A()/2*t)`}, 1) ; <(
      QE,
      andR(1) ; <(
        prop,
        andR(1) ; <(
          prop,
          implyR(1) ; orR(1) ;
          orL('L=={`abs(x_0-xo_0) > admissibleSeparation(v_0) | abs(y_0-yo_0) > admissibleSeparation(v_0)`}); <(
            transform({`abs(x_0-xo_0) > v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
            hideR('R=={`abs(y-yo) > stopDist(v)`}); smartQE
            ,
            transform({`abs(y_0-yo_0) > v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
            hideR('R=={`abs(x-xo) > stopDist(v)`}); smartQE
          )
        )
      ),
      unfold; hideL('L=={`abs(x_0-xo_0) > admissibleSeparation(v_0) | abs(y_0-yo_0) > admissibleSeparation(v_0)`});
      dia; dw; unfold; doall(smartQE)
    )
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); brakingInnerLoop; print({`Braking branch done`})
      ,
      print({`Stopped branch`}); stoppedInnerLoop; print({`Stopped branch done`})
      ,
      print({`Acceleration branch`}); accInnerLoop; print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 11: Reach waypoint".

/*
 *	Robot must stop within distance delta at goal.
 *
 *  Robot
 * 	- must stop within distance delta of goal
 *  - can only drive straight and forward
 *  - ensures progress towards goal
 *
 *  Liveness property:
 *  - Robot can stop at goal
 *
 */

Definitions.
	R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R GDelta().	 /* goal area size */
	R Vmax().    /* robot cannot go faster than this */

	R waypointStartDist(R xg) = ( xg-GDelta() ).
	R waypointEndDist(R xg)   = ( xg+GDelta() ).

  R minV() = ( A()*ep() ).

	R stopDist(R v) = ( v^2/(2*b()) ).
	R accComp(R v)  = ( (A()/b() + 1)*(A()/2*ep()^2 + ep()*v) ).

	B bounds() <-> (                                                                     /* Bounds for global constants */
      A() > 0                                                                                       /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & Vmax() >= 2*A()*ep()
    & GDelta() > Vmax()*ep() + Vmax()^2/(2*b())                            /* waypoint is large enough that robot can
                                                                                  start driving and still stop inside */
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    vr = 0
    & xr < waypointStartDist(xg)
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

	B loopinv() <-> (
	  0 <= vr & vr <= Vmax & xr + stopDist(vr) < waypointEndDist(xg)
	).

	HP ctrl ::= {
      ar := -b();
   ++ ?vr = 0; ar := 0;
   ++ ?xr + stopDist(vr) + accComp(vr) < waypointEndDist(xg) & vr+A()*ep()<=Vmax(); ar := A();
   ++ ?xr <= waypointStartDist(xg) & vr <= Vmax(); ar := *; ?-b() <= ar & ar <= (Vmax()-vr)/ep() & ar <= A();
	}.

	HP dyn ::= { {xr' = vr, vr' = ar, t' = 1 & t <= ep() & vr >= 0} }.

	HP dwwp ::= { { { ctrl; t:=0; } dyn; }*@invariant(loopinv()) }.
End.

ProgramVariables.
	R xr.		/* robot position: x */
	R vr.		/* robot translational velocity */
	R ar.		/* robot translational acceleration */
	R xg.		/* goal position */
	R t.		/* control cycle time */
End.

Problem.
  assumptions()
	  ->
	  /* safety */
	  [ dwwp; ] (xr < waypointEndDist(xg))
		&
		/* liveness */
		< dwwp; >(waypointStartDist(xg) < xr)
End.

Tactic "Proof Theorem 11: Reach waypoint".
  implyR(1) ; andL('L)* ; andR(1) ; <(
    master,
    iterated(1) ; orR(1) ; composed(2) ; composed(2) ; choiced(2) ; orR(2) ; hideR(2) ; choiced(2) ; orR(2) ;
    hideR(2) ; choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; andR(2); <(
      QE,
      composed(2) ; randomd(2) ; existsR({`min(((Vmax()-vr)/ep(),A()))`}, 2) ; testd(2) ; andR(2) ; <(
        QE,
        assignd(2) ; solve(2) ; existsR({`ep()`}, 2) ; andR(2) ; <(
          QE,
          andR(2) ; <(
            QE,
            existsR({`ar*ep()+vr_1`}, 2) ; simplify(2) ;
            existsR({`ar/2*ep()^2+vr_1*ep()+xr_1`}, 2) ; simplify(2) ;
            con({`v`}, {`Vmax()>0&A()>0&b()>0&ep()>0&0 < vr&vr<=Vmax()&xg-GDelta() < xr+v*ep()*vr`}, 2) ; <(
              QE,
              QE,
              composed(1) ; composed(1) ; cut({`xr<=xg-GDelta()|xg-GDelta() < xr`}) ; <(
                orL('L=={`xr<=xg-GDelta()|xg-GDelta() < xr`}) ; <(
                  choiced(1) ; orR(1) ; hideR(1) ; choiced(1) ; orR(1) ; hideR(1) ; choiced(1) ; orR(1) ;
                  hideR(1) ; composed(1) ; testd(1) ; andR(1) ; <(
                    master,
                    composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
                      QE,
                      assignd(1) ; solve(1) ; QE({`Mathematica`})
                      )
                    ),
                  choiced(1) ; orR(1) ; hideR(2) ; assignd(1) ; assignd(1) ; solve(1) ; QE({`Mathematica`})
                  ),
                hideR(1) ; QE
                )
              )
            )
          )
        )
      )
    )
End.

End.

Theorem "Theorem 12: Cross intersection".

/*
 *	Robot must safely cross an intersection.
 *
 *  Robot
 * 	- must cross intersection safely
 *  - can only drive straight and forward
 *  - ensures progress towards intersection
 *
 *  Obstacle
 *  - Drives forward with minimum speed (does not block intersection)
 *
 *  Intersection
 *  - At position 0 (on both the robot's and the obstacle's path)
 *
 *  Liveness property:
 *  - Robot can cross intersection
 *
 *  Safety property:
 *  - Robot and obstacle are not at the intersection at the same time
 *
 */

Definitions.
	R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
	R Vmin().    /* obstacle minimum speed */
	R ixr() = ( 0 ). /* position of intersection on path of robot */
	R ixo() = ( 0 ). /* position of intersection on path of obstacle */

	R minV() = ( A()*ep() ).

	R stopDist(R v) = ( v^2/(2*b()) ).
	R accComp(R v)  = ( (A()/b() + 1)*(A()/2*ep()^2 + ep()*v) ).

	B OAfterX(R xo) <-> ( xo>ixo() ).
	B RAfterX(R x) <-> ( x>ixr() ).

	B bounds() <-> (                                                                     /* Bounds for global constants */
      A() > 0                                                                                       /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & Vmin() > 0
  ).
  B initialState() <-> (                                                   /* Somewhere before intersection initially */
    vr = 0
    & vo>=Vmin()
    & xr < ixr()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

	B loopinv() <-> (
	  0 <= vr & Vmin()<=vo & (RAfterX(xr) | OAfterX(xo) | xr + stopDist(vr) < ixr() |
	    (vr>0 & ( xo+vo*(ixr()-xr)/vr+A/2*((ixr()-xr)/vr)^2 < ixo()
              | ixo() < xo + Vmin()*(ixr()-xr)/vr))
    )
	).

	HP obstacle ::= { ao := *; ?-b()<=ao&ao<=A(); }.

	HP robot ::= {
    if (RAfterX(xr) | OAfterX(xo)) {
      ar := *; ?-b()<=ar&ar<=A();
    } else { if (/*PassFaster*/ vr>0 & ( xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()
                                       | ixo() < xo + Vmin()*(ixr()-xr)/(vr+A()*ep()) ) ) {
      ar := *; ?0<=ar&ar<=A();
    } else { if (/*PassCoast*/ vr>0 & ixo() < xo + Vmin()*(ixr()-xr)/vr) {
      ar := 0;
    } else {         /* 1D Model 3 */
        ar := -b();
     ++ ?vr = 0; ar := 0;
     ++ ?xr + stopDist(vr) + accComp(vr) < ixr(); ar := A();
    }}}
	}.

	HP dyn ::= { {xr' = vr, vr' = ar, xo'=vo, vo'=ao, t' = 1 & t <= ep() & vr >= 0 & vo>=Vmin() } }.

	HP dwcx ::= {
	  {	obstacle;
      { robot; t := 0; }
      dyn;
    }*@invariant(loopinv())
	}.
End.

ProgramVariables.
	R xr.		/* robot position: x */
	R vr.		/* robot translational velocity */
	R ar.		/* robot translational acceleration */
	R xo.		/* obstacle position */
	R vo.   /* obstacle velocity */
	R ao.   /* obstacle acceleration */
	R t.		/* control cycle time */
End.

Problem.
  assumptions()
	  ->
	  /* safety */
	  [ dwcx; ](xr=ixr() -> xo!=ixo())
		&
		/* liveness */
		< dwcx; >(RAfterX(xr))
End.

Tactic "Proof Theorem 12: Cross intersection (single convergence condition)".
/* some of the QE need QE({`Mathematica`}) */
  implyR(1) ; andR(1) ; <(
  loop({`0<=vr&Vmin()<=vo&(xr>0|xo>0|xr+vr^2/(2*b()) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr))`}, 1) ; <(
    QE,
    QE,
    composeb(1) ; composeb(1.1) ; solve(1.1.1) ; chase(1) ; allR(1) ; implyR(1) ; andL(-1) ; andL(-7) ; andR(1) ; <(
      implyR(1) ; allR(1) ; implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; orL(-9) ; <(
        fullSimplify ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            orR(1) ; hideR(2) ; QE
            )
          ),
        fullSimplify ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            orR(1) ; orR(2) ; hideR(3) ; hideR(1) ; QE
            )
          )
        ),
      implyR(1) ; andR(1) ; <(
        implyR(1) ; andL(-10) ; fullSimplify ; allR(1) ; implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            orR(1) ; orR(2) ; orR(3) ; hideL(-7) ; hideR(3) ; andR(3) ; <(
              QE,
              orR(3) ; orL(-9) ; <(
                hideR(4) ; hideL(-7) ; hideR(2) ; QE,
                hideL(-7) ; hideR(3) ; hideR(2) ; QE
                )
              )
            )
          ),
        implyR(1) ; andR(1) ; <(
          implyR(1) ; andL(-11) ; fullSimplify ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
            QE,
            orR(1) ; orR(2) ; orR(3) ; orR(4) ; hideR(4) ; hideR(3) ; hideL(-7) ; hideL(-7) ; hideL(-7) ; QE
            ),
          implyR(1) ; andR(1) ; <(
            notOr(-9) ; andL(-9) ; notAnd(-9) ; notAnd(-10) ; fullSimplify ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
              QE,
              andR(1) ; <(
                QE,
                orR(1) ; orR(2) ; orR(3) ; orL(-8) ; <(
                  hideR(4) ; hideR(1) ; hideR(1) ; hideL(-9) ; hideL(-9) ; QE,
                  andL(-8) ; fullSimplify ; fullSimplify ; closeFalse
                  )
                )
              ),
            andR(1) ; <(
              implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; fullSimplify ; andR(1) ; <(
                QE,
                QE
                ),
              implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; hideL(-10) ; hideL(-10) ; hideL(-9) ; hideL(-8) ; andR(1) ; <(
                QE,
                andR(1) ; <(
                  QE,
                  orR(1) ; orR(2) ; orR(3) ; hideR(4) ; hideR(1) ; hideR(1) ; QE
                  )
                )
              )
            )
          )
        )
      )
    ),
  con({`v`}, {`A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo<=0->vr=0)&\exists n (n>=2&xo+(v-n)*ep()*Vmin()>0&vr+(min((v,n-1))-(n-2))*ep()*A()>=A()*ep()&(xr>0|xr+min((v,n-2))*ep()*(A()*ep())>0))`}, 1) ; <(
    QE,
    QE,
    composed(1) ; composed(1.1) ; solve(1.1.1) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
      QE,
      composed(1) ; ((andL('L) | existsL('L))*) ; choiced(1) ; orR(1) ; composed(1) ; testd(1) ; orL(-16=={`xr>0|xr+min((v,n-2))*ep()*(A()*ep())>0`}) ; <(
        hideR(2) ; fullSimplify ; composed(1) ; randomd(1) ; implyL(-8=={`xo<=0->vr=0`}) ; <(
          cut({`xo+vo*ep()>0|xo+vo*ep()<=0`}) ; <(
            orL('Llast) ; <(
              existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
                QE,
                assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                  QE,
                  andR(1) ; <(
                    QE,
                    fullSimplify ; andR(1) ; <(
                      QE,
                      existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                        QE,
                        andR(1) ; <(
                          QE,
                          QE
                          )
                        )
                      )
                    )
                  )
                ),
              hideR(1) ; QE
              ),
            hideR(1) ; QE
            ),
          cut({`xo+vo*ep()>0|xo+vo*ep()<=0`}) ; <(
            orL('Llast) ; <(
              existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
                QE,
                assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                  QE,
                  andR(1) ; <(
                    QE,
                    fullSimplify ; andR(1) ; <(
                      QE,
                      existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                        QE,
                        andR(1) ; <(
                          QE,
                          QE
                          )
                        )
                      )
                    )
                  )
                ),
              existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
                QE,
                assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                  QE,
                  andR(1) ; <(
                    QE,
                    fullSimplify ; existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                      QE,
                      andR(1) ; <(
                        QE,
                        QE
                        )
                      )
                    )
                  )
                )
              ),
            hideR(1) ; QE
            )
          ),
        composed(2) ; testd(2) ; implyL(-12=={`xo<=0->vr=0`}) ; <(
          andR(1) ; <(
            hideR(2) ; QE,
            hideR(2) ; composed(1) ; randomd(1) ; existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
              QE,
              assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                QE,
                andR(1) ; <(
                  QE,
                  fullSimplify ; andR(1) ; <(
                    QE,
                    existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                      QE,
                      andR(1) ; <(
                        QE,
                        QE
                        )
                      )
                    )
                  )
                )
              )
            ),
          andR(1) ; <(
            andR(2) ; <(
              QE,
              choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; andR(2) ; <(
                QE,
                choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; andR(2) ; <(
                  QE,
                  choiced(2) ; orR(2) ; hideR(2) ; choiced(2) ; orR(2) ; hideR(3) ; composed(2) ; testd(2) ; fullSimplify ; assignd(2) ; assignd(2) ; existsR({`ep()`}, 2) ; andR(2) ; <(
                    QE,
                    andR(2) ; <(
                      QE,
                      fullSimplify ; existsR({`n`}, 2) ; fullSimplify ; andR(2) ; <(
                        QE,
                        andR(2) ; <(
                          QE,
                          QE
                          )
                        )
                      )
                    )
                  )
                )
              ),
            hideR(2) ; composed(1) ; randomd(1) ; cut({`xo+vo*ep()>0|xo+vo*ep()<=0`}) ; <(
              orL('Llast) ; <(
                existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
                  QE,
                  assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                    QE,
                    andR(1) ; <(
                      QE,
                      fullSimplify ; andR(1) ; <(
                        QE,
                        existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                          QE,
                          andR(1) ; <(
                            QE,
                            QE
                            )
                          )
                        )
                      )
                    )
                  ),
                existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
                  QE,
                  assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                    QE,
                    andR(1) ; <(
                      QE,
                      fullSimplify ; existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                        QE,
                        andR(1) ; <(
                          QE,
                          QE
                          )
                        )
                      )
                    )
                  )
                ),
              hideR(1) ; QE
              )
            )
          )
        )
      )
    )
  )
End.

Tactic "Proof Theorem 12: Cross intersection (loop split and unroll)".
/* some of the QE need QE({`Mathematica`}) */
implyR(1) ; andR(1) ; <(
  loop({`0<=vr&Vmin()<=vo&(xr>0|xo>0|xr+vr^2/(2*b()) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr))`}, 1) ; <(
    QE,
    QE,
    composeb(1) ; composeb(1.1) ; solve(1.1.1) ; chase(1) ; allR(1) ; implyR(1) ; andL(-1) ; andL(-7) ; andR(1) ; <(
      implyR(1) ; allR(1) ; implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; orL(-9) ; <(
        fullSimplify ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            orR(1) ; hideR(2) ; QE
            )
          ),
        fullSimplify ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            orR(1) ; orR(2) ; hideR(3) ; hideR(1) ; QE
            )
          )
        ),
      implyR(1) ; andR(1) ; <(
        implyR(1) ; andL(-10) ; fullSimplify ; allR(1) ; implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            orR(1) ; orR(2) ; orR(3) ; hideL(-7) ; hideR(3) ; andR(3) ; <(
              QE,
              orR(3) ; orL(-9) ; <(
                hideR(4) ; hideL(-7) ; hideR(2) ; QE,
                hideL(-7) ; hideR(3) ; hideR(2) ; QE
                )
              )
            )
          ),
        implyR(1) ; andR(1) ; <(
          implyR(1) ; andL(-11) ; fullSimplify ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
            QE,
            orR(1) ; orR(2) ; orR(3) ; orR(4) ; hideR(4) ; hideR(3) ; hideL(-7) ; hideL(-7) ; hideL(-7) ; QE
            ),
          implyR(1) ; andR(1) ; <(
            notOr(-9) ; andL(-9) ; notAnd(-9) ; notAnd(-10) ; fullSimplify ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
              QE,
              andR(1) ; <(
                QE,
                orR(1) ; orR(2) ; orR(3) ; orL(-8) ; <(
                  hideR(4) ; hideR(1) ; hideR(1) ; hideL(-9) ; hideL(-9) ; QE,
                  andL(-8) ; fullSimplify ; fullSimplify ; closeFalse
                  )
                )
              ),
            andR(1) ; <(
              implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; fullSimplify ; andR(1) ; <(
                QE,
                QE
                ),
              implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; hideL(-10) ; hideL(-10) ; hideL(-9) ; hideL(-8) ; andR(1) ; <(
                QE,
                andR(1) ; <(
                  QE,
                  orR(1) ; orR(2) ; orR(3) ; hideR(4) ; hideR(1) ; hideR(1) ; QE
                  )
                )
              )
            )
          )
        )
      )
    ),
  andL('L)* ; useAt({`<*> merge`}, {`1`}, 1) ; con({`v`}, {`A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+v*ep()*Vmin()>0`}, 1) ; <(
    QE,
    andL('L)* ; edit({`xo>0`}, -9) ; hideL(-1) ; fullSimplify ; iterated(1) ; orR(1) ; composed(2) ; composed(2) ; randomd(2) ; existsR({`0`}, 2) ; testd(2) ; andR(2) ; <(
      QE,
      composed(2) ; composed(2) ; choiced(2) ; orR(2) ; hideR(3) ; composed(2) ; testd(2) ; simplify(2) ; composed(2) ; randomd(2) ; existsR({`A()`}, 2) ; testd(2) ; andR(2) ; <(
        QE,
        assignd(2) ; solve(2) ; existsR({`ep()`}, 2) ; simplify(2) ; andR(2) ; <(
          QE,
          existsR({`vo_1+0`}, 2) ; fullSimplify ; existsR({`A()*ep()+vr_1`}, 2) ; simplify(2) ; existsR({`vo_1*ep()+xo_1`}, 2) ; simplify(2) ;
          existsR({`A()/2*ep()^2+vr_1*ep()+xr_1`}, 2) ; simplify(2) ; edit({`vr>=A()*ep()`}, -11=={`vr=A()*ep()+vr_1`}) ; edit({`xr>=xr_1`}, -13=={`xr=A()/2*ep()^2+vr_1*ep()+xr_1`}) ; edit({`xo>0`}, -12=={`xo=vo_1*ep()+xo_1`}) ; hideL(-5=={`xo_1>0`}) ; hideL(-6=={`vr_1>=0`}) ;
          con({`w`}, {`A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&xo>0&vr>=A()*ep()&xr+w*ep()*(A()*ep())>0`}, 2) ; <(
            QE,
            QE,
            andL('L)* ; composed(1) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
              QE,
              composed(1) ; solve(1.1) ; composed(1) ; choiced(1) ; orR(1) ; composed(1) ; testd(1) ; simplify(1) ; hideR(2) ; composed(1) ; randomd(1) ; existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
                QE,
                assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; QE
                )
              )
            )
          )
        )
      )
    ,
    andL('L)* ; composed(1) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
      QE,
      composed(1) ; solve(1.1) ; composed(1) ; choiced(1) ; orR(1) ; orL(-12=={`xo>0|vr=0`}) ; <(
        hideR(2) ; composed(1) ; testd(1) ; simplify(1) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
          QE,
          assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; QE
          ),
        composed(1) ; testd(1) ; andR(1) ; <(
          composed(2) ; testd(2) ; andR(2) ; <(
            QE,
            choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; simplify(2) ; choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; simplify(2) ; choiced(2) ; orR(2) ; hideR(2) ; choiced(2) ; orR(2) ; hideR(3) ; composed(2) ; testd(2) ; simplify(2) ; assignd(2) ; assignd(2) ; existsR({`ep()`}, 2) ; simplify(2) ; QE
            ),
          hideR(2) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
            QE,
            assignd(1) ; existsR({`ep()`}, 1) ; simplify(1) ; QE
            )
          )
        )
      )
    )
  )
End.

End.

Theorem "Theorem 13: Passive safety with trajectory distance measurement".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R v) = (v^2 / (2*b()) + V()*v/b()).
  R accelComp(R v, R a) = ((a/b() + 1) * (a/2 * ep()^2 + ep()*(v+V))).
  R admissibleSeparationG(R v, R a) = (stopDist(v) + accelComp(v,a)).
  R admissibleSeparationL(R v, R a) = (-v^2/(2*a)-V*v/a).
  R trajectoryDist(R r, R xo, R xc, R yo, R yc) = ( abs(abs(r) - ((xo-xc)^2 + (yo-yc)^2)^(1/2)) ).

  B isWellformedDir() <-> ( r!=0 & r^2 = (x-xc)^2 + (y-yc)^2 & dx^2 + dy^2 = 1 & dx = -(y-yc)/r & dy = (x-xc)/r & w*r=v ).

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v) | abs(abs(r) - ((xo-xc)^2 + (yo-yc)^2)^(1/2)) > V*v/b)
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xc.
  R yc.
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; { dx:=-dx;dy:=-dy; ++ dx:=dx;dy:=dy; }; r := *; xc := *; yc := *;
            ?(r!=0 & r^2 = (x-xc)^2+(y-yc)^2 & dx=-(y-yc)/r & dy=(x-xc)/r & r*w=v); }
      	  ++
          /* or choose a new safe curve */
          { a := *; ?-b<=a & a<=A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xc := *; yc := *;

            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?(r!=0 & r^2 = (x-xc)^2+(y-yc)^2 & dx=-(y-yc)/r & dy=(x-xc)/r & r*w=v);

            /* use that curve, if it is a safe one (admissible velocities) */
            if (v+a*ep>=0) { ?abs(x-xo) > admissibleSeparationG(v,a) | abs(y-yo) > admissibleSeparationG(v,a) | trajectoryDist(r,xo,xc,yo,yc) > V*(ep + (v+a*ep)/b); }
            else           { ?abs(x-xo) > admissibleSeparationL(v,a) | abs(y-yo) > admissibleSeparationL(v,a) | trajectoryDist(r,xo,xc,yo,yc) > -V*v/a; }
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 13: Passive safety with trajectory distance measurement".
/* Some of the QE need QE({`Mathematica`}) */
implyR(1) ; loop({`v>=0&(r!=0&r^2=(x-xc)^2+(y-yc)^2&dx^2+dy^2=1&dx=-(y-yc)/r&dy=(x-xc)/r&w*r=v)&(v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b()|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V()*v/b())`}, 1) ; <(
  print({`Base Case`}); QE; print({`Base Case Done`}),
  print({`Use Case`}); unfold ; fullSimplify ; hideL(-11=={`w*r=v`}) ; hideL(-10=={`dy=(x-xc)/r`}) ; hideL(-9=={`dx=-(y-yc)/r`}) ; hideL(-8=={`dx^2+dy^2=1`}) ; hideL(-3=={`ep()>0`}) ; orL(-4) ; <(
    hideL(-6=={`r^2=(x-xc)^2+(y-yc)^2`}) ; hideL(-5=={`r!=0`}) ; QE,
    orL(-4) ; <(
      hideL(-6=={`r^2=(x-xc)^2+(y-yc)^2`}) ; hideL(-5=={`r!=0`}) ; QE,
      edit({`expand(abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2)))>V()*v/b()`}, -4) ; edit({`expand(abs(r))-((xo-xc)^2+(yo-yc)^2)^(1/2)>=0&abs_0=abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2)|abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2) < 0&abs_0=-(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))`}, -8) ; orL(-9) ; <(
        QE,
        QE
        )
      )
    ); print({`Use Case Done`}),
  unfold ; <(
    print({`Induction Step (1)`});
    dC({`t>=0&dx^2+dy^2=1&v=old(v)-b()*t&w*r=v`}, 1) ; <(
      dC({`dx=-(y-yc)/r&dy=(x-xc)/r`}, 1) ; <(
        dC({`xo=old(xo)+vxo*t&yo=old(yo)+vyo*t`}, 1) ; <(
          dC({`-t*(v+b()/2*t)<=x-old(x)&x-old(x)<=t*(v+b()/2*t)`}, 1) ; <(
            dC({`-t*(v+b()/2*t)<=y-old(y)&y-old(y)<=t*(v+b()/2*t)`}, 1) ; <(
              print({`Induction Step (1) Differential Invariants Established`});
              dW(1) ; implyR(1) ; andL('L)* ; fullSimplify ; andR(1) ; <(
                hideL(-6=={`v_0>0->abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()|abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V()*v_0/b()`}) ; QE,
                implyR(1) ; orR(1) ; orR(2) ; hideL(-1=={`A()>=0`}) ; hideL(-2=={`ep()>0`}) ; hideL(-21=={`t<=ep()`}) ; hideL(-23=={`dx^2+dy^2=1`}) ; hideL(-20=={`dy=(x-xc)/r`}) ; hideL(-19=={`dx=-(y-yc)/r`}) ; hideL(-9=={`dy_0=(x_0-xc)/r`}) ; hideL(-8=={`dx_0=-(y_0-yc)/r`}) ; hideL(-7=={`dx_0^2+dy_0^2=1`}) ; implyL(-4) ; <(
                  hideR(3=={`abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V()*v/b()`}) ; hideR(2=={`abs(y-yo)>v^2/(2*b())+V()*v/b()`}) ; hideR(1=={`abs(x-xo)>v^2/(2*b())+V()*v/b()`}) ; QE,
                  orL(-4) ; <(
                    hideR(3=={`abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V()*v/b()`}) ; hideR(2=={`abs(y-yo)>v^2/(2*b())+V()*v/b()`}) ; smartQE,
                    orL(-4) ; <(
                      hideR(3=={`abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V()*v/b()`}) ; hideR(1=={`abs(x-xo)>v^2/(2*b())+V()*v/b()`}) ; smartQE,
                      hideR(2=={`abs(y-yo)>v^2/(2*b())+V()*v/b()`}) ; hideR(1=={`abs(x-xo)>v^2/(2*b())+V()*v/b()`}) ; edit({`abs(abs(r)-abbrv((((xo_0-xc)^2+(yo_0-yc)^2)^(1/2),oldCDist)))>V()*v_0/b()`}, -4) ; edit({`abs(abs(r)-abbrv((((xo-xc)^2+(yo-yc)^2)^(1/2),cDist)))>V()*v/b()`}, 1) ; cut({`abs(cDist-oldCDist)<=t*V()`}) ; <(
                        hideL(-22=={`cDist=((xo-xc)^2+(yo-yc)^2)^(1/2)`}) ; hideL(-21=={`oldCDist=((xo_0-xc)^2+(yo_0-yc)^2)^(1/2)`}) ; hideL(-6=={`r^2=(x_0-xc)^2+(y_0-yc)^2`}) ; hideL(-6=={`w_0*r=v_0`}) ; hideL(-6=={`vxo^2+vyo^2<=V()^2`}) ; smartQE,
                        hideR(1=={`abs(abs(r)-cDist)>V()*v/b()`}) ; hideL(-4=={`abs(abs(r)-oldCDist)>V()*v_0/b()`}) ; hideL(-5=={`r^2=(x_0-xc)^2+(y_0-yc)^2`}) ; hideL(-5=={`w_0*r=v_0`}) ; hideL(-4=={`r!=0`}) ; hideL(-3=={`v_0>=0`}) ; hideL(-14=={`w*r=v`}) ; cut({`abs(cDist-oldCDist)<=t*(vxo^2+vyo^2)^(1/2)`}) ; <(
                          hideL(-16=={`cDist=((xo-xc)^2+(yo-yc)^2)^(1/2)`}) ; hideL(-15=={`oldCDist=((xo_0-xc)^2+(yo_0-yc)^2)^(1/2)`}) ; smartQE,
                          hideR(1=={`abs(cDist-oldCDist)<=t*V()`}) ; hideL(-3=={`vxo^2+vyo^2<=V()^2`}) ; hideL(-2=={`V()>=0`}) ; hideL(-2=={`t_0=0`}) ; smartQE
                          )
                        )
                      )
                    )
                  )
                ),
              hideL(-6=={`v_0>0->abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()|abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V()*v_0/b()`}) ; dI(1)
              ),
            hideL(-6=={`v_0>0->abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()|abs(y-yo_0)>v_0^2/(2*b())+V()*v_0/b()|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V()*v_0/b()`}) ; dI(1)
            ),
          hideL(-6=={`v_0>0->abs(x-xo_0)>v_0^2/(2*b())+V()*v_0/b()|abs(y-yo_0)>v_0^2/(2*b())+V()*v_0/b()|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V()*v_0/b()`}) ; dI(1)
          ),
        hideL(-6=={`v_0>0->abs(x-xo)>v_0^2/(2*b())+V()*v_0/b()|abs(y-yo)>v_0^2/(2*b())+V()*v_0/b()|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V()*v_0/b()`}) ; dI(1)
        ),
      hideL(-6=={`v_0>0->abs(x-xo)>v_0^2/(2*b())+V()*v_0/b()|abs(y-yo)>v_0^2/(2*b())+V()*v_0/b()|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V()*v_0/b()`}) ; dI(1)
      ); print({`Induction Step (1) Done`}),
    print({`Induction Step (2)`});
    dC({`t>=0&dx^2+dy^2=1&v=old(v)&w*r=v`}, 1) ; <(
      dC({`dx=-(y-yc)/r&dy=(x-xc)/r`}, 1) ; <(
        print({`Induction Step (2) Differential Invariants Established`});
        dW(1) ; implyR(1) ; andL('L)* ; fullSimplify ; QE,
        hideL(-6=={`v_0>0->abs(x-xo)>v_0^2/(2*b())+V()*v_0/b()|abs(y-yo)>v_0^2/(2*b())+V()*v_0/b()|abs(abs(r_0)-((xo-xc_0)^2+(yo-yc_0)^2)^(1/2))>V()*v_0/b()`}) ; dI(1)
        ),
      hideL(-6=={`v_0>0->abs(x-xo)>v_0^2/(2*b())+V()*v_0/b()|abs(y-yo)>v_0^2/(2*b())+V()*v_0/b()|abs(abs(r_0)-((xo-xc_0)^2+(yo-yc_0)^2)^(1/2))>V()*v_0/b()`}) ; dI(1)
      ); print({`Induction Step (2) Done`}),
    print({`Induction Step (3)`});
    hideL(-6=={`v>0->abs(x-xo_0)>v^2/(2*b())+V()*v/b()|abs(y-yo_0)>v^2/(2*b())+V()*v/b()|abs(abs(r_0)-((xo_0-xc_0)^2+(yo_0-yc_0)^2)^(1/2))>V()*v/b()`}) ; hideL(-6=={`r_0!=0`}) ; hideL(-6=={`r_0^2=(x-xc_0)^2+(y-yc_0)^2`}) ; hideL(-7=={`dx=-(y-yc_0)/r_0`}) ; hideL(-7=={`dy=(x-xc_0)/r_0`}) ; hideL(-7=={`w_0*r_0=v`}) ; dC({`t>=0&dx^2+dy^2=1&v=old(v)+a*t&w*r=v`}, 1) ; <(
      dC({`dx=-(y-yc)/r&dy=(x-xc)/r`}, 1) ; <(
        dC({`xo=old(xo)+vxo*t&yo=old(yo)+vyo*t`}, 1) ; <(
          dC({`-t*(v-a/2*t)<=x-old(x)&x-old(x)<=t*(v-a/2*t)`}, 1) ; <(
            dC({`-t*(v-a/2*t)<=y-old(y)&y-old(y)<=t*(v-a/2*t)`}, 1) ; <(
              print({`Induction Step (3) Differential Invariants Established`});
              dW(1) ; implyR(1) ; andL('L)* ; fullSimplify ; hideL(-10=={`-W()<=w_0`}) ; hideL(-10=={`w_0<=W()`}) ; andR(1) ; <(
                hideL(-16=={`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*ep()^2+ep()*(v_0+V()))|abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*ep()^2+ep()*(v_0+V()))|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V()*(ep()+(v_0+a*ep())/b())`}) ; QE,
                implyR(1) ; orR(1) ; orR(2) ; hideL(-29=={`dx^2+dy^2=1`}) ; hideL(-25=={`dy=(x-xc)/r`}) ; hideL(-24=={`dx=-(y-yc)/r`}) ; hideL(-13=={`dy_0=(x_0-xc)/r`}) ; hideL(-12=={`dx_0=-(y_0-yc)/r`}) ; hideL(-6=={`dx_0^2+dy_0^2=1`}) ; hideL(-14=={`t_0=0`}) ; orL(-13) ; <(
                  edit({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*t^2+t*(v_0+V()))`}, -13) ; hideL(-12=={`v_0+a*ep()>=0`}) ; hideL(-19=={`t<=ep()`}) ; hideL(-3=={`ep()>0`}) ; hideR(3=={`abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V()*v/b()`}) ; hideR(2=={`abs(y-yo)>v^2/(2*b())+V()*v/b()`}) ; smartQE,
                  orL(-13) ; <(
                    hideR(3=={`abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V()*v/b()`}) ; hideR(1=={`abs(x-xo)>v^2/(2*b())+V()*v/b()`}) ; edit({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*t^2+t*(v_0+V()))`}, -13) ; hideL(-12=={`v_0+a*ep()>=0`}) ; hideL(-3=={`ep()>0`}) ; hideL(-18=={`t<=ep()`}) ; smartQE,
                    hideR(2=={`abs(y-yo)>v^2/(2*b())+V()*v/b()`}) ; hideR(1=={`abs(x-xo)>v^2/(2*b())+V()*v/b()`}) ; edit({`abs(abs(r)-abbrv((((xo_0-xc)^2+(yo_0-yc)^2)^(1/2),oldCDist)))>V()*(ep()+(v_0+a*ep())/b())`}, -13) ; edit({`abs(abs(r)-abbrv((((xo-xc)^2+(yo-yc)^2)^(1/2),cDist)))>V()*v/b()`}, 1) ; hideL(-9=={`r!=0`}) ; hideL(-9=={`r^2=(x_0-xc)^2+(y_0-yc)^2`}) ; hideL(-9=={`r*w_0=v_0`}) ; hideL(-9=={`v_0+a*ep()>=0`}) ; cut({`abs(cDist-oldCDist)<=t*V()`}) ; <(
                      hideL(-22=={`oldCDist=((xo_0-xc)^2+(yo_0-yc)^2)^(1/2)`}) ; hideL(-22=={`cDist=((xo-xc)^2+(yo-yc)^2)^(1/2)`}) ; edit({`abs(abs(r)-oldCDist)>V()*(t+(v_0+a*t)/b())`}, -9) ; hideL(-3=={`ep()>0`}) ; hideL(-15=={`t<=ep()`}) ; smartQE,
                      hideR(1=={`abs(abs(r)-cDist)>V()*v/b()`}) ; hideL(-9=={`abs(abs(r)-oldCDist)>V()*(ep()+(v_0+a*ep())/b())`}) ; hideL(-15=={`t<=ep()`}) ; hideL(-3=={`ep()>0`}) ; cut({`abs(cDist-oldCDist)<=t*(vxo^2+vyo^2)^(1/2)`}) ; <(
                        hideL(-19=={`oldCDist=((xo_0-xc)^2+(yo_0-yc)^2)^(1/2)`}) ; hideL(-19=={`cDist=((xo-xc)^2+(yo-yc)^2)^(1/2)`}) ; edit({`abbrv((abs(cDist-oldCDist),X))<=t*V()`}, 1) ; hideL(-20=={`X=abs(cDist-oldCDist)`}) ; hideL(-1=={`A()>=0`}) ; hideL(-3=={`v_0>=0`}) ; hideL(-4=={`-b()<=a`}) ; hideL(-4=={`a<=A()`}) ; hideL(-4=={`-t*(v-a/2*t)<=y-y_0`}) ; hideL(-4=={`y-y_0<=t*(v-a/2*t)`}) ; hideL(-4=={`-t*(v-a/2*t)<=x-x_0`}) ; hideL(-4=={`x-x_0<=t*(v-a/2*t)`}) ; hideL(-4=={`xo=xo_0+vxo*t`}) ; hideL(-4=={`yo=yo_0+vyo*t`}) ; hideL(-6=={`v=v_0+a*t`}) ; hideL(-4=={`v>=0`}) ; hideL(-5=={`w*r=v`}) ; hideL(-5=={`v>0`}) ; hideL(-1=={`b()>0`}) ; QE,
                        hideR(1=={`abs(cDist-oldCDist)<=t*V()`}) ; hideL(-5=={`vxo^2+vyo^2<=V()^2`}) ; hideL(-3=={`V()>=0`}) ; hideL(-15=={`w*r=v`}) ; hideL(-5=={`a<=A()`}) ; hideL(-1=={`A()>=0`}) ; hideL(-4=={`-t*(v-a/2*t)<=y-y_0`}) ; hideL(-4=={`y-y_0<=t*(v-a/2*t)`}) ; hideL(-4=={`-t*(v-a/2*t)<=x-x_0`}) ; hideL(-4=={`x-x_0<=t*(v-a/2*t)`}) ; hideL(-8=={`v=v_0+a*t`}) ; hideL(-8=={`v>0`}) ; hideL(-6=={`v>=0`}) ; hideL(-3=={`-b()<=a`}) ; hideL(-1=={`b()>0`}) ; smartQE
                        )
                      )
                    )
                  )
                ),
              hideL(-18=={`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*ep()^2+ep()*(v_0+V()))|abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*ep()^2+ep()*(v_0+V()))|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V()*(ep()+(v_0+a*ep())/b())`}) ; dI(1)
              ),
            hideL(-18=={`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*ep()^2+ep()*(v_0+V()))|abs(y-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*ep()^2+ep()*(v_0+V()))|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V()*(ep()+(v_0+a*ep())/b())`}) ; dI(1)
            ),
          hideL(-18=={`abs(x-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*ep()^2+ep()*(v_0+V()))|abs(y-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*ep()^2+ep()*(v_0+V()))|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>V()*(ep()+(v_0+a*ep())/b())`}) ; dI(1)
          ),
        hideL(-18=={`abs(x-xo)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*ep()^2+ep()*(v_0+V()))|abs(y-yo)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*ep()^2+ep()*(v_0+V()))|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V()*(ep()+(v_0+a*ep())/b())`}) ; dI(1)
        ),
      hideL(-18=={`abs(x-xo)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*ep()^2+ep()*(v_0+V()))|abs(y-yo)>v_0^2/(2*b())+V()*v_0/b()+(a/b()+1)*(a/2*ep()^2+ep()*(v_0+V()))|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V()*(ep()+(v_0+a*ep())/b())`}) ; dI(1)
      ); print({`Induction Step (3) Done`}),
    print({`Induction Step (4)`});
    dC({`t>=0&dx^2+dy^2=1&v=old(v)&w*r=v`}, 1) ; <(
      dC({`dx=-(y-yc)/r&dy=(x-xc)/r`}, 1) ; <(
        print({`Induction Step (4) Differential Invariants Established`});
        dW(1) ; implyR(1) ; andL('L)* ; fullSimplify ; QE,
        hideL(-6=={`v_0>0->abs(x-xo)>v_0^2/(2*b())+V()*v_0/b()|abs(y-yo)>v_0^2/(2*b())+V()*v_0/b()|abs(abs(r_0)-((xo-xc_0)^2+(yo-yc_0)^2)^(1/2))>V()*v_0/b()`}) ; dI(1)
        ),
      hideL(-6=={`v_0>0->abs(x-xo)>v_0^2/(2*b())+V()*v_0/b()|abs(y-yo)>v_0^2/(2*b())+V()*v_0/b()|abs(abs(r_0)-((xo-xc_0)^2+(yo-yc_0)^2)^(1/2))>V()*v_0/b()`}) ; dI(1)
      ); print({`Induction Step (4) Done`}),
    print({`Induction Step (5)`});
    edit({`!v+a*ep() < 0`}, 1) ; notR(1) ; hideL(-6=={`v>0->abs(x-xo_0)>v^2/(2*b())+V()*v/b()|abs(y-yo_0)>v^2/(2*b())+V()*v/b()|abs(abs(r_0)-((xo_0-xc_0)^2+(yo_0-yc_0)^2)^(1/2))>V()*v/b()`}) ; hideL(-6=={`r_0!=0`}) ; hideL(-6=={`r_0^2=(x-xc_0)^2+(y-yc_0)^2`}) ; hideL(-7=={`dx=-(y-yc_0)/r_0`}) ; hideL(-7=={`dy=(x-xc_0)/r_0`}) ; hideL(-7=={`w_0*r_0=v`}) ; hideL(-10=={`-W()<=w`}) ; hideL(-10=={`w<=W()`}) ; cut({`a < 0`}) ; <(
      hideL(-9=={`a<=A()`}) ; hideL(-1=={`A()>=0`}) ; dC({`t>=0&dx^2+dy^2=1&v=old(v)+a*t&w*r=v`}, 1) ; <(
        dC({`dx=-(y-yc)/r&dy=(x-xc)/r`}, 1) ; <(
          dC({`xo=old(xo)+vxo*t&yo=old(yo)+vyo*t`}, 1) ; <(
            dC({`-t*(v-a/2*t)<=x-old(x)&x-old(x)<=t*(v-a/2*t)`}, 1) ; <(
              dC({`-t*(v-a/2*t)<=y-old(y)&y-old(y)<=t*(v-a/2*t)`}, 1) ; <(
                print({`Induction Step (5) Differential Invariants Established`});
                dW(1) ; implyR(1) ; andL('L)* ; fullSimplify ; andR(1) ; <(
                  hideL(-13=={`abs(x_0-xo_0)>-v_0^2/(2*a)-V()*v_0/a|abs(y_0-yo_0)>-v_0^2/(2*a)-V()*v_0/a|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>-V()*v_0/a`}) ; QE,
                  implyR(1) ; orR(1) ; orR(2) ; hideL(-28=={`dx^2+dy^2=1`}) ; hideL(-24=={`dy=(x-xc)/r`}) ; hideL(-23=={`dx=-(y-yc)/r`}) ; hideL(-11=={`dy_0=(x_0-xc)/r`}) ; hideL(-10=={`dx_0=-(y_0-yc)/r`}) ; hideL(-5=={`dx_0^2+dy_0^2=1`}) ; orL(-10) ; <(
                    hideR(3=={`abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V()*v/b()`}) ; hideR(2=={`abs(y-yo)>v^2/(2*b())+V()*v/b()`}) ; smartQE,
                    orL(-10) ; <(
                      hideR(3=={`abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V()*v/b()`}) ; hideR(1=={`abs(x-xo)>v^2/(2*b())+V()*v/b()`}) ; smartQE,
                      hideR(2=={`abs(y-yo)>v^2/(2*b())+V()*v/b()`}) ; hideR(1=={`abs(x-xo)>v^2/(2*b())+V()*v/b()`}) ; edit({`abs(abs(r)-abbrv((((xo_0-xc)^2+(yo_0-yc)^2)^(1/2),oldCDist)))>-V()*v_0/a`}, -10) ; edit({`abs(abs(r)-abbrv((((xo-xc)^2+(yo-yc)^2)^(1/2),cDist)))>V()*v/b()`}, 1) ; cut({`abs(cDist-oldCDist)<=t*V()`}) ; <(
                        hideL(-27=={`cDist=((xo-xc)^2+(yo-yc)^2)^(1/2)`}) ; hideL(-26=={`oldCDist=((xo_0-xc)^2+(yo_0-yc)^2)^(1/2)`}) ; smartQE,
                        hideR(1=={`abs(abs(r)-cDist)>V()*v/b()`}) ; hideL(-14=={`-t*(v-a/2*t)<=y-y_0`}) ; hideL(-14=={`y-y_0<=t*(v-a/2*t)`}) ; hideL(-14=={`-t*(v-a/2*t)<=x-x_0`}) ; hideL(-14=={`x-x_0<=t*(v-a/2*t)`}) ; hideL(-19=={`v=v_0+a*t`}) ; hideL(-19=={`w*r=v`}) ; hideL(-19=={`v>0`}) ; hideL(-17=={`v>=0`}) ; hideL(-12=={`v_0+a*ep() < 0`}) ; hideL(-15=={`t<=ep()`}) ; hideL(-2=={`ep()>0`}) ; hideL(-6=={`r!=0`}) ; hideL(-6=={`r^2=(x_0-xc)^2+(y_0-yc)^2`}) ; hideL(-8=={`t_0=0`}) ; hideL(-6=={`r*w_0=v_0`}) ; hideL(-5=={`-b()<=a`}) ; hideL(-1=={`b()>0`}) ; cut({`abs(cDist-oldCDist)<=t*(vxo^2+vyo^2)^(1/2)`}) ; <(
                          hideL(-9=={`oldCDist=((xo_0-xc)^2+(yo_0-yc)^2)^(1/2)`}) ; hideL(-9=={`cDist=((xo-xc)^2+(yo-yc)^2)^(1/2)`}) ; edit({`abbrv((abs(cDist-oldCDist),X))<=t*V()`}, 1) ; hideL(-10=={`X=abs(cDist-oldCDist)`}) ; hideL(-4=={`abs(abs(r)-oldCDist)>-V()*v_0/a`}) ; QE,
                          hideR(1=={`abs(cDist-oldCDist)<=t*V()`}) ; hideL(-3=={`vxo^2+vyo^2<=V()^2`}) ; hideL(-3=={`abs(abs(r)-oldCDist)>-V()*v_0/a`}) ; hideL(-3=={`a < 0`}) ; hideL(-1=={`V()>=0`}) ; hideL(-1=={`v_0>=0`}); smartQE
                          )
                        )
                      )
                    )
                  ),
                hideL(-13=={`abs(x_0-xo_0)>-v_0^2/(2*a)-V()*v_0/a|abs(y_0-yo_0)>-v_0^2/(2*a)-V()*v_0/a|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>-V()*v_0/a`}) ; dI(1)
                ),
              hideL(-13=={`abs(x_0-xo_0)>-v_0^2/(2*a)-V()*v_0/a|abs(y-yo_0)>-v_0^2/(2*a)-V()*v_0/a|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>-V()*v_0/a`}) ; dI(1)
              ),
            hideL(-13=={`abs(x-xo_0)>-v_0^2/(2*a)-V()*v_0/a|abs(y-yo_0)>-v_0^2/(2*a)-V()*v_0/a|abs(abs(r)-((xo_0-xc)^2+(yo_0-yc)^2)^(1/2))>-V()*v_0/a`}) ; dI(1)
            ),
          hideL(-13=={`abs(x-xo)>-v_0^2/(2*a)-V()*v_0/a|abs(y-yo)>-v_0^2/(2*a)-V()*v_0/a|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>-V()*v_0/a`}) ; dI(1)
          ),
        hideL(-13=={`abs(x-xo)>-v_0^2/(2*a)-V()*v_0/a|abs(y-yo)>-v_0^2/(2*a)-V()*v_0/a|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>-V()*v_0/a`}) ; dI(1)
        ),
      hideR(1=={`[{x'=v*dx,y'=v*dy,v'=a,dx'=-w*dy,dy'=w*dx,w'=a/r,xo'=vxo,yo'=vyo,t'=1&t<=ep()&v>=0}](v>=0&(r!=0&r^2=(x-xc)^2+(y-yc)^2&dx^2+dy^2=1&dx=-(y-yc)/r&dy=(x-xc)/r&w*r=v)&(v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b()|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>V()*v/b()))`}) ; hideL(-15=={`abs(x-xo)>-v^2/(2*a)-V()*v/a|abs(y-yo)>-v^2/(2*a)-V()*v/a|abs(abs(r)-((xo-xc)^2+(yo-yc)^2)^(1/2))>-V()*v/a`}) ; QE
      )
    ); print({`Induction Step (5) Done`})
  ); print({`Proof Done`})
End.

End.

Theorem "Theorem 14: Reach waypoint with deadline".

/*
 *	Robot must stop within distance delta at goal.
 *
 *  Robot
 * 	- must stop within distance delta of goal
 *  - can only drive straight and forward
 *  - ensures progress towards goal
 *
 *  Liveness property:
 *  - Robot can stop at goal
 *
 */

Functions.
	R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R GDelta().	 /* goal area size */
	R Vmax().    /* robot cannot go faster than this */

	R waypointStartDist(R xg) = ( xg-GDelta() ).
	R waypointEndDist(R xg)   = ( xg+GDelta() ).

  R minV() = ( A()*ep() ).
  R maxTravelTime(R g) = ( waypointStartDist(g)/minV() ).
  R stopTime(R v)      = ( v/b() ).
  R speedUpTime(R v)   = ( ep()-v/A() ).

	R stopDist(R v) = ( v^2/(2*b()) ).
	R accComp(R v)  = ( (A()/b() + 1)*(A()/2*ep()^2 + ep()*v) ).

	B bounds() <-> (                                                                     /* Bounds for global constants */
      A() > 0                                                                                       /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & Vmax() >= 2*A()*ep()
    & GDelta() > Vmax()*ep() + Vmax()^2/(2*b())                            /* waypoint is large enough that robot can
                                                                                  start driving and still stop inside */
    & T > ep() + maxTravelTime(xg-xr) + ep() + stopTime(Vmax())
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    vr = 0
    & xr < waypointStartDist(xg)
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

	B loopinv() <-> (
	  0 <= vr & vr <= Vmax & xr + stopDist(vr) < waypointEndDist(xg)
    				& (waypointStartDist(xg) < xr -> (vr = 0 | T >= stopTime(vr)))
    				& (xr <= waypointStartDist(xg) ->
    				       (vr >= minV() & T > maxTravelTime(xg-xr) + ep() + stopTime(Vmax()))
    				     | (vr <= minV() & T > speedUpTime(vr) + maxTravelTime(xg-xr) + ep() + stopTime(Vmax())))
	).

	HP ctrl ::= {
    if (xr > waypointStartDist(xg)) {
      /* in the goal area: brake or stay stopped */
      ar := -b(); ++ ?vr = 0; ar := 0;
    } else {
      if (xr + stopDist(vr) + accComp(vr) < waypointEndDist(xg) & vr+A()*ep() <= Vmax()) {
        /* if robot can stop from higher speed before leaving goal area then accelerate */
        ar := A();
      } else {
        /* else coast until at goal */
        ar := 0;
      }
    }
	}.

	HP dyn ::= { {xr' = vr, vr' = ar, t' = 1, T'=-1 & t <= ep() & vr >= 0} }.

	HP dwwpdl ::= {
    {	{ ctrl; t := 0; }
      dyn;
    }*@invariant(loopinv())
	}.
End.

ProgramVariables.
	R xr.		/* robot position: x */
	R vr.		/* robot translational velocity */
	R ar.		/* robot translational acceleration */
	R xg.		/* goal position */
	R t.		/* control cycle time */
	R T.		/* global time */
End.

Problem.
  assumptions()
	  -> [ dwwpdl; ](xr < waypointEndDist(xg) & (T <= 0 -> (waypointStartDist(xg) < xr & vr = 0)))
		 & < dwwpdl; >(waypointStartDist(xg) < xr & vr = 0)
End.

Tactic "Proof Theorem 14: Reach waypoint with deadline".
  /* Some of the QE need QE({`Mathematica`}) */
  implyR(1) ; andR(1) ; <(
    loop({`0<=vr&vr<=Vmax()&xr+vr^2/(2*b()) < xg+GDelta()&(xg-GDelta() < xr->vr=0|T>=vr/b())&(xr<=xg-GDelta()->vr>=A()*ep()&T>(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()|vr<=A()*ep()&T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b())`}, 1) ; <(
      QE,
      andR(1) ; <(
        andL('L)* ; hideL(-10=={`xr<=xg-GDelta()->vr>=A()*ep()&T>(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()|vr<=A()*ep()&T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; QE,
        implyR(1) ; andL('L)* ; andR(1) ; <(
          hideL(-10=={`xg-GDelta() < xr->vr=0|T>=vr/b()`}) ; implyL(-10) ; <(
            QE,
            QE
            ),
          implyL(-10) ; <(
            implyL(-10) ; <(
              QE,
              QE
              ),
            hideL(-11=={`xr<=xg-GDelta()->vr>=A()*ep()&T>(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()|vr<=A()*ep()&T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; QE
            )
          )
        ),
      andL('L)* ; notGreater(1.0.0.0.1.0.0) ; notAnd(1.0.0.0.1.1.1.0.0) ; composeb(1) ; solve(1.1) ; chase(1) ; andR(1) ; <(
        implyR(1) ; fullSimplify ; andR(1) ; <(
          allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
            QE,
            andR(1) ; <(
              QE,
              andR(1) ; <(
                QE,
                andR(1) ; <(
                  QE,
                  implyR(1) ; orR(1) ; allL({`t_`}, -12) ; implyL(-12) ; <(
                    hideR(1=={`(-b())*t_+vr>=A()*ep()&-t_+T>(xg-((-b())/2*t_^2+vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideR(1=={`(-b())*t_+vr<=A()*ep()&-t_+T>ep()-((-b())*t_+vr)/A()+(xg-((-b())/2*t_^2+vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; QE,
                    hideR(1=={`(-b())*t_+vr>=A()*ep()&-t_+T>(xg-((-b())/2*t_^2+vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideR(1=={`(-b())*t_+vr<=A()*ep()&-t_+T>ep()-((-b())*t_+vr)/A()+(xg-((-b())/2*t_^2+vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideL(-5=={`GDelta()>Vmax()*ep()+Vmax()^2/(2*b())`}) ; hideL(-7=={`xr+vr^2/(2*b()) < xg+GDelta()`}) ; QE
                    )
                  )
                )
              )
            ),
          implyR(1) ; fullSimplify ; allR(1) ; implyR(1) ; implyR(1) ; QE
          ),
        implyR(1) ; fullSimplify ; andR(1) ; <(
          implyR(1) ; andL(-11) ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
            QE,
            andR(1) ; <(
              QE,
              andR(1) ; <(
                hideL(-9=={`vr>=A()*ep()&T>(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()|vr<=A()*ep()&T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideL(-9=={`xr<=xg-GDelta()`}) ; hideL(-8=={`xr+vr^2/(2*b()) < xg+GDelta()`}) ; hideL(-4=={`Vmax()>=2*A()*ep()`}) ; hideL(-4=={`GDelta()>Vmax()*ep()+Vmax()^2/(2*b())`}) ; hideL(-5=={`vr<=Vmax()`}) ; hideL(-6=={`vr+A()*ep()<=Vmax()`}) ; QE,
                andR(1) ; <(
                  hideL(-11=={`xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()`}) ; hideL(-8=={`xr+vr^2/(2*b()) < xg+GDelta()`}) ; implyR(1) ; orR(1) ; QE,
                  implyR(1) ; orR(1) ; hideL(-11=={`xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()`}) ; hideL(-8=={`xr+vr^2/(2*b()) < xg+GDelta()`}) ; orL(-8) ; <(
                    hideR(2=={`A()*t_+vr<=A()*ep()&-t_+T>ep()-(A()*t_+vr)/A()+(xg-(A()/2*t_^2+vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; andL(-8) ; andR(1) ; <(
                      QE,
                      QE
                      ),
                    andL(-8) ; andR(1) ; <(
                      andR(2) ; <(
                        QE,
                        QE
                        ),
                      andR(2) ; <(
                        allL({`t_`}, -11) ; implyL(-11) ; <(
                          hideR(1=={`-t_+T>(xg-(A()/2*t_^2+vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideR(1=={`A()*t_+vr<=A()*ep()`}) ; QE,
                          andL(-11) ; hideL(-11=={`A()/2*t_^2+vr*t_+xr<=xg-GDelta()`}) ; hideL(-5=={`GDelta()>Vmax()*ep()+Vmax()^2/(2*b())`}) ; edit({`-t_+T>(xg-(A()/2*t_^2+vr*t_+xr)-GDelta())/(A()*ep())+abbrv(ep()+Vmax()/b())`}, 1) ; edit({`T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+abbrv`}, -11) ; hideL(-14=={`abbrv=ep()+Vmax()/b()`}) ; edit({`vr+A()*t_<=Vmax()`}, -8) ; QE
                          ),
                        QE
                        )
                      )
                    )
                  )
                )
              )
            ),
          implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
            hideL(-9=={`vr>=A()*ep()&T>(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()|vr<=A()*ep()&T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideL(-10=={`xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr)>=xg+GDelta()|vr+A()*ep()>Vmax()`}) ; QE,
            andR(1) ; <(
              hideL(-8=={`xr+vr^2/(2*b()) < xg+GDelta()`}) ; allL({`t_`}, -12) ; implyL(-12) ; <(
                hideR(1=={`xg-GDelta() < vr*t_+xr->vr=0|-t_+T>=vr/b()`}) ; QE,
                orL(-8) ; <(
                  orL(-10) ; <(
                    QE,
                    QE
                    ),
                  implyR(1) ; orR(1) ; orL(-10) ; <(
                    QE,
                    QE
                    )
                  )
                ),
              implyR(1) ; orR(1) ; fullSimplify ; orL(-9) ; <(
                hideR(2=={`vr<=A()*ep()&-t_+T>ep()-vr/A()+(xg-(vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; andL(-9) ; fullSimplify ; orL(-10) ; <(
                  edit({`-t_+T>(xg-(vr*t_+xr)-GDelta())/(A()*ep())+abbrv(ep()+Vmax()/b())`}, 1) ; edit({`T>(xg-xr-GDelta())/(A()*ep())+abbrv`}, -15) ; hideL(-16=={`abbrv=ep()+Vmax()/b()`}) ; allL({`t_`}, -12) ; implyL(-12) ; <(
                    QE,
                    hideL(-10=={`xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr)>=xg+GDelta()`}) ; hideL(-5=={`GDelta()>Vmax()*ep()+Vmax()^2/(2*b())`}) ; QE
                    ),
                  allL({`t_`}, -12) ; implyL(-12) ; <(
                    QE,
                    edit({`-t_+T>(xg-(vr*t_+xr)-GDelta())/(A()*ep())+abbrv(ep()+Vmax()/b())`}, 1) ; edit({`T>(xg-xr-GDelta())/(A()*ep())+abbrv`}, -15) ; hideL(-16=={`abbrv=ep()+Vmax()/b()`}) ; hideL(-8=={`xr+vr^2/(2*b()) < xg+GDelta()`}) ; hideL(-5=={`GDelta()>Vmax()*ep()+Vmax()^2/(2*b())`}) ; QE
                    )
                  ),
                allL({`t_`}, -13) ; implyL(-13) ; <(
                  hideR(1=={`vr>=A()*ep()&-t_+T>(xg-(vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideR(1=={`vr<=A()*ep()&-t_+T>ep()-vr/A()+(xg-(vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; QE,
                  andL(-9) ; fullSimplify ; hideR(1=={`vr>=A()*ep()&-t_+T>(xg-(vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideR(1=={`-t_+T>ep()-vr/A()+(xg-(vr*t_+xr)-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; orL(-10) ; <(
                    hideL(-15=={`T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; hideL(-9=={`xr<=xg-GDelta()`}) ; QE,
                    hideL(-15=={`T>ep()-vr/A()+(xg-xr-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ; QE
                    )
                  )
                )
              )
            )
          )
        )
      ),
    notGreater(1.0.0.0.0.1.0.0) ; notAnd(1.0.0.0.0.1.1.1.0.0) ; iterated(1) ; orR(1) ; composed(2) ; solve(2.1) ; composed(2) ; choiced(2) ; orR(2) ;
    hideR(2=={`<?xr_1>xg-GDelta();{ar:=-b();++?vr_1=0;ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr_1>=0)&\exists T (T=-t_+T_1&\exists vr (vr=ar*t_+vr_1&\exists xr (xr=ar/2*t_^2+vr_1*t_+xr_1&<{{{?xr>xg-GDelta();{ar:=-b();++?vr=0;ar:=0;}++?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}}t:=0;}{xr'=vr,vr'=ar,t'=1,T'=-1&t<=ep()&vr>=0}}*>(xg-GDelta() < xr&vr=0)))))`}) ; composed(2) ; andL('L)* ; testd(2) ; hideL(-8=={`T_1>ep()+(xg-xr_1-GDelta())/(A()*ep())+ep()+Vmax()/b()`}) ;
    simplify(2) ; choiced(2) ; orR(2) ; composed(2) ; testd(2) ; andR(2) ; <(
      hideR(3=={`<?!xr_1+vr_1^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr_1) < xg+GDelta()|!vr_1+A()*ep()<=Vmax();ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr_1>=0)&\exists T (T=-t_+T_1&\exists vr (vr=ar*t_+vr_1&\exists xr (xr=ar/2*t_^2+vr_1*t_+xr_1&<{{{?xr>xg-GDelta();{ar:=-b();++?vr=0;ar:=0;}++?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}}t:=0;}{xr'=vr,vr'=ar,t'=1,T'=-1&t<=ep()&vr>=0}}*>(xg-GDelta() < xr&vr=0)))))`}) ;
      QE
      ,
      hideR(3=={`<?!xr_1+vr_1^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr_1) < xg+GDelta()|!vr_1+A()*ep()<=Vmax();ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr_1>=0)&\exists T (T=-t_+T_1&\exists vr (vr=ar*t_+vr_1&\exists xr (xr=ar/2*t_^2+vr_1*t_+xr_1&<{{{?xr>xg-GDelta();{ar:=-b();++?vr=0;ar:=0;}++?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}}t:=0;}{xr'=vr,vr'=ar,t'=1,T'=-1&t<=ep()&vr>=0}}*>(xg-GDelta() < xr&vr=0)))))`}) ;
      assignd(2) ; assignd(2) ; existsR({`ep()`}, 2) ; andR(2) ; <(
        QE
        ,
        andR(2) ; <(
          QE
          ,
          existsR({`-ep()+T_1`}, 2) ; simplify(2) ; existsR({`A()*ep()+vr_1`}, 2) ; simplify(2) ;
          existsR({`A()/2*ep()^2+vr_1*ep()+xr_1`}, 2) ; simplify(2) ;
          useAt({`<*> merge`}, {`1`}, 2) ; hideL(-8=={`T=-ep()+T_1`}) ;
          con({`u`}, {`Vmax()>0&A()>0&b()>0&ep()>0&0 < vr&vr<=Vmax()&(xg-GDelta() < xr|xg-GDelta() < xr+u*ep()*vr)`}, 2) ; <(
            QE,
            andL('L)* ; edit({`xg-GDelta() < xr`}, -8) ; hideL(-1=={`u<=0`}) ; useAt({`<*> merge`}, {`1`}, 1) ;
            con({`v`}, {`Vmax()>0&A()>0&b()>0&ep()>0&vr>=0&vr-v*ep()*b()<=b()*ep()&xg-GDelta() < xr`}, 1) ; <(
              QE
              ,
              andL('L)* ; edit({`vr<=b()*ep()`}, -7) ; hideL(-1=={`v<=0`}) ; iterated(1) ; orR(1) ; composed(2) ; solve(2.1) ;
              composed(2) ; choiced(2) ; orR(2) ; composed(2) ; testd(2) ; simplify(2) ;
              hideR(3=={`<?xr_2<=xg-GDelta();{?xr_2+vr_2^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr_2) < xg+GDelta()&vr_2+A()*ep()<=Vmax();ar:=A();++?!xr_2+vr_2^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr_2) < xg+GDelta()|!vr_2+A()*ep()<=Vmax();ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr_2>=0)&\exists T (T=-t_+T_1&\exists vr (vr=ar*t_+vr_2&\exists xr (xr=ar/2*t_^2+vr_2*t_+xr_2&<{{{?xr>xg-GDelta();{ar:=-b();++?vr=0;ar:=0;}++?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}}t:=0;}{xr'=vr,vr'=ar,t'=1,T'=-1&t<=ep()&vr>=0}}*>(xg-GDelta() < xr&vr=0)))))`}) ;
              choiced(2) ; orR(2) ;
              hideR(3=={`<?vr_2=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr_2>=0)&\exists T (T=-t_+T_1&\exists vr (vr=ar*t_+vr_2&\exists xr (xr=ar/2*t_^2+vr_2*t_+xr_2&<{{{?xr>xg-GDelta();{ar:=-b();++?vr=0;ar:=0;}++?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}}t:=0;}{xr'=vr,vr'=ar,t'=1,T'=-1&t<=ep()&vr>=0}}*>(xg-GDelta() < xr&vr=0)))))`}) ;
              assignd(2) ; assignd(2) ; existsR({`vr_2/b()`}, 2) ; andR(2) ; <(
                QE,
                andR(2) ; <(
                  QE,
                  existsR({`-vr_2/b()+T_1`}, 2) ; simplify(2) ; existsR({`0`}, 2) ; andR(2) ; <(
                    QE,
                    existsR({`vr_2^2/(2*b())+xr_2`}, 2) ; andR(2) ; <(
                      QE,
                      con({`w`}, {`Vmax()>0&A()>0&b()>0&ep()>0&vr=0&xg-GDelta() < xr`}, 2) ; <(
                        QE,
                        QE,
                        composed(1) ; solve(1.1) ; composed(1) ; andL('L)* ; choiced(1) ; orR(1) ;
                        hideR(2=={`<?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&ar*t_+vr=0&xg-GDelta() < ar/2*t_^2+vr*t_+xr)`}) ; composed(1) ; testd(1) ; simplify(1) ; choiced(1) ; orR(1) ; hideR(1=={`<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&ar*t_+vr=0&xg-GDelta() < ar/2*t_^2+vr*t_+xr)`}) ;
                        composed(1) ; testd(1) ; simplify(1) ; assignd(1) ; assignd(1) ; fullSimplify ; QE
                      )
                    )
                  )
                )
              )
              ,
              andL('L)* ; composed(1) ; solve(1.1) ; composed(1) ; choiced(1) ; orR(1) ;
              hideR(2=={`<?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&ar*t_+vr-(v-1)*ep()*b()<=b()*ep()&xg-GDelta() < ar/2*t_^2+vr*t_+xr)`}) ; composed(1) ; testd(1) ; simplify(1) ; choiced(1) ; orR(1) ; hideR(2=={`<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&ar*t_+vr-(v-1)*ep()*b()<=b()*ep()&xg-GDelta() < ar/2*t_^2+vr*t_+xr)`}) ;
              assignd(1) ; assignd(1) ; QE
            )
            ,
            andL('L)* ; composed(1) ; solve(1.1) ; composed(1) ; choiced(1) ; orR(1) ; composed(1) ; testd(1) ;
            hideL(-12=={`ep()>0`}) ; hideL(-11=={`b()>0`}) ; hideL(-10=={`A()>0`}) ; orL(-12=={`xg-GDelta() < xr|xg-GDelta() < xr+u*ep()*vr`}) ; <(
              hideL(-4=={`xr_1 < xg-GDelta()`}) ; hideL(-3=={`vr_1=0`}) ;
              simplify(1) ;
              hideR(2=={`<?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < ar*t_+vr&ar*t_+vr<=Vmax()&(xg-GDelta() < ar/2*t_^2+vr*t_+xr|xg-GDelta() < ar/2*t_^2+vr*t_+xr+(u-1)*ep()*(ar*t_+vr)))`}) ;
              choiced(1) ; orR(1) ;
              hideR(2=={`<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < ar*t_+vr&ar*t_+vr<=Vmax()&(xg-GDelta() < ar/2*t_^2+vr*t_+xr|xg-GDelta() < ar/2*t_^2+vr*t_+xr+(u-1)*ep()*(ar*t_+vr)))`}) ;
              assignd(1) ; assignd(1) ;
              existsR({`min(ep(),vr/b())/2`}, 1) ; andR(1) ; <(
                QE,
                andR(1) ; <(
                  QE,
                  fullSimplify ; andR(1) ; doall(QE)
                )
              )
              ,
              cut({`xr>xg-GDelta()&(xr>xg-GDelta()-><ar:=-b();++?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < ar*t_+vr&ar*t_+vr<=Vmax()&(xg-GDelta() < ar/2*t_^2+vr*t_+xr|xg-GDelta() < ar/2*t_^2+vr*t_+xr+(u-1)*ep()*(ar*t_+vr))))`}) ; <(
                hideR(2=={`<?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < ar*t_+vr&ar*t_+vr<=Vmax()&(xg-GDelta() < ar/2*t_^2+vr*t_+xr|xg-GDelta() < ar/2*t_^2+vr*t_+xr+(u-1)*ep()*(ar*t_+vr)))`}) ;
                andL('Llast) ; fullSimplify ; closeTrue
                ,
                hideR(1=={`xr>xg-GDelta()&<ar:=-b();++?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < ar*t_+vr&ar*t_+vr<=Vmax()&(xg-GDelta() < ar/2*t_^2+vr*t_+xr|xg-GDelta() < ar/2*t_^2+vr*t_+xr+(u-1)*ep()*(ar*t_+vr)))`}) ;
                andR(2) ; <(
                  composed(1) ; testd(1) ; andR(1) ; <(
                    QE,
                    choiced(1) ; orR(1) ; composed(2) ; testd(2) ; andR(2) ; <(
                      composed(3) ; testd(3) ; andR(3) ; <(
                        prop,
                        assignd(3) ; assignd(3) ; existsR({`ep()`}, 3) ; fullSimplify ; QE
                      )
                      ,
                      assignd(2) ; assignd(2) ; composed(3) ; testd(3) ; andR(3) ; <(
                        fullSimplify ; orR(3) ; existsR({`ep()`}, 2) ; andR(2) ; <(
                          QE,
                          andR(2) ; <(
                            QE,
                            andR(2) ; <(
                              QE,
                              andR(2) ; <(
                                QE,
                                orR(2) ; QE
                              )
                            )
                          )
                        )
                        ,
                        assignd(3) ; assignd(3) ; existsR({`ep()`}, 3) ;
                        hideR(2=={`\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+0<=ep()&A()*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < A()*t_+vr&A()*t_+vr<=Vmax()&(xg-GDelta() < A()/2*t_^2+vr*t_+xr|xg-GDelta() < A()/2*t_^2+vr*t_+xr+(u-1)*ep()*(A()*t_+vr)))`}) ;
                        fullSimplify ; QE
                      )
                    )
                  )
                  ,
                  hideR(1=={`<?xr<=xg-GDelta();{?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()&vr+A()*ep()<=Vmax();ar:=A();++?!xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < xg+GDelta()|!vr+A()*ep()<=Vmax();ar:=0;}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < ar*t_+vr&ar*t_+vr<=Vmax()&(xg-GDelta() < ar/2*t_^2+vr*t_+xr|xg-GDelta() < ar/2*t_^2+vr*t_+xr+(u-1)*ep()*(ar*t_+vr)))`}) ;
                  implyR(1) ; choiced(1) ; orR(1) ;
                  hideR(2=={`<?vr=0;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0)&Vmax()>0&A()>0&b()>0&ep()>0&0 < ar*t_+vr&ar*t_+vr<=Vmax()&(xg-GDelta() < ar/2*t_^2+vr*t_+xr|xg-GDelta() < ar/2*t_^2+vr*t_+xr+(u-1)*ep()*(ar*t_+vr)))`}) ;
                  assignd(1) ; assignd(1) ;
                  existsR({`min(ep(),vr/b())/2`}, 1) ; andR(1) ; <(
                    QE,
                    andR(1) ; <(
                      QE,
                      fullSimplify ; andR(1) ; doall(QE)
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
End.

End.

Lemma "Cross intersection with deadline - Safety".

/*
 *	Robot must safely cross an intersection.
 *
 *  Robot
 * 	- must cross intersection safely
 *  - can only drive straight and forward
 *  - ensures progress towards intersection
 *
 *  Obstacle
 *  - Drives forward with minimum speed (does not block intersection)
 *
 *  Intersection
 *  - At position 0 (on both the robot's and the obstacle's path)
 *
 *  Liveness property:
 *  - Robot can cross intersection
 *
 *  Safety property:
 *  - Robot always crosses intersection before deadline
 *  - Robot and obstacle are not at the intersection at the same time
 *
 */

Definitions.
	R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
	R Vmin().    /* obstacle minimum speed */
	R ixr() = ( 0 ). /* position of intersection on path of robot */
	R ixo() = ( 0 ). /* position of intersection on path of obstacle */
	R D().       /* Deadline */

	R min(R,R).
	R max(R,R).

	R minV() = ( A()*ep() ).

	R stopDist(R v) = ( v^2/(2*b()) ).
	R accComp(R v)  = ( (A()/b() + 1)*(A()/2*ep()^2 + ep()*v) ).

	B OAfterX(R xo) <-> ( xo>ixo() ).
	B RAfterX(R xr) <-> ( xr>ixr() ).

	B bounds() <-> (                                                                     /* Bounds for global constants */
      A() > 0                                                                                       /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & Vmin() > 0
    & D() >= ep() & RAfterX(xr + A()/2*(D() - ep)^2)
  ).
  B initialState() <-> (                                                   /* Somewhere before intersection initially */
    vr = 0
    & vo>=Vmin()
    & xr < ixr()
    & ixr()-xr < A()/2*(D()-ep())^2
    & T = min(0, (xo-ixo())/Vmin()) - ep()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

	B safetyloopinv() <-> (
	  0 <= vr & Vmin()<=vo & (RAfterX(xr) | OAfterX(xo) | xr + stopDist(vr) < ixr() |
	    (vr>0 & ( xo+vo*(ixr()-xr)/vr+A/2*((ixr()-xr)/vr)^2 < ixo()
              | ixo() < xo + Vmin()*(ixr()-xr)/vr))
    )
	).

  B deadlineloopinv() <-> (
    0 <= vr & Vmin()<=vo
    & T <= (xo-ixo())/Vmin()
    & ( T <= 0 & RAfterX(xr + A()/2*(D() - ep)^2)
      | T > 0 & RAfterX(xr + vr*(max(0,D()-T)) + A()/2*(max(0,D()-T))^2) )
  ).

  HP obstacle ::= { ao := *; ?-b()<=ao&ao<=A(); }.

  HP robot ::= {
    if (OAfterX(xo)) {
      ar := A();
    } else { if (RAfterX(xr)) {
      ar := *; ?-b()<=ar&ar<=A();
    } else { if (/*PassFaster*/ vr>0 & ( xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()
                                       | ixo() < xo + Vmin()*(ixr()-xr)/(vr+A()*ep()) ) ) {
      ar := *; ?0<=ar&ar<=A();
    } else { if (/*PassCoast*/ vr>0 & ixo() < xo + Vmin()*(ixr()-xr)/vr) {
      ar := 0;
    } else {         /* 1D Model 3 */
        ar := -b();
     ++ ?vr = 0; ar := 0;
     ++ ?xr + stopDist(vr) + accComp(vr) < ixr(); ar := A();
    }}}}
  }.

  HP dyn ::= { {xr' = vr, vr' = ar, xo'=vo, vo'=ao, t' = 1, T'=1 & t <= ep() & vr >= 0 & vo>=Vmin() } }.

  HP dwcxd ::= {
    {
      obstacle;
      { robot; t := 0; }
      dyn;
    }*@invariant(loopinv())
  }.

End.

ProgramVariables.
	R xr.		/* robot position: x */
	R vr.		/* robot translational velocity */
	R ar.		/* robot translational acceleration */
	R xo.		/* obstacle position */
	R vo.   /* obstacle velocity */
	R ao.   /* obstacle acceleration */
	R t.		/* control cycle time */
	R T.    /* remaining time until robot must start driving (i.e., until obstacle has passed the intersection) */
End.

Problem.
  assumptions() -> [ dwcxd; ]( (xr=ixr() -> xo!=ixo()) & (T>=D() -> RAfterX(xr)) )
End.

Tactic "Proof Lemma: Cross intersection with deadline - Safety".

tactic leafQE as ( print({`Proving arithmetic`}); QE; done );
tactic unfoldQEL as ( (doall(orL('L)))*; doall(leafQE; done); done );

implyR(1) ; boxAnd(1) ; andR(1) ; <(
loop({`0<=vr&Vmin()<=vo&(xr>0|xo>0|xr+vr^2/(2*b()) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr))`}, 1) ; <(
  leafQE,
  leafQE,
  boxAnd(1) ; andR(1) ; <(
    composeb(1) ; composeb(1.1) ; GV(1) ; GV(1.0) ; unfold ; dW(1) ; leafQE,
    notAnd(1.0.1.0.0.1.1.1.1.1.1.1.0.0) ; notGreater(1.0.1.0.0.1.1.1.1.1.1.1.0.0.0) ; notLess(1.0.1.0.0.1.1.1.1.1.1.1.0.0.1) ; notAnd(1.0.1.0.0.1.1.1.1.1.0.0) ; notOr(1.0.1.0.0.1.1.1.1.1.0.0.1) ; notLess(1.0.1.0.0.1.1.1.1.1.0.0.1.0) ; notLess(1.0.1.0.0.1.1.1.1.1.0.0.1.1) ; notGreater(1.0.1.0.0.1.1.1.0.0) ; notGreater(1.0.1.0.0.1.1.1.1.1.0.0.0) ; unfold ; <(
      diffInvariant({`xo>=old(xo)`}, 1) ; dW(1) ; leafQE
      ,
      diffInvariant({`xr>=old(xr)`}, 2) ; dW(2) ; leafQE
      ,
      fullSimplify ; hideL(-5=={`D()>=ep()`}) ;
      diffInvariant({`t>=0&vr=old(vr)+ar*t&vo=old(vo)+ao*t`}, 2) ;
      diffInvariant({`xr=old(xr)+old(vr)*t+ar*t^2/2&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 2) ;
      dW(2) ; implyR(2) ; andR(2) ; <(
        hideL(-6=={`xo_0>0|xr_0+vr_0^2/(2*b()) < 0|xo_0+vo_0*(-xr_0)/vr_0+A()/2*((-xr_0)/vr_0)^2 < 0|0 < xo_0+Vmin()*(-xr_0)/vr_0`}) ; hideL(-10=={`xo_0+vo_0*(-xr_0)/vr_0+A()/2*((-xr_0)/vr_0)^2 < 0|0 < xo_0+Vmin()*(-xr_0)/(vr_0+A()*ep())`}) ; leafQE,
        orR(2) ; orR(3) ; orR(4) ; hideL(-6=={`xo_0>0|xr_0+vr_0^2/(2*b()) < 0|xo_0+vo_0*(-xr_0)/vr_0+A()/2*((-xr_0)/vr_0)^2 < 0|0 < xo_0+Vmin()*(-xr_0)/vr_0`}) ; andR(5) ; <(
          leafQE,
          orR(5) ; andL('L)* ; orL(-10) ; <(
            edit({`vr_0<=vr&vr<=vr_0+A()*t`}, -24) ; hideL(-20=={`t<=ep()`}) ; hideL(-3=={`ep()>0`}) ; edit({`xr_0+vr_0*t<=xr&xr<=xr_0+vr_0*t+A()*t^2/2`}, -17) ; edit({`xo_0+Vmin()*t<=xo&xo<=xo_0+vo_0*t+A()*t^2/2`}, -18) ; edit({`vo<=vo_0+A()*t`}, -23) ; hideL(-5=={`-b()<=ao`}) ; hideL(-5=={`ao<=A()`}) ; hideL(-8=={`0<=ar`}) ; hideL(-8=={`ar<=A()`}) ; edit({`vo>0`}, -17) ; edit({`vo_0>0`}, -4) ; hideL(-2=={`b()>0`}) ; allL2R(-7) ; hideL(-7=={`t_0=0`}) ; allL2R(-7) ; hideL(-7=={`vr_0=vr_1`}) ; allL2R(-7) ; hideL(-7=={`vo_0=vo_1`}) ; allL2R(-7) ; hideL(-7=={`xr_0=xr_1`}) ; allL2R(-7) ; hideL(-7=={`xo_0=xo_1`}) ; hideR(6=={`0 < xo+Vmin()*(-xr)/vr`}) ; hideR(4=={`xr+vr^2/(2*b()) < 0`}) ; hideR(3=={`xo>0`}) ; hideR(1=={`xo_1>0`}) ; leafQE,
            edit({`0 < xo_0+Vmin()*(-xr_0)/(vr_0+A()*t)`}, -10) ; hideL(-20=={`t<=ep()`}) ; hideL(-3=={`ep()>0`}) ; hideR(1=={`xo_0>0`}) ; hideR(4=={`xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < 0`}) ; hideR(3=={`xr+vr^2/(2*b()) < 0`}) ; edit({`!xr<=0`}, 1) ; edit({`!xo<=0`}, 2) ; hideL(-5=={`-b()<=ao`}) ; hideL(-2=={`b()>0`}) ; notR(2) ; notR(1) ; edit({`vr_0<=vr&vr<=vr_0+A()*t`}, -20) ; edit({`xr_0+vr_0*t<=xr&xr<=xr_0+vr_0*t+A()*t^2/2`}, -15) ; edit({`xo_0+Vmin()*t<=xo&xo<=xo_0+vo_0*t+A()*t^2/2`}, -16) ; edit({`vo<=vo_0+A()*t`}, -21) ; hideL(-8=={`0<=ar`}) ; hideL(-8=={`ar<=A()`}) ; hideL(-4=={`ao<=A()`}) ; hideL(-7=={`t_0=0`}) ; edit({`0 < vr`}, -14) ; allL2R(-7) ; hideL(-7=={`vr_0=vr_1`}) ; allL2R(-7) ; hideL(-7=={`vo_0=vo_1`}) ; allL2R(-7) ; hideL(-7=={`xr_0=xr_1`}) ; allL2R(-7) ; hideL(-7=={`xo_0=xo_1`}) ; andL(-12) ; hideL(-15=={`vr_1<=vr`}) ; leafQE
            )
          )
        )
      ,
      fullSimplify ; andL(-11) ; fullSimplify ; hideR(1=={`xo>0`}) ;
      diffInvariant({`t>=0&vr=old(vr)&vo=old(vo)+ao*t`}, 1) ;
      diffInvariant({`xr=old(xr)+old(vr)*t&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ;
      dW(1) ; implyR(1) ; andR(1) ; <(
        leafQE,
        orR(1) ; orR(2) ; orR(3) ; hideR(1=={`xr>0`}) ; hideR(1=={`xo>0`}) ; hideR(1=={`xr+vr^2/(2*b()) < 0`}) ; andR(1) ; <(
          leafQE,
          orR(1) ; hideR(1=={`xo+vo*(-xr)/vr+A()/2*((-xr)/vr)^2 < 0`}) ; hideL(-13=={`xo_0+vo_0*(-xr_0)/vr_0+A()/2*((-xr_0)/vr_0)^2>=0`}) ; leafQE
          )
        )
      ,
      fullSimplify ; orL(-8) ; <(
        diffInvariant({`t>=0&vr=old(vr)-b()*t`}, 2) ;
        diffInvariant({`xr=old(xr)+old(vr)*t-b()*t^2/2`}, 2) ;
        dW(2) ; leafQE
        ,
        diffInvariant({`t>=0&vr=old(vr)-b()*t`}, 2) ;
        diffInvariant({`xr=old(xr)+old(vr)*t-b()*t^2/2`}, 2) ;
        dW(2) ; leafQE
        ),
      hideL(-13=={`vr<=0|0>=xo+Vmin()*(0-xr)/vr`}) ;
      hideL(-12=={`vr<=0|xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2>=0&0>=xo+Vmin()*(0-xr)/(vr+A()*ep())`}) ;
      diffInvariant({`vr=old(vr)`}, 2) ;
      diffInvariant({`xr=old(xr)`}, 2) ;
      orL(-8) ; <(
        hideR(2=={`[{xr'=vr,vr'=0,xo'=vo,vo'=ao,t'=1,T'=1&((t<=ep()&vr>=0&vo>=Vmin())&vr=vr_0)&xr=xr_0}](Vmin()<=vo&(xr>0|xo>0|xr+vr^2/(2*b()) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)))`}) ; leafQE,
        orL(-8) ; <(
          closeId,
          dW(2) ; orL(-8) ; <(
            leafQE,
            andL(-8) ; hideR(2=={`((t<=ep()&vr>=0&vo>=Vmin())&vr=vr_0)&xr=xr_0->Vmin()<=vo&(xr>0|xo>0|xr+vr^2/(2*b()) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr))`}) ; leafQE
            )
          )
        ),
      diffInvariant({`t>=0&vr=old(vr)+A()*t`}, 2) ;
      diffInvariant({`xr=old(xr)+old(vr)*t+A()*t^2/2`}, 2) ;
      dW(2) ; implyR(2) ; andR(2) ; <(
        leafQE,
        orR(2) ; orR(3) ; orR(4) ; hideL(-15=={`t_0=0`}) ; allL2R(-15) ; hideL(-15=={`vr_0=vr_1`}) ; allL2R(-15) ; hideL(-15=={`xr_0=xr_1`}) ; hideL(-9=={`-b()<=ao`}) ; hideL(-9=={`ao<=A()`}) ; hideL(-5=={`D()>=ep()`}) ; hideR(1=={`xo_0>0`}) ; hideR(4=={`vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr)`}) ; hideR(1=={`xr>0`}) ; hideR(1=={`xo>0`}) ; orL(-7) ; <(
          hideR(1=={`xr+vr^2/(2*b()) < 0`}) ; leafQE,
          hideL(-7=={`xo_0>0|xr_1+vr_1^2/(2*b()) < 0|vr_1>0&(xo_0+vo_0*(0-xr_1)/vr_1+A()/2*((0-xr_1)/vr_1)^2 < 0|0 < xo_0+Vmin()*(0-xr_1)/vr_1)`}) ; orL(-9) ; <(
            fullSimplify ; leafQE,
            orL(-8) ; <(
              leafQE,
              hideL(-8=={`xo_0+vo_0*(0-xr_1)/vr_1+A()/2*((0-xr_1)/vr_1)^2>=0&0>=xo_0+Vmin()*(0-xr_1)/(vr_1+A()*ep())`}) ; leafQE
              )
            )
          )
        )
      )
    )
  ),
loop({`0<=vr&Vmin()<=vo&T<=(xo-0)/Vmin()&(T<=0&xr+A()/2*(D()-ep())^2>0|T>0&xr+vr*max((0,D()-T))+A()/2*max((0,D()-T))^2>0)`}, 1) ; <(
  leafQE,
  leafQE,
  notAnd(1.0.1.0.0.1.1.1.1.1.1.1.0.0) ; notGreater(1.0.1.0.0.1.1.1.1.1.1.1.0.0.0) ; notLess(1.0.1.0.0.1.1.1.1.1.1.1.0.0.1) ; notAnd(1.0.1.0.0.1.1.1.1.1.0.0) ; notOr(1.0.1.0.0.1.1.1.1.1.0.0.1) ; notLess(1.0.1.0.0.1.1.1.1.1.0.0.1.0) ; notLess(1.0.1.0.0.1.1.1.1.1.0.0.1.1) ; notGreater(1.0.1.0.0.1.1.1.0.0) ; notGreater(1.0.1.0.0.1.1.1.1.1.0.0.0) ; boxAnd(1) ; andR(1) ; <(
    composeb(1) ; composeb(1.1) ; GV(1) ; GV(1.0) ; unfold ; dW(1) ; leafQE,
    boxAnd(1) ; andR(1) ; <(
      composeb(1) ; composeb(1.1) ; GV(1) ; GV(1.0) ; unfold ; dW(1) ; leafQE,
      boxAnd(1) ; andR(1) ; <(
        composeb(1) ; composeb(1.1) ; composeb(1.1) ; GV(1.1) ; unfold ;
        diffInvariant({`t>=0&T=old(T)+t&vo=old(vo)+ao*t`}, 1) ;
        diffInvariant({`xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ;
        dW(1) ; leafQE
        ,
        unfold ; <(
          diffInvariant({`t>=0&T=old(T)+t&vr=old(vr)+A()*t`}, 1) ;
          diffInvariant({`xr=old(xr)+old(vr)*t+A()*t^2/2`}, 1) ;
          dW(1) ; leafQE
          ,
          hideR(1=={`xo>0`}) ;
          diffInvariant({`t>=0&T=old(T)+t&vr=old(vr)+ar*t&vo=old(vo)+ao*t`}, 1) ;
          diffInvariant({`xr=old(xr)+old(vr)*t+ar*t^2/2&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 1) ;
          dW(1) ; implyR(1) ; orR(1) ; edit({`T>0&xr+vr*abbrv(max((0,D()-T)))+A()/2*max((0,D()-T))^2>0`}, 2) ; edit({`abbrv=expand(max((0,D()-T)))`}, -17) ; edit({`T_0<=0&xr_0+A()/2*(D()-ep())^2>0|T_0>0&xr_0+vr_0*max((0,D()-T_0))+A()/2*abbrv(max((0,D()-T_0)))^2>0`}, -9) ; edit({`abbrv_0=expand(max((0,D()-T_0)))`}, -19) ; andR(1) ; <(
            andR(2) ; <(
              leafQE,
              hideR(1=={`T<=0`}) ; hideL(-9=={`T_0<=0&xr_0+A()/2*(D()-ep())^2>0|T_0>0&xr_0+vr_0*abbrv_0+A()/2*abbrv_0^2>0`}) ; hideL(-19=={`0>=D()-T_0&max_1=0|0 < D()-T_0&max_1=D()-T_0`}) ; orL(-17) ; <(
                leafQE,
                leafQE
                )
              ),
            orL(-9) ; <(
              orL(-18) ; <(
                orL(-20) ; <(
                  leafQE,
                  leafQE
                  ),
                hideR(2=={`T>0&xr+vr*abbrv+A()/2*abbrv^2>0`}) ; leafQE
                ),
              hideR(2=={`T>0&xr+vr*abbrv+A()/2*abbrv^2>0`}) ; orL(-18) ; <(
                orL(-20) ; <(
                  leafQE,
                  leafQE
                  ),
                orL(-20) ; <(
                  leafQE,
                  leafQE
                  )
                )
              )
            ),
          diffInvariant({`t>=0&T=old(T)+t&vr>=old(vr)&vo=old(vo)+ao*t`}, 2) ;
          diffInvariant({`xr>=old(xr)+old(vr)*t&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 2) ;
          dW(2) ; implyR(2) ; orR(2) ; hideL(-14=={`xo_0+vo_0*(0-xr_0)/vr_0+A()/2*((0-xr_0)/vr_0)^2 < 0|0 < xo_0+Vmin()*(0-xr_0)/(vr_0+A()*ep())`}) ; edit({`T>0&xr+vr*abbrv(max((0,D()-T)))+A()/2*max((0,D()-T))^2>0`}, 3) ; edit({`abbrv=expand(max((0,D()-T)))`}, -23) ; edit({`T_0<=0&xr_0+A()/2*(D()-ep())^2>0|T_0>0&xr_0+vr_0*abbrv(max((0,D()-T_0)))+A()/2*max((0,D()-T_0))^2>0`}, -9) ; edit({`abbrv_0=expand(max((0,D()-T_0)))`}, -25) ; andR(2) ; <(
            andR(3) ; <(
              leafQE,
              unfoldQEL
              ),
            andR(3) ; <(
              hideL(-26=={`0>=D()-T_0&max_1=0|0 < D()-T_0&max_1=D()-T_0`}) ; hideL(-24=={`0>=D()-T&max_0=0|0 < D()-T&max_0=D()-T`}) ; orL(-9) ; <(
                leafQE,
                leafQE
                ),
              hideR(2=={`xr+A()/2*(D()-ep())^2>0`}) ;
              unfoldQEL
              )
            ),
          diffInvariant({`t>=0&T=old(T)+t&vr=old(vr)&vo=old(vo)+ao*t`}, 2) ;
          diffInvariant({`xr=old(xr)+old(vr)*t&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 2) ;
          dW(2) ; hideR(1=={`xo_0>0`}) ; implyR(1) ; orR(1) ; edit({`T>0&xr+vr*abbrv(max((0,D()-T)))+A()/2*max((0,D()-T))^2>0`}, 2) ; edit({`abbrv=expand(max((0,D()-T)))`}, -23) ; edit({`T_0<=0&xr_0+A()/2*(D()-ep())^2>0|T_0>0&xr_0+vr_0*max((0,D()-T_0))+A()/2*abbrv(max((0,D()-T_0)))^2>0`}, -9) ; edit({`abbrv_0=expand(max((0,D()-T_0)))`}, -25) ; andR(1) ; <(
            andR(2) ; <(
              leafQE,
              hideL(-26=={`0>=D()-T_0&max_1=0|0 < D()-T_0&max_1=D()-T_0`}) ; orL(-9) ; <(
                orL(-24) ; <(
                  leafQE,
                  hideL(-13=={`vr_0<=0|xo_0+vo_0*(0-xr_0)/vr_0+A()/2*((0-xr_0)/vr_0)^2>=0&0>=xo_0+Vmin()*(0-xr_0)/(vr_0+A()*ep())`}) ; leafQE
                  ),
                orL(-24) ; <(
                  leafQE,
                  leafQE
                  )
                )
              ),
            andR(2) ; <(
              hideL(-13=={`vr_0<=0|xo_0+vo_0*(0-xr_0)/vr_0+A()/2*((0-xr_0)/vr_0)^2>=0&0>=xo_0+Vmin()*(0-xr_0)/(vr_0+A()*ep())`}) ; hideL(-25=={`0>=D()-T_0&max_1=0|0 < D()-T_0&max_1=D()-T_0`}) ;
              unfoldQEL,
              unfoldQEL
              )
            ),
          diffInvariant({`t>=0&T=old(T)+t&vr=old(vr)-b()*t&vo=old(vo)+ao*t`}, 2) ;
          diffInvariant({`xr=old(xr)+old(vr)*t-b()*t^2/2&xo=old(xo)+old(vo)*t+ao*t^2/2`}, 2) ;
          dW(2) ; hideR(1=={`xo_0>0`}) ; implyR(1) ; orR(1) ; hideL(-15=={`t_0=0`}) ; edit({`T>0&xr+vr*abbrv(max((0,D()-T)))+A()/2*max((0,D()-T))^2>0`}, 2) ; edit({`abbrv=expand(max((0,D()-T)))`}, -21) ; edit({`T_0<=0&xr_0+A()/2*(D()-ep())^2>0|T_0>0&xr_0+vr_0*abbrv(max((0,D()-T_0)))+A()/2*max((0,D()-T_0))^2>0`}, -9) ; edit({`abbrv_0=expand(max((0,D()-T_0)))`}, -23) ; andR(1) ; <(
            andR(2) ; <(
              leafQE,
              hideL(-13=={`vr_0<=0|xo_0+vo_0*(0-xr_0)/vr_0+A()/2*((0-xr_0)/vr_0)^2>=0&0>=xo_0+Vmin()*(0-xr_0)/(vr_0+A()*ep())`}) ;
              orL(-9) ; <(
                orL(-21) ; <(
                  orL(-23) ; <(
                    leafQE,
                    leafQE
                    ),
                  orL(-23) ; <(
                    leafQE,
                    orL(-13) ; <(
                      leafQE,
                      hideL(-10=={`-b()<=ao`}) ; hideR(1=={`T<=0`}) ; leafQE
                      )
                    )
                  ),
                hideR(1=={`T<=0`}) ; orL(-23) ; <(
                  orL(-21) ; <(
                    leafQE,
                    leafQE
                    ),
                  orL(-21) ; <(
                    leafQE,
                    leafQE
                    )
                  )
                )
              ),
            andR(2) ; <(
              hideL(-13=={`vr_0<=0|xo_0+vo_0*(0-xr_0)/vr_0+A()/2*((0-xr_0)/vr_0)^2>=0&0>=xo_0+Vmin()*(0-xr_0)/(vr_0+A()*ep())`}) ; hideL(-13=={`vr_0<=0|0>=xo_0+Vmin()*(0-xr_0)/vr_0`}) ; orL(-9) ; <(
                leafQE,
                leafQE
                ),
              hideL(-13=={`vr_0<=0|xo_0+vo_0*(0-xr_0)/vr_0+A()/2*((0-xr_0)/vr_0)^2>=0&0>=xo_0+Vmin()*(0-xr_0)/(vr_0+A()*ep())`}) ;
              orL(-9) ; <(
                orL(-21) ; <(
                  orL(-23) ; <(
                    leafQE,
                    leafQE
                    ),
                  orL(-23) ; <(
                    leafQE,
                    hideL(-10=={`-b()<=ao`}) ; orL(-12) ; <(
                      leafQE,
                      hideR(2=={`xr+vr*abbrv+A()/2*abbrv^2>0`}) ; leafQE
                      )
                    )
                  ),
                hideR(1=={`xr+A()/2*(D()-ep())^2>0`}) ;
                unfoldQEL
                )
              )
            )
            ,
            diffInvariant({`t>=0&T=old(T)+t&vr=old(vr)`}, 2) ;
            diffInvariant({`xr=old(xr)+old(vr)*t`}, 2) ;
            diffInvariant({`vo=old(vo)+ao*t`}, 2) ;
            diffInvariant({`xo=old(xo)+old(vo)*t+ao*t^2/2`}, 2) ;
            dW(2) ; implyR(2) ; orR(2) ; leafQE
            ,
            diffInvariant({`t>=0&T=old(T)+t&vr=old(vr)+A()*t`}, 2) ;
            diffInvariant({`xr=old(xr)+old(vr)*t+A()*t^2/2`}, 2) ;
            dW(2) ; implyR(2) ; hideR(1=={`xo>0`}) ; orR(1) ; hideL(-13=={`vr_0<=0|xo+vo_0*(0-xr_0)/vr_0+A()/2*((0-xr_0)/vr_0)^2>=0&0>=xo+Vmin()*(0-xr_0)/(vr_0+A()*ep())`}) ; edit({`T>0&xr+vr*abbrv(max((0,D()-T)))+A()/2*max((0,D()-T))^2>0`}, 2) ; edit({`abbrv=expand(max((0,D()-T)))`}, -20) ; edit({`T_0<=0&xr_0+A()/2*(D()-ep())^2>0|T_0>0&xr_0+vr_0*max((0,D()-T_0))+A()/2*abbrv(max((0,D()-T_0)))^2>0`}, -9) ; edit({`abbrv_0=expand(max((0,D()-T_0)))`}, -22) ; andR(1) ; <(
            andR(2) ; <(
              leafQE,
              hideR(1=={`T<=0`}) ; hideL(-13=={`vr_0<=0|0>=xo+Vmin()*(0-xr_0)/vr_0`}) ;
              unfoldQEL
              ),
            andR(2) ; <(
              hideL(-13=={`vr_0<=0|0>=xo+Vmin()*(0-xr_0)/vr_0`}) ; hideL(-20=={`0>=D()-T&max_0=0|0 < D()-T&max_0=D()-T`}) ; hideL(-21=={`0>=D()-T_0&max_1=0|0 < D()-T_0&max_1=D()-T_0`}) ; leafQE,
              hideR(1=={`xr+A()/2*(D()-ep())^2>0`}) ; hideL(-13=={`vr_0<=0|0>=xo+Vmin()*(0-xr_0)/vr_0`}) ;
              unfoldQEL
              )
            )
          )
        )
      )
    )
  )
)
End.

End.

Theorem "Theorem 15: Cross intersection with deadline".

/*
 *	Robot must safely cross an intersection.
 *
 *  Robot
 * 	- must cross intersection safely
 *  - can only drive straight and forward
 *  - ensures progress towards intersection
 *
 *  Obstacle
 *  - Drives forward with minimum speed (does not block intersection)
 *
 *  Intersection
 *  - At position 0 (on both the robot's and the obstacle's path)
 *
 *  Liveness property:
 *  - Robot can cross intersection
 *
 *  Safety property:
 *  - Robot always crosses intersection before deadline
 *  - Robot and obstacle are not at the intersection at the same time
 *
 */

Definitions.
	R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
	R Vmin().    /* obstacle minimum speed */
	R ixr() = ( 0 ). /* position of intersection on path of robot */
	R ixo() = ( 0 ). /* position of intersection on path of obstacle */
	R D().       /* Deadline */

	R min(R,R).
	R max(R,R).

	R minV() = ( A()*ep() ).

	R stopDist(R v) = ( v^2/(2*b()) ).
	R accComp(R v)  = ( (A()/b() + 1)*(A()/2*ep()^2 + ep()*v) ).

	B OAfterX(R xo) <-> ( xo>ixo() ).
	B RAfterX(R xr) <-> ( xr>ixr() ).

	B bounds() <-> (                                                                     /* Bounds for global constants */
      A() > 0                                                                                       /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & Vmin() > 0
    & D() >= ep() & RAfterX(xr + A()/2*(D() - ep)^2)
  ).
  B initialState() <-> (                                                   /* Somewhere before intersection initially */
    vr = 0
    & vo>=Vmin()
    & xr < ixr()
    & ixr()-xr < A()/2*(D()-ep())^2
    & T = min(0, (xo-ixo())/Vmin()) - ep()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

	B safetyloopinv() <-> (
	  0 <= vr & Vmin()<=vo & (RAfterX(xr) | OAfterX(xo) | xr + stopDist(vr) < ixr() |
	    (vr>0 & ( xo+vo*(ixr()-xr)/vr+A/2*((ixr()-xr)/vr)^2 < ixo()
              | ixo() < xo + Vmin()*(ixr()-xr)/vr))
    )
	).

  B deadlineloopinv() <-> (
    0 <= vr & Vmin()<=vo
    & T <= (xo-ixo())/Vmin()
    & ( T <= 0 & RAfterX(xr + A()/2*(D() - ep)^2)
      | T > 0 & RAfterX(xr + vr*(max(0,D()-T)) + A()/2*(max(0,D()-T))^2) )
  ).

  HP obstacle ::= { ao := *; ?-b()<=ao&ao<=A(); }.

  HP robot ::= {
    if (OAfterX(xo)) {
      ar := A();
    } else { if (RAfterX(xr)) {
      ar := *; ?-b()<=ar&ar<=A();
    } else { if (/*PassFaster*/ vr>0 & ( xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()
                                       | ixo() < xo + Vmin()*(ixr()-xr)/(vr+A()*ep()) ) ) {
      ar := *; ?0<=ar&ar<=A();
    } else { if (/*PassCoast*/ vr>0 & ixo() < xo + Vmin()*(ixr()-xr)/vr) {
      ar := 0;
    } else {         /* 1D Model 3 */
        ar := -b();
     ++ ?vr = 0; ar := 0;
     ++ ?xr + stopDist(vr) + accComp(vr) < ixr(); ar := A();
    }}}}
  }.

  HP dyn ::= { {xr' = vr, vr' = ar, xo'=vo, vo'=ao, t' = 1, T'=1 & t <= ep() & vr >= 0 & vo>=Vmin() } }.

  HP dwcxd ::= {
    {
      obstacle;
      { robot; t := 0; }
      dyn;
    }*@invariant(loopinv())
  }.

End.

ProgramVariables.
	R xr.		/* robot position: x */
	R vr.		/* robot translational velocity */
	R ar.		/* robot translational acceleration */
	R xo.		/* obstacle position */
	R vo.   /* obstacle velocity */
	R ao.   /* obstacle acceleration */
	R t.		/* control cycle time */
	R T.    /* remaining time until robot must start driving (i.e., until obstacle has passed the intersection) */
End.

Problem.
  assumptions()
	  ->
	  /* safety */
	  [ dwcxd; ]( (xr=ixr() -> xo!=ixo()) & (T>=D() -> RAfterX(xr)) )
		&
		/* liveness */
		< dwcxd; >( RAfterX(xr) )
End.

Tactic "Proof Theorem 15: Cross intersection with deadline (single convergence condition)".
/* Some of the QE need QE({`Mathematica`}) */

tactic leafQE as ( print({`Proving arithmetic`}); QE; done );

implyR(1) ; andR(1) ; <(
  useLemma({`Cross intersection with deadline - Safety`}, {`prop`}),
  con({`v`}, {`vo>=Vmin()&vr>=0&(xo<=0->vr=0|xr>0)&\exists n (n>=2&xo+(v-n)*ep()*Vmin()>0&vr+(min((v,n-1))-(n-2))*ep()*A()>=A()*ep()&xr+min((v,n-2))*ep()*(A()*ep())>0)`}, 1) ; <(
    leafQE,
    leafQE,
    composed(1) ; composed(1.1) ; solve(1.1.1) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
      leafQE,
      andL('L)* ;
      composed(1) ; choiced(1) ; orR(1) ; existsL(-10) ; andL('L)* ; implyL(-9) ; <(
        edit({`!xo>0`}, 3) ; notR(3) ; composed(1) ; testd(1) ; simplify(1) ;
        hideR(2=={`<?!xo>0;{?xr>0;ar:=*;?-b()<=ar&ar<=A();++?!xr>0;{?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&0/2*t_^2+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ;
        assignd(1) ; assignd(1) ; existsR({`ep()`}, 1) ; fullSimplify ; andR(1) ; <(
          leafQE,
          andR(1) ; <(
            implyR(1) ; leafQE,
            existsR({`n`}, 1) ; fullSimplify ; leafQE
            )
          ),
        composed(1) ; testd(1) ; composed(2) ; testd(2) ; andR(1) ; <(
          andR(2) ; <(
            prop,
            choiced(2) ; orR(2) ; composed(2) ; testd(2) ; composed(3) ; testd(3) ; orL(-9) ; <(
              andR(2) ; <(
                andR(3) ; <(
                  prop,
                  choiced(3) ; orR(3) ;
                  hideR(3=={`<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&0/2*t_^2+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ; composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ; hideR(3=={`<?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ; composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ; hideR(3=={`<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ; choiced(3) ; orR(3) ; hideR(4=={`<?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ;
                  composed(3) ; testd(3) ; simplify(3) ; assignd(3) ; assignd(3) ; existsR({`ep()`}, 3) ; fullSimplify ; existsR({`n`}, 3) ; fullSimplify ; leafQE
                  ),
                andR(3) ; <(
                  composed(2) ; randomd(2) ; existsR({`0`}, 2) ; testd(2) ; andR(2) ; <(
                    leafQE,
                    assignd(2) ; existsR({`ep()`}, 2) ; fullSimplify ; existsR({`n`}, 2) ; fullSimplify ; leafQE
                    ),
                  choiced(3) ; orR(3) ;
                  hideR(3=={`<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&0/2*t_^2+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ; composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ; hideR(3=={`<?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ; composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ; hideR(3=={`<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ; choiced(3) ; orR(3) ; hideR(4=={`<?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ; composed(3) ; testd(3) ; simplify(3) ; assignd(3) ; assignd(3) ; existsR({`ep()`}, 3) ; hideR(2=={`<ar:=*;?-b()<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&0/2*t_^2+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ;
                  fullSimplify ; existsR({`n`}, 2) ; fullSimplify ; leafQE
                  )
                ),
              simplify(2) ;
              hideR(3=={`!xr>0&<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&0/2*t_^2+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ;
              composed(2) ; randomd(2) ; existsR({`0`}, 2) ; testd(2) ; andR(2) ; <(
                leafQE,
                assignd(2) ; existsR({`ep()`}, 2) ; fullSimplify ; andR(2) ; <(
                  leafQE,
                  existsR({`n`}, 2) ; fullSimplify ; leafQE
                  )
                )
              )
            ),
          orL(-9) ; <(
            andR(2) ; <(
              assignd(1) ; assignd(1) ; existsR({`ep()`}, 1) ; fullSimplify ; andR(1) ; <(
                leafQE,
                andR(1) ; <(
                  leafQE,
                  existsR({`n`}, 1) ; fullSimplify ; leafQE
                  )
                ),
              choiced(2) ; orR(2) ; composed(2) ; testd(2) ; composed(3) ; testd(3) ; andR(2) ; <(
                andR(3) ; <(
                  prop,
                  choiced(3) ; orR(3) ;
                  hideR(3=={`<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&0/2*t_^2+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ; composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ; hideR(3=={`<?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ; composed(3) ; testd(3) ; simplify(3) ; choiced(3) ; orR(3) ; hideR(3=={`<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ; choiced(3) ; orR(3) ; hideR(4=={`<?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ;
                  composed(3) ; testd(3) ; simplify(3) ; assignd(3) ; assignd(3) ; assignd(1) ; assignd(1) ; existsR({`ep()`}, 1) ; existsR({`ep()`}, 3) ; fullSimplify ; andR(1) ; <(
                    leafQE,
                    andR(1) ; <(
                      leafQE,
                      existsR({`n`}, 3) ; existsR({`n`}, 1) ; fullSimplify ; leafQE
                      )
                    )
                  ),
                hideR(1=={`<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&0/2*t_^2+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ;
                composed(1) ; randomd(1) ; existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
                  hideR(2=={`!xr>0&<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&0/2*t_^2+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ;
                  leafQE
                  ,
                  assignd(1) ; existsR({`ep()`}, 1) ; andR(2) ; <(
                    fullSimplify ; andR(1) ; <(
                      leafQE,
                      andR(1) ; <(
                        leafQE,
                        existsR({`n`}, 1) ; fullSimplify ; leafQE
                        )
                      ),
                    choiced(2) ; orR(2) ;
                    hideR(2=={`<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&0/2*t_^2+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ; composed(2) ; testd(2) ; fullSimplify ; choiced(2) ; orR(2) ; hideR(2=={`<?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ; composed(2) ; testd(2) ; simplify(2) ; choiced(2) ; orR(2) ; hideR(2=={`<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ; choiced(2) ; orR(2) ; hideR(3=={`<?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ;
                    chase(2) ; simplify(2) ; existsR({`ep()`}, 2) ; fullSimplify ; existsR({`n`}, 2) ; andR(1) ; <(
                      leafQE,
                      andR(1) ; <(
                        leafQE,
                        existsR({`n`}, 1) ; fullSimplify ; leafQE
                        )
                      )
                    )
                  )
                )
              ),
            chase(1) ; existsR({`ep()`}, 1) ; simplify(1) ; andR(1) ; <(
              hideR(2=={`!xo>0&<?xr>0;ar:=*;?-b()<=ar&ar<=A();++?!xr>0;{?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&0/2*t_^2+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ;
              leafQE
              ,
              andR(1) ; <(
                hideR(2=={`!xo>0&<?xr>0;ar:=*;?-b()<=ar&ar<=A();++?!xr>0;{?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&0/2*t_^2+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ;
                leafQE
                ,
                existsR({`n`}, 1) ; simplify(1) ; hideR(2=={`!xo>0&<?xr>0;ar:=*;?-b()<=ar&ar<=A();++?!xr>0;{?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo<=0->ar*t_+vr=0|ar/2*t_^2+vr*t_+xr>0)&\exists n (n>=2&0/2*t_^2+vo*t_+xo+(v-1-n)*ep()*Vmin()>0&ar*t_+vr+(min((v-1,n-1))-(n-2))*ep()*A()>=A()*ep()&ar/2*t_^2+vr*t_+xr+min((v-1,n-2))*ep()*(A()*ep())>0))`}) ; leafQE
                )
              )
            )
          )
        )
      )
    )
  )
End.

Tactic "Proof Theorem 15: Cross intersection with deadline (loop split and unroll)".
/* Some of the QE need QE({`Mathematica`}) */

tactic leafQE as ( print({`Proving arithmetic`}); QE; done );

implyR(1) ; andL('L)* ; andR(1) ; <(
  useLemma({`Cross intersection with deadline - Safety`}, {`prop`})
  ,
  useAt({`<*> merge`}, {`1`}, 1) ; con({`v`}, {`vo>=Vmin()&vr>=0&(xo>0|vr=0)&xo+v*ep()*Vmin()>0`}, 1) ; <(
    leafQE
    ,
    andL('L)* ; iterated(1) ; orR(1) ; edit({`xo>0`}, -9) ; fullSimplify ; composed(2) ; composed(2) ; randomd(2) ; existsR({`0`}, 2) ; testd(2) ; hideL(-1=={`v<=0`}) ; andR(2) ; <(
      leafQE,
      composed(2) ; composed(2) ; choiced(2) ; orR(2) ;
      hideR(3=={`<?!xo>0;{?xr>0;ar:=*;?-b()<=ar&ar<=A();++?!xr>0;{?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}}}><t:=0;><{xr'=vr,vr'=ar,xo'=vo,vo'=0,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}><{{ao:=*;?-b()<=ao&ao<=A();}{{?xo>0;ar:=A();++?!xo>0;{?xr>0;ar:=*;?-b()<=ar&ar<=A();++?!xr>0;{?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}}}}t:=0;}{xr'=vr,vr'=ar,xo'=vo,vo'=ao,t'=1,T'=1&t<=ep()&vr>=0&vo>=Vmin()}}*>xr>0`}) ;
      composed(2) ; testd(2) ; fullSimplify ; assignd(2) ; assignd(2) ; solve(2) ; existsR({`ep()`}, 2) ; fullSimplify ; andR(2) ; <(
        leafQE,
        existsR({`ep()+T_1`}, 2) ; fullSimplify ; existsR({`vo_1+0`}, 2) ; fullSimplify ; existsR({`A()*ep()+vr_1`}, 2) ;
        simplify(2) ; existsR({`vo_1*ep()+xo_1`}, 2) ; simplify(2) ; existsR({`A()/2*ep()^2+vr_1*ep()+xr_1`}, 2) ;
        simplify(2) ; hideL(-11=={`T=ep()+T_1`}) ; edit({`vr>=A()*ep()`}, -12=={`vr=A()*ep()+vr_1`}) ;
        edit({`xo>0`}, -13=={`xo=vo_1*ep()+xo_1`}) ; edit({`xr>=xr_1`}, -14=={`xr=A()/2*ep()^2+vr_1*ep()+xr_1`}) ;
        hideL(-7=={`vr_1>=0`}) ;
        con({`w`}, {`vo>=Vmin()&xo>0&vr>=A()*ep()&xr+w*ep()*(A()*ep())>0`}, 2) ; <(
          leafQE,
          leafQE,
          composed(1) ; composed(1) ; randomd(1) ; andL('L)* ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
            leafQE,
            composed(1) ; solve(1.1) ; composed(1) ; choiced(1) ; orR(1) ;
            hideR(2=={`<?!xo>0;{?xr>0;ar:=*;?-b()<=ar&ar<=A();++?!xr>0;{?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&vo*t_+xo>0&ar*t_+vr>=A()*ep()&ar/2*t_^2+vr*t_+xr+(w-1)*ep()*(A()*ep())>0)`}) ;
            composed(1) ; testd(1) ; simplify(1) ; assignd(1) ; assignd(1) ; existsR({`ep()`}, 1) ; fullSimplify ; leafQE
          )
        )
      )
    )
    ,
    composed(1) ; composed(1.1) ; solve(1.1.1) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
      leafQE,
      andL('L)* ; composed(1) ; choiced(1) ; orR(1) ; composed(1) ; testd(1) ; orL(-9) ; <(
        fullSimplify ;
        hideR(2=={`<?!xo>0;{?xr>0;ar:=*;?-b()<=ar&ar<=A();++?!xr>0;{?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)`}) ;
        assignd(1) ; assignd(1) ; existsR({`ep()`}, 1) ; fullSimplify ; leafQE
        ,
        composed(2) ; testd(2) ; andR(1) ; <(
          andR(2) ; <(
            prop,
            choiced(2) ; orR(2) ; composed(2) ; testd(2) ; composed(3) ; testd(3) ; andR(2) ; <(
              andR(3) ; <(
                prop,
                choiced(3) ; orR(3) ;
                hideR(3=={`<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo>0|ar*t_+vr=0)&0/2*t_^2+vo*t_+xo+(v-1)*ep()*Vmin()>0)`}) ; composed(3) ; testd(3) ; fullSimplify ; choiced(3) ; orR(3) ; hideR(3=={`<?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)`}) ; composed(3) ; testd(3) ; fullSimplify ; choiced(3) ; orR(3) ; hideR(3=={`<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)`}) ; choiced(3) ; orR(3) ; hideR(4=={`<?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)`}) ;
                composed(3) ; testd(3) ; fullSimplify ; assignd(3) ; assignd(3) ; existsR({`ep()`}, 3) ; fullSimplify ; leafQE
              ),
              composed(2) ; randomd(2) ; existsR({`0`}, 2) ;
              hideR(3=={`!xr>0&<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo>0|ar*t_+vr=0)&0/2*t_^2+vo*t_+xo+(v-1)*ep()*Vmin()>0)`}) ;
              testd(2) ; andR(2) ; <(
                leafQE,
                assignd(2) ; existsR({`ep()`}, 2) ; fullSimplify ; leafQE
              )
            )
          ),
          andR(2) ; <(
            assignd(1) ; assignd(1) ; notR(2) ; existsR({`ep()`}, 1) ; fullSimplify ; leafQE,
            choiced(2) ; orR(2) ; composed(2) ; testd(2) ; composed(3) ; testd(3) ; andR(2) ; <(
              andR(3) ; <(
                prop,
                hideR(1=={`<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo>0|ar*t_+vr=0)&0/2*t_^2+vo*t_+xo+(v-1)*ep()*Vmin()>0)`}) ; choiced(2) ; orR(2) ; hideR(2=={`<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo>0|ar*t_+vr=0)&0/2*t_^2+vo*t_+xo+(v-1)*ep()*Vmin()>0)`}) ; composed(2) ; testd(2) ; fullSimplify ; choiced(2) ; orR(2) ; hideR(2=={`<?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)`}) ; composed(2) ; testd(2) ; fullSimplify ; choiced(2) ; orR(2) ; hideR(2=={`<ar:=-b();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)`}) ; choiced(2) ; orR(2) ; hideR(3=={`<?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&vo>=Vmin())&(vo*t_+xo>0|ar*t_+vr=0)&vo*t_+xo+(v-1)*ep()*Vmin()>0)`}) ;
                composed(2) ; testd(2) ; fullSimplify ; assignd(2) ; assignd(2) ; existsR({`ep()`}, 2) ; fullSimplify ; leafQE
                ),
              hideR(1=={`<ar:=A();><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo>0|ar*t_+vr=0)&0/2*t_^2+vo*t_+xo+(v-1)*ep()*Vmin()>0)`}) ; hideR(2=={`!xr>0&<?vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep()));ar:=*;?0<=ar&ar<=A();++?!(vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/(vr+A()*ep())));{?vr>0&0 < xo+Vmin()*(0-xr)/vr;ar:=0;++?!(vr>0&0 < xo+Vmin()*(0-xr)/vr);{ar:=-b();++?vr=0;ar:=0;++?xr+vr^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*vr) < 0;ar:=A();}}><t:=0;>\exists t_ (t_>=0&\forall s_ (0<=s_&s_<=t_->s_+t<=ep()&ar*s_+vr>=0&0*s_+vo>=Vmin())&(0/2*t_^2+vo*t_+xo>0|ar*t_+vr=0)&0/2*t_^2+vo*t_+xo+(v-1)*ep()*Vmin()>0)`}) ;
              composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
                leafQE,
                assignd(1) ; existsR({`ep()`}, 1) ; fullSimplify ; leafQE
              )
            )
          )
        )
      )
    )
  )
)
End.

End.

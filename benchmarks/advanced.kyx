ArchiveEntry "Benchmarks/Advanced/ETCS: Essentials"

Description "Essentials of European Train Control System (ETCS)".
Citation "Andre Platzer. Differential dynamic logic for hybrid systems. Journal of Automated Reasoning, 41(2), pages 143-189, 2008.".
Link "http://symbolaris.com/pub/freedL.pdf#page=14".

Definitions
  Real ep; /* Control cycle duration upper bound */
  Real b;  /* Braking force */
  Real A;  /* Maximum acceleration */
  Real m;  /* End of movement authority (train must not drive past m) */

  Real stopDist(Real v) = v^2/(2*b);                     /* Train stopping distance from speed (.) with braking force b */
  Real accCompensation(Real v) = (((A/b) + 1)*((A/2)*ep^2 + ep*v));     /* Distance to compensate speed increase. */
  Real SB(Real v)       = stopDist(v) + accCompensation(v);      /* Distance needed to stop safely when accelerating once */

  /* Initial states */
  Bool initial(Real m, Real z, Real v) <-> (
    v >= 0 &
    m-z >= stopDist(v) &         /* train has sufficient distance to the end of the movement authority to stop safely */
    b>0 &                                                                                       /* brakes are working */
    A>=0 &                                                                                       /* engine is working */
    ep>=0
  );

  Bool safe(Real m, Real z, Real v, Real d) <-> (
    z >= m -> v <= d      /* train 'z' drives past end of movement authority 'm' only with appropriate speed 'v'<='d' */
  );

  /* loop invariant: always maintain sufficient stopping distance */
  Bool loopInv(Real m, Real z, Real v) <-> (v >= 0 & m-z >= stopDist(v));

  /* train controller */
  HP ctrl ::= {
        ?m - z <= SB(v); a := -b;        /* train protection: emergency brake when close to end of movement authority */
     ++ ?m - z >= SB(v); a :=  A;        /* free driving: accelerate when sufficient distance */
  };

  HP drive ::= {
    t := 0;                                                  /* reset control cycle timer */
    {z'=v, v'=a, t'=1  & v >= 0 & t <= ep}                   /* drive (not backwards v>=0)
                                                                for at most ep time (t<=ep) until next controller run */
  };
End.

ProgramVariables
  Real a;  /* Actual acceleration -b <= a <= A */
  Real v;  /* Current velocity */
  Real z;  /* Train position */
  Real t;  /* Actual control cycle duration t <= ep */
End.

/* Safety specification of the form: initial -> [{ctrl;plant}*]safe
 * Starting in any state where initial is true,
 * any number of repetitions of running a controller 'ctrl' and then driving according to 'plant'
 * keeps the system safe (end up only in states where 'safe' is true).
 */
Problem
initial(m, z, v)  ->
    [
      {
        ctrl;
        drive;
      }*@invariant(loopInv(m, z, v))                       /* repeat, loop invariant documents system design property */
    ] (z <= m)                          /* safety property: train 'z' never drives past end of movement authority 'm' */
End.

Tactic "Scripted proof"
  expandAllDefs();
  implyR(1);
  loop("v>=0&m-z>=v^2/(2*b)", 1) ; <(
    "Init": prop,
    "Post": QE,
    "Step":
      composeb(1);
      composeb(1.1);
      solve(1.1.1);
      unfold; <(
        QE,
        allL("t_",-6); implyL(-6); <(
          hideR(1=="A*t_+v>=0&m-(A*(t_^2/2)+v*t_+z)>=(A*t_+v)^2/(2*b)") ; QE,
          QE
        )
    )
  )
End.

Tactic "Scripted proof (2)"
expandAllDefs();
implyR(1) ; loop("v>=0&m-z>=v^2/(2*b)", 1) ; <(
  prop,
  QE,
  composeb(1) ; composeb(1.1) ; solve(1.1.1) ; unfold ; doall(QE)
)
End.

Tactic "Automated proof"
  autoClose
End.

End.

ArchiveEntry "Benchmarks/Advanced/ETCS: Proposition 1 (Controllability)"

Description "Proposition 1: Controllability.".
Citation "Andre Platzer and Jan-David Quesel. European Train Control System: A case study in formal verification. In Karin Breitman and Ana Cavalcanti, editors, 11th International Conference on Formal Engineering Methods, ICFEM, Rio de Janeiro, Brasil, Proceedings, volume 5885 of LNCS, pages 246-265. Springer, 2009.".
Link "http://symbolaris.com/pub/ETCS.pdf#page=10".

Definitions
  Real b;  /* Braking force */

  Bool Assumptions(Real v, Real d) <-> ( v>=0 & d>=0 & b>0 );                                        /* Assumptions A */
End.

ProgramVariables
  Real m;
  Real z;
  Real v;
  Real d;
End.

Problem
  Assumptions(v, d) & z<=m
  ->
  ( [ {z'=v, v'=-b & v>=0 } ](z>=m -> v<=d)
    <->
    v^2-d^2 <= 2*b*(m-z)
  )
End.

Tactic "Scripted proof"
  expandAllDefs();
  implyR(1); equivR(1); <(
    solve('Llast); QE,
    solve('Rlast); QE
  )
End.

Tactic "Automated proof"
  autoClose
End.

End.

ArchiveEntry "Benchmarks/Advanced/ETCS: Proposition 4 (Reactivity)"

Description "Proposition 4: Reactivity constraint".
Citation "Andre Platzer and Jan-David Quesel. European Train Control System: A case study in formal verification. In Karin Breitman and Ana Cavalcanti, editors, 11th International Conference on Formal Engineering Methods, ICFEM, Rio de Janeiro, Brasil, Proceedings, volume 5885 of LNCS, pages 246-265. Springer, 2009.".
Link "http://symbolaris.com/pub/ETCS.pdf#page=12".

Definitions
  Real ep; /* Control cycle duration upper bound */
  Real b;  /* Braking force */
  Real A;  /* Maximum acceleration */

  Bool Assumptions(Real v, Real d) <-> ( v>=0 & d>=0 & b>0 );                                        /* Assumptions A */

  Bool Controllable(Real m, Real z, Real v, Real d) <-> (                             /* Controllability constraint C */
    v^2-d^2 <= 2*b*(m-z) & Assumptions(v, d)
  );

  HP drive ::= {
    t := 0;                                                  /* reset control cycle timer */
    {z'=v, v'=a, t'=1  & v >= 0 & t <= ep}                   /* drive (not backwards v>=0)
                                                                for at most ep time (t<=ep) until next controller run */
  };

End.

ProgramVariables
  Real vdes;
  Real sb;
  Real mo;
  Real t;
  Real a;
  Real v;
  Real z;
  Real m;
  Real d;
  Real do;
  Real em;
End.

Problem
em = 0 & d >= 0 & b > 0 & ep > 0 & A > 0 & v>=0
  -> ((\forall m \forall z (m-z>= sb & Controllable(m,z,v,d) -> [ a:=A; drive; ]Controllable(m,z,v,d)) )
      <->
      sb >= (v^2 - d^2) /(2*b) + (A/b + 1) * (A/2 * ep^2 + ep*v)
     )
End.

Tactic "Scripted proof"
useSolver("Mathematica");
expandAllDefs();
implyR('R=="em=0&d>=0&b()>0&ep()>0&A()>0&v>=0->(\forall m \forall z (m-z>=sb&v^2-d^2<=2*b()*(m-z)&v>=0&d>=0&b()>0->[a:=A();t:=0;{z'=v,v'=a,t'=1&v>=0&t<=ep()}](v^2-d^2<=2*b()*(m-z)&v>=0&d>=0&b()>0))<->sb>=(v^2-d^2)/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v))");
equivR('R=="\forall m \forall z (m-z>=sb&v^2-d^2<=2*b()*(m-z)&v>=0&d>=0&b()>0->[a:=A();t:=0;{z'=v,v'=a,t'=1&v>=0&t<=ep()}](v^2-d^2<=2*b()*(m-z)&v>=0&d>=0&b()>0))<->sb>=(v^2-d^2)/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v)"); <(
  "\forall m \forall z (m-z>=sb&v^2-d^2<=2*b()*(m-z)&v>=0&d>=0&b()>0->[a:=A();t:=0;{z'=v,v'=a,t'=1&v>=0&t<=ep()}](v^2-d^2<=2*b()*(m-z)&v>=0&d>=0&b()>0))&sb>=(v^2-d^2)/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v)":
    chaseAt('L=="\forall m \forall z (m-z>=sb&v^2-d^2<=2*b()*(m-z)&v>=0&d>=0&b()>0->#[a:=A();t:=0;{z'=v,v'=a,t'=1&v>=0&t<=ep()}](v^2-d^2<=2*b()*(m-z)&v>=0&d>=0&b()>0)#)");
    solve('L=="\forall m \forall z (m-z>=sb&v^2-d^2<=2*b()*(m-z)&v>=0&d>=0&b()>0->\forall t (t=0->#[{z'=v,v'=A(),t'=1&v>=0&t<=ep()}](v^2-d^2<=2*b()*(m-z)&v>=0&d>=0&b()>0)#))");
    QE,
  "!\forall m \forall z (m-z>=sb&v^2-d^2<=2*b()*(m-z)&v>=0&d>=0&b()>0->[a:=A();t:=0;{z'=v,v'=a,t'=1&v>=0&t<=ep()}](v^2-d^2<=2*b()*(m-z)&v>=0&d>=0&b()>0))&!sb>=(v^2-d^2)/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v)":
    unfold;
    ODE('R=="[{z'=v,v'=A(),t'=1&v>=0&t<=ep()}](v^2-d^2<=2*b()*(m-z)&v>=0&d>=0&b()>0)")
)
End.

Tactic "Automated proof"
  autoClose
End.

End.

ArchiveEntry "Benchmarks/Advanced/ATC: 2 Aircraft Tangential Roundabout Maneuver"

Description "Essentials of Tangential Roundabout Maneuver (TRM) in Air Traffic Control (ATC)".
Citation "Andre Platzer. Differential-algebraic dynamic logic for differential-algebraic programs. Journal of Logic and Computation, 20(1), pages 309-352, 2010.".
Link "https://doi.org/10.1093/logcom/exn070".

Definitions
  Real p;  /* protected zone radius */

  Bool safeSeparation(Real x1, Real y1, Real x2, Real y2) <-> ( (x1-y1)^2 + (x2-y2)^2 >= p^2 );
End.

ProgramVariables
  Real x1, x2;   /* position of aircraft 1 */
  Real d1, d2;   /* direction of aircraft 1 */
  Real y1, y2;   /* position of aircraft 2 */
  Real e1, e2;   /* direction of aircraft 2 */
  Real om;       /* angular velocity of aircraft 1 */
  Real omy;      /* angular velocity of aircraft 2 */
  Real c1, c2;   /* position of center of roundabout circle */
End.

Problem
  safeSeparation(x1, y1, x2, y2)
  ->
   [{
      {
         om:=*;omy:=*;
         {x1'=d1,x2'=d2, d1'=-om*d2,d2'=om*d1, y1'=e1,y2'=e2, e1'=-omy*e2,e2'=omy*e1
          & safeSeparation(x1, y1, x2, y2)}
       }*@invariant(safeSeparation(x1, y1, x2, y2));
       c1:=*;c2:=*; om:=*;
       d1:=-om*(x2-c2); d2:=om*(x1-c1);
       e1:=-om*(y2-c2); e2:=om*(y1-c1);
       {
       {x1'=d1,x2'=d2, d1'=-om*d2,d2'=om*d1, y1'=e1,y2'=e2, e1'=-om*e2,e2'=om*e1}
       @invariant(d1-e1=-om*(x2-y2)&d2-e2=om*(x1-y1))
       }
    }*@invariant(safeSeparation(x1, y1, x2, y2))
  ]safeSeparation(x1, y1, x2, y2)
End.

Tactic "Scripted proof"
implyR('R=="(x1-y1)^2+(x2-y2)^2>=p()^2->[{{om:=*;omy:=*;{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1&(x1-y1)^2+(x2-y2)^2>=p()^2}}*c1:=*;c2:=*;om:=*;d1:=-om*(x2-c2);d2:=om*(x1-c1);e1:=-om*(y2-c2);e2:=om*(y1-c1);{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1}}*](x1-y1)^2+(x2-y2)^2>=p()^2");
loop("safeSeparation(x1, y1, x2, y2)", 'R=="[{{om:=*;omy:=*;{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1&(x1-y1)^2+(x2-y2)^2>=p()^2}}*c1:=*;c2:=*;om:=*;d1:=-om*(x2-c2);d2:=om*(x1-c1);e1:=-om*(y2-c2);e2:=om*(y1-c1);{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1}}*](x1-y1)^2+(x2-y2)^2>=p()^2"); <(
  "Init":
    id,
  "Post":
    id,
  "Step":
    composeb('R=="[{om:=*;omy:=*;{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1&(x1-y1)^2+(x2-y2)^2>=p()^2}}*c1:=*;c2:=*;om:=*;d1:=-om*(x2-c2);d2:=om*(x1-c1);e1:=-om*(y2-c2);e2:=om*(y1-c1);{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1}](x1-y1)^2+(x2-y2)^2>=p()^2");
    loop("safeSeparation(x1, y1, x2, y2)", 'R=="[{om:=*;omy:=*;{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1&(x1-y1)^2+(x2-y2)^2>=p()^2}}*][c1:=*;c2:=*;om:=*;d1:=-om*(x2-c2);d2:=om*(x1-c1);e1:=-om*(y2-c2);e2:=om*(y1-c1);{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1}](x1-y1)^2+(x2-y2)^2>=p()^2"); <(
      "Init":
        id,
      "Post":
        unfold;
        diffInvariant("d1-e1=-om*(x2-y2)&d2-e2=om*(x1-y1)", 'R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1}](x1-y1)^2+(x2-y2)^2>=p()^2");
        dI('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1&true&d1-e1=-om*(x2-y2)&d2-e2=om*(x1-y1)}](x1-y1)^2+(x2-y2)^2>=p()^2"),
      "Step":
        unfold;
        dW('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1&(x1-y1)^2+(x2-y2)^2>=p()^2}](x1-y1)^2+(x2-y2)^2>=p()^2");
        prop
    )
)
End.

Tactic "Automated proof"
  autoClose
End.

End.

ArchiveEntry "Benchmarks/Advanced/ATC: 3 Aircraft Tangential Roundabout Maneuver"

Description "Essentials of Tangential Roundabout Maneuver (TRM) in Air Traffic Control (ATC)".
Citation "Andre Platzer. Differential-algebraic dynamic logic for differential-algebraic programs. Journal of Logic and Computation, 20(1), pages 309-352, 2010.".
Link "https://doi.org/10.1093/logcom/exn070".

Definitions
  Real p;  /* protected zone radius */

  Bool safeSeparation(Real x1, Real y1, Real x2, Real y2) <-> ( (x1-y1)^2 + (x2-y2)^2 >= p^2 );

  Bool safeSeparation3(Real x1, Real y1, Real x2, Real y2, Real z1, Real z2) <-> (
      safeSeparation(x1, y1, x2, y2)
    & safeSeparation(y1, z1, y2, z2)
    & safeSeparation(x1, z1, x2, z2)
  );

End.

ProgramVariables
  Real x1, x2;   /* position of aircraft 1 */
  Real d1, d2;   /* direction of aircraft 1 */
  Real y1, y2;   /* position of aircraft 2 */
  Real e1, e2;   /* direction of aircraft 2 */
  Real z1, z2;   /* position of aircraft 3 */
  Real f1, f2;   /* direction of aircraft 3 */
  Real om, omy, omz;   /* angular velocity of aircraft 1,2,3 */
  Real c1, c2;   /* position of center of roundabout circle */
End.

Problem
  safeSeparation3(x1, y1, x2, y2, z1, z2)
  ->
   [{
       {
         om:=*;omy:=*;omz:=*;
         {x1'=d1,x2'=d2, d1'=-om*d2,d2'=om*d1,
          y1'=e1,y2'=e2, e1'=-omy*e2,e2'=omy*e1,
          z1'=f1,z2'=f2, f1'=-omz*f2,f2'=omz*f1 & safeSeparation3(x1, y1, x2, y2, z1, z2) }
       }*@invariant(safeSeparation3(x1, y1, x2, y2, z1, z2));
       c1:=*;c2:=*; om:=*;
       d1:=-om*(x2-c2); d2:=om*(x1-c1);
       e1:=-om*(y2-c2); e2:=om*(y1-c1);
       f1:=-om*(z2-c2); f2:=om*(z1-c1);
       {
       {x1'=d1,x2'=d2, d1'=-om*d2,d2'=om*d1,
        y1'=e1,y2'=e2, e1'=-om*e2,e2'=om*e1,
        z1'=f1,z2'=f2, f1'=-om*f2,f2'=om*f1}
       @invariant(
          d1=-om*(x2-c2)&d2=om*(x1-c1) & e1=-om*(y2-c2)&e2=om*(y1-c1) & f1=-om*(z2-c2)&f2=om*(z1-c1))
       }
    }*@invariant(safeSeparation3(x1, y1, x2, y2, z1, z2))
   ]safeSeparation3(x1, y1, x2, y2, z1, z2)
End.

Tactic "Scripted proof"
implyR('R=="(x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2->[{{om:=*;omy:=*;omz:=*;{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1,z1'=f1,z2'=f2,f1'=-omz*f2,f2'=omz*f1&(x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2}}*c1:=*;c2:=*;om:=*;d1:=-om*(x2-c2);d2:=om*(x1-c1);e1:=-om*(y2-c2);e2:=om*(y1-c1);f1:=-om*(z2-c2);f2:=om*(z1-c1);{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1}}*]((x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2)");
loop("safeSeparation3(x1, y1, x2, y2, z1, z2)", 'R=="[{{om:=*;omy:=*;omz:=*;{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1,z1'=f1,z2'=f2,f1'=-omz*f2,f2'=omz*f1&(x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2}}*c1:=*;c2:=*;om:=*;d1:=-om*(x2-c2);d2:=om*(x1-c1);e1:=-om*(y2-c2);e2:=om*(y1-c1);f1:=-om*(z2-c2);f2:=om*(z1-c1);{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1}}*]((x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2)"); <(
  "Init":
    prop,
  "Post":
    prop,
  "Step":
    composeb('R=="[{om:=*;omy:=*;omz:=*;{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1,z1'=f1,z2'=f2,f1'=-omz*f2,f2'=omz*f1&(x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2}}*c1:=*;c2:=*;om:=*;d1:=-om*(x2-c2);d2:=om*(x1-c1);e1:=-om*(y2-c2);e2:=om*(y1-c1);f1:=-om*(z2-c2);f2:=om*(z1-c1);{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1}]((x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2)");
    loop("safeSeparation3(x1, y1, x2, y2, z1, z2)", 'R=="[{om:=*;omy:=*;omz:=*;{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1,z1'=f1,z2'=f2,f1'=-omz*f2,f2'=omz*f1&(x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2}}*][c1:=*;c2:=*;om:=*;d1:=-om*(x2-c2);d2:=om*(x1-c1);e1:=-om*(y2-c2);e2:=om*(y1-c1);f1:=-om*(z2-c2);f2:=om*(z1-c1);{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1}]((x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2)"); <(
      "Init":
        prop,
      "Post":
        unfold;
        diffInvariant("d1=-om*(x2-c2)&d2=om*(x1-c1)", 'R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1}]((x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2)");
        diffInvariant("e1=-om*(y2-c2)&e2=om*(y1-c1)", 'R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&true&d1=-om*(x2-c2)&d2=om*(x1-c1)}]((x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2)");
        diffInvariant("f1=-om*(z2-c2)&f2=om*(z1-c1)", 'R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&(true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1)}]((x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2)");
        ODE('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1)}]((x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2)"),
      "Step":
        unfold;
        dW('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1,z1'=f1,z2'=f2,f1'=-omz*f2,f2'=omz*f1&(x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2}]((x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2)");
        prop
    )
)
End.

Tactic "Scripted proof 2"
implyR('R=="safeSeparation3(x1,y1,x2,y2,z1,z2)->[{{om:=*;omy:=*;omz:=*;{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1,z1'=f1,z2'=f2,f1'=-omz*f2,f2'=omz*f1&safeSeparation3(x1,y1,x2,y2,z1,z2)}}*c1:=*;c2:=*;om:=*;d1:=-om*(x2-c2);d2:=om*(x1-c1);e1:=-om*(y2-c2);e2:=om*(y1-c1);f1:=-om*(z2-c2);f2:=om*(z1-c1);{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1}}*]safeSeparation3(x1,y1,x2,y2,z1,z2)");
loop("safeSeparation3(x1,y1,x2,y2,z1,z2)", 'R=="[{{om:=*;omy:=*;omz:=*;{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1,z1'=f1,z2'=f2,f1'=-omz*f2,f2'=omz*f1&safeSeparation3(x1,y1,x2,y2,z1,z2)}}*c1:=*;c2:=*;om:=*;d1:=-om*(x2-c2);d2:=om*(x1-c1);e1:=-om*(y2-c2);e2:=om*(y1-c1);f1:=-om*(z2-c2);f2:=om*(z1-c1);{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1}}*]safeSeparation3(x1,y1,x2,y2,z1,z2)"); <(
  "Init":
    id,
  "Post":
    id,
  "Step":
    composeb('R=="[{om:=*;omy:=*;omz:=*;{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1,z1'=f1,z2'=f2,f1'=-omz*f2,f2'=omz*f1&safeSeparation3(x1,y1,x2,y2,z1,z2)}}*c1:=*;c2:=*;om:=*;d1:=-om*(x2-c2);d2:=om*(x1-c1);e1:=-om*(y2-c2);e2:=om*(y1-c1);f1:=-om*(z2-c2);f2:=om*(z1-c1);{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1}]safeSeparation3(x1,y1,x2,y2,z1,z2)");
    loop("safeSeparation3(x1,y1,x2,y2,z1,z2)", 'R=="[{om:=*;omy:=*;omz:=*;{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1,z1'=f1,z2'=f2,f1'=-omz*f2,f2'=omz*f1&safeSeparation3(x1,y1,x2,y2,z1,z2)}}*][c1:=*;c2:=*;om:=*;d1:=-om*(x2-c2);d2:=om*(x1-c1);e1:=-om*(y2-c2);e2:=om*(y1-c1);f1:=-om*(z2-c2);f2:=om*(z1-c1);{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1}]safeSeparation3(x1,y1,x2,y2,z1,z2)"); <(
      "Init":
        id,
      "Post":
        unfold;
        diffInvariant("d1=-om*(x2-c2)&d2=om*(x1-c1)", 1) using "d1=-om*(x2-c2) :: d2=om*(x1-c1) :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1}]safeSeparation3(x1,y1,x2,y2,z1,z2) :: nil";
        diffInvariant("e1=-om*(y2-c2)&e2=om*(y1-c1)", 1) using "e1=-om*(y2-c2) :: e2=om*(y1-c1) :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&true&d1=-om*(x2-c2)&d2=om*(x1-c1)}]safeSeparation3(x1,y1,x2,y2,z1,z2) :: nil";
        diffInvariant("f1=-om*(z2-c2)&f2=om*(z1-c1)", 1) using "f1=-om*(z2-c2) :: f2=om*(z1-c1) :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&(true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1)}]safeSeparation3(x1,y1,x2,y2,z1,z2) :: nil";
        expand("safeSeparation3");
        boxAnd('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1)}](safeSeparation(x1,y1,x2,y2)&safeSeparation(y1,z1,y2,z2)&safeSeparation(x1,z1,x2,z2))");
        andR('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1)}]safeSeparation(x1,y1,x2,y2)&[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1)}](safeSeparation(y1,z1,y2,z2)&safeSeparation(x1,z1,x2,z2))"); <(
          "[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1)}]safeSeparation(x1,y1,x2,y2)":
            andL('L=="safeSeparation(x1,y1,x2,y2)&safeSeparation(y1,z1,y2,z2)&safeSeparation(x1,z1,x2,z2)");
            expand("safeSeparation");
            dIClose(1) using "(x1-y1)^2+(x2-y2)^2>=p()^2 :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1)}](x1-y1)^2+(x2-y2)^2>=p()^2 :: nil",
          "[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1)}](safeSeparation(y1,z1,y2,z2)&safeSeparation(x1,z1,x2,z2))":
            boxAnd('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1)}](safeSeparation(y1,z1,y2,z2)&safeSeparation(x1,z1,x2,z2))");
            andR('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1)}]safeSeparation(y1,z1,y2,z2)&[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1)}]safeSeparation(x1,z1,x2,z2)"); <(
              "[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1)}]safeSeparation(y1,z1,y2,z2)":
                unfold;
                expand("safeSeparation");
                dIClose(1) using "(y1-z1)^2+(y2-z2)^2>=p()^2 :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1)}](y1-z1)^2+(y2-z2)^2>=p()^2 :: nil",
              "[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1)}]safeSeparation(x1,z1,x2,z2)":
                unfold;
                expand("safeSeparation");
                dIClose(1) using "(x1-z1)^2+(x2-z2)^2>=p()^2 :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1&((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1)}](x1-z1)^2+(x2-z2)^2>=p()^2 :: nil"
            )
        ),
      "Step":
        unfold;
        dW('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1,z1'=f1,z2'=f2,f1'=-omz*f2,f2'=omz*f1&safeSeparation3(x1,y1,x2,y2,z1,z2)}]safeSeparation3(x1,y1,x2,y2,z1,z2)");
        id
    )
)
End.

Tactic "Automated proof"
  autoClose
End.

End.

ArchiveEntry "Benchmarks/Advanced/ATC: 4 Aircraft Tangential Roundabout Maneuver"

Description "Essentials of Tangential Roundabout Maneuver (TRM) in Air Traffic Control (ATC)".
Citation "Andre Platzer. Differential-algebraic dynamic logic for differential-algebraic programs. Journal of Logic and Computation, 20(1), pages 309-352, 2010.".
Link "https://doi.org/10.1093/logcom/exn070".

Definitions
  Real p;  /* protected zone radius */

  Bool safeSeparation(Real x1, Real y1, Real x2, Real y2) <-> ( (x1-y1)^2 + (x2-y2)^2 >= p^2 );

  Bool safeSeparation4(Real x1, Real y1, Real x2, Real y2, Real z1, Real z2, Real u1, Real u2) <-> (
      safeSeparation(x1, y1, x2, y2)
    & safeSeparation(y1, z1, y2, z2)
    & safeSeparation(x1, z1, x2, z2)
    & safeSeparation(x1, u1, x2, u2)
    & safeSeparation(y1, u1, y2, u2)
    & safeSeparation(z1, u1, z2, u2)
  );

End.

ProgramVariables
  Real x1, x2;   /* position of aircraft 1 */
  Real d1, d2;   /* direction of aircraft 1 */
  Real y1, y2;   /* position of aircraft 2 */
  Real e1, e2;   /* direction of aircraft 2 */
  Real z1, z2;   /* position of aircraft 3 */
  Real f1, f2;   /* direction of aircraft 3 */
  Real u1, u2;   /* position of aircraft 4 */
  Real g1, g2;   /* direction of aircraft 4 */
  Real om, omy, omz, omu;   /* angular velocity of aircraft 1,2,3,4 */
  Real c1, c2;   /* position of center of roundabout circle */
End.

Problem
  safeSeparation4(x1, y1, x2, y2, z1, z2, u1, u2)
  ->
   [{
      {
        om:=*;omy:=*;omz:=*;omu:=*;
        {x1'=d1,x2'=d2, d1'=-om*d2,d2'=om*d1,
         y1'=e1,y2'=e2, e1'=-omy*e2,e2'=omy*e1,
         z1'=f1,z2'=f2, f1'=-omz*f2,f2'=omz*f1,
         u1'=g1,u2'=g2, g1'=-omu*g2,g2'=omu*g1
         & safeSeparation4(x1, y1, x2, y2, z1, z2, u1, u2) }
      }*@invariant(safeSeparation4(x1, y1, x2, y2, z1, z2, u1, u2));
      c1:=*;c2:=*; om:=*;
      d1:=-om*(x2-c2); d2:=om*(x1-c1);
      e1:=-om*(y2-c2); e2:=om*(y1-c1);
      f1:=-om*(z2-c2); f2:=om*(z1-c1);
      g1:=-om*(u2-c2); g2:=om*(u1-c1);
      {
      {x1'=d1,x2'=d2, d1'=-om*d2,d2'=om*d1,
       y1'=e1,y2'=e2, e1'=-om*e2,e2'=om*e1,
       z1'=f1,z2'=f2, f1'=-om*f2,f2'=om*f1,
       u1'=g1,u2'=g2, g1'=-om*g2,g2'=om*g1}
      @invariant((d1=-om*(x2-c2)&d2=om*(x1-c1))&
                 (e1=-om*(y2-c2)&e2=om*(y1-c1))&
                 (f1=-om*(z2-c2)&f2=om*(z1-c1))&
                 (g1=-om*(u2-c2)&g2=om*(u1-c1)))
      }
    }*@invariant(safeSeparation4(x1, y1, x2, y2, z1, z2, u1, u2))
   ]safeSeparation4(x1, y1, x2, y2, z1, z2, u1, u2)
End.

Tactic "Scripted proof"
implyR('R=="safeSeparation4(x1,y1,x2,y2,z1,z2,u1,u2)->[{{om:=*;omy:=*;omz:=*;omu:=*;{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1,z1'=f1,z2'=f2,f1'=-omz*f2,f2'=omz*f1,u1'=g1,u2'=g2,g1'=-omu*g2,g2'=omu*g1&safeSeparation4(x1,y1,x2,y2,z1,z2,u1,u2)}}*c1:=*;c2:=*;om:=*;d1:=-om*(x2-c2);d2:=om*(x1-c1);e1:=-om*(y2-c2);e2:=om*(y1-c1);f1:=-om*(z2-c2);f2:=om*(z1-c1);g1:=-om*(u2-c2);g2:=om*(u1-c1);{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1}}*]safeSeparation4(x1,y1,x2,y2,z1,z2,u1,u2)");
loop("safeSeparation4(x1,y1,x2,y2,z1,z2,u1,u2)", 'R=="[{{om:=*;omy:=*;omz:=*;omu:=*;{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-omy*e2,e2'=omy*e1,z1'=f1,z2'=f2,f1'=-omz*f2,f2'=omz*f1,u1'=g1,u2'=g2,g1'=-omu*g2,g2'=omu*g1&safeSeparation4(x1,y1,x2,y2,z1,z2,u1,u2)}}*c1:=*;c2:=*;om:=*;d1:=-om*(x2-c2);d2:=om*(x1-c1);e1:=-om*(y2-c2);e2:=om*(y1-c1);f1:=-om*(z2-c2);f2:=om*(z1-c1);g1:=-om*(u2-c2);g2:=om*(u1-c1);{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1}}*]safeSeparation4(x1,y1,x2,y2,z1,z2,u1,u2)"); <(
  "Init":
    propClose,
  "Post":
    propClose,
  "Step":
    composeb(1);
    loop("safeSeparation4(x1,y1,x2,y2,z1,z2,u1,u2)", 1); <(
      "Init":
        propClose,
      "Post":
        unfold;
        diffInvariant("d1=-om*(x2-c2)&d2=om*(x1-c1)", 1) using "d1=-om*(x2-c2) :: d2=om*(x1-c1) :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1}]safeSeparation4(x1,y1,x2,y2,z1,z2,u1,u2) :: nil";
        diffInvariant("e1=-om*(y2-c2)&e2=om*(y1-c1)", 1) using "e1=-om*(y2-c2) :: e2=om*(y1-c1) :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&true&d1=-om*(x2-c2)&d2=om*(x1-c1)}]safeSeparation4(x1,y1,x2,y2,z1,z2,u1,u2) :: nil";
        diffInvariant("f1=-om*(z2-c2)&f2=om*(z1-c1)", 1) using "f1=-om*(z2-c2) :: f2=om*(z1-c1) :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1)}]safeSeparation4(x1,y1,x2,y2,z1,z2,u1,u2) :: nil";
        diffInvariant("g1=-om*(u2-c2)&g2=om*(u1-c1)", 1) using "g1=-om*(u2-c2) :: g2=om*(u1-c1) :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1)}]safeSeparation4(x1,y1,x2,y2,z1,z2,u1,u2) :: nil";
        expandAllDefs();
        unfold;
        boxAnd('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}]((x1-y1)^2+(x2-y2)^2>=p()^2&(y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2&(x1-u1)^2+(x2-u2)^2>=p()^2&(y1-u1)^2+(y2-u2)^2>=p()^2&(z1-u1)^2+(z2-u2)^2>=p()^2)");
        andR('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](x1-y1)^2+(x2-y2)^2>=p()^2&[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}]((y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2&(x1-u1)^2+(x2-u2)^2>=p()^2&(y1-u1)^2+(y2-u2)^2>=p()^2&(z1-u1)^2+(z2-u2)^2>=p()^2)"); <(
          "[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](x1-y1)^2+(x2-y2)^2>=p()^2":
            dI(1) using "(x1-y1)^2+(x2-y2)^2>=p()^2 :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](x1-y1)^2+(x2-y2)^2>=p()^2 :: nil",
          "[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}]((y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2&(x1-u1)^2+(x2-u2)^2>=p()^2&(y1-u1)^2+(y2-u2)^2>=p()^2&(z1-u1)^2+(z2-u2)^2>=p()^2)":
            boxAnd('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}]((y1-z1)^2+(y2-z2)^2>=p()^2&(x1-z1)^2+(x2-z2)^2>=p()^2&(x1-u1)^2+(x2-u2)^2>=p()^2&(y1-u1)^2+(y2-u2)^2>=p()^2&(z1-u1)^2+(z2-u2)^2>=p()^2)");
            andR('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](y1-z1)^2+(y2-z2)^2>=p()^2&[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}]((x1-z1)^2+(x2-z2)^2>=p()^2&(x1-u1)^2+(x2-u2)^2>=p()^2&(y1-u1)^2+(y2-u2)^2>=p()^2&(z1-u1)^2+(z2-u2)^2>=p()^2)"); <(
              "[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](y1-z1)^2+(y2-z2)^2>=p()^2":
                dI(1) using "(y1-z1)^2+(y2-z2)^2>=p()^2 :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](y1-z1)^2+(y2-z2)^2>=p()^2 :: nil",
              "[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}]((x1-z1)^2+(x2-z2)^2>=p()^2&(x1-u1)^2+(x2-u2)^2>=p()^2&(y1-u1)^2+(y2-u2)^2>=p()^2&(z1-u1)^2+(z2-u2)^2>=p()^2)":
                boxAnd('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}]((x1-z1)^2+(x2-z2)^2>=p()^2&(x1-u1)^2+(x2-u2)^2>=p()^2&(y1-u1)^2+(y2-u2)^2>=p()^2&(z1-u1)^2+(z2-u2)^2>=p()^2)");
                andR('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](x1-z1)^2+(x2-z2)^2>=p()^2&[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}]((x1-u1)^2+(x2-u2)^2>=p()^2&(y1-u1)^2+(y2-u2)^2>=p()^2&(z1-u1)^2+(z2-u2)^2>=p()^2)"); <(
                  "[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](x1-z1)^2+(x2-z2)^2>=p()^2":
                    dI(1) using "(x1-z1)^2+(x2-z2)^2>=p()^2 :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](x1-z1)^2+(x2-z2)^2>=p()^2 :: nil",
                  "[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}]((x1-u1)^2+(x2-u2)^2>=p()^2&(y1-u1)^2+(y2-u2)^2>=p()^2&(z1-u1)^2+(z2-u2)^2>=p()^2)":
                    boxAnd('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}]((x1-u1)^2+(x2-u2)^2>=p()^2&(y1-u1)^2+(y2-u2)^2>=p()^2&(z1-u1)^2+(z2-u2)^2>=p()^2)");
                    andR('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](x1-u1)^2+(x2-u2)^2>=p()^2&[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}]((y1-u1)^2+(y2-u2)^2>=p()^2&(z1-u1)^2+(z2-u2)^2>=p()^2)"); <(
                      "[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](x1-u1)^2+(x2-u2)^2>=p()^2":
                        dI(1) using "(x1-u1)^2+(x2-u2)^2>=p()^2 :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](x1-u1)^2+(x2-u2)^2>=p()^2 :: nil",
                      "[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}]((y1-u1)^2+(y2-u2)^2>=p()^2&(z1-u1)^2+(z2-u2)^2>=p()^2)":
                        boxAnd('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}]((y1-u1)^2+(y2-u2)^2>=p()^2&(z1-u1)^2+(z2-u2)^2>=p()^2)");
                        andR('R=="[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](y1-u1)^2+(y2-u2)^2>=p()^2&[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](z1-u1)^2+(z2-u2)^2>=p()^2"); <(
                          "[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](y1-u1)^2+(y2-u2)^2>=p()^2":
                            dI(1) using "(y1-u1)^2+(y2-u2)^2>=p()^2 :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](y1-u1)^2+(y2-u2)^2>=p()^2 :: nil",
                          "[{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](z1-u1)^2+(z2-u2)^2>=p()^2":
                            dI(1) using "(z1-u1)^2+(z2-u2)^2>=p()^2 :: [{x1'=d1,x2'=d2,d1'=-om*d2,d2'=om*d1,y1'=e1,y2'=e2,e1'=-om*e2,e2'=om*e1,z1'=f1,z2'=f2,f1'=-om*f2,f2'=om*f1,u1'=g1,u2'=g2,g1'=-om*g2,g2'=om*g1&(((true&d1=-om*(x2-c2)&d2=om*(x1-c1))&e1=-om*(y2-c2)&e2=om*(y1-c1))&f1=-om*(z2-c2)&f2=om*(z1-c1))&g1=-om*(u2-c2)&g2=om*(u1-c1)}](z1-u1)^2+(z2-u2)^2>=p()^2 :: nil"
                        )
                    )
                )
            )
        ),
      "Step":
        unfold;
        dW(1);
        id
    )
)
End.

Tactic "Automated proof"
  autoClose
End.

End.

ArchiveEntry "Benchmarks/Advanced/Robot collision avoidance in two-dimensional space: Static safety"

Description "Safety of collision avoidance in environments with all stationary obstacles.".
Citation "Stefan Mitsch, Khalil Ghorbal, David Vogelbacher, and André Platzer. Formal verification of obstacle avoidance and navigation of ground robots. International Journal of Robotics Research. 36(12), pp. 1312-1340, 2017.".
Link "http://symbolaris.com/pub/morerobix.pdf#page=8".

Definitions
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real W;       /* maximum steering */

  Real stopDist(Real v) = v^2 / (2*b);            /* The straight-line stopping distance from brake start to full stop. */
  Real accelComp(Real v) = ((A/b + 1) * (A/2 * ep^2 + ep*v));      /* Straight-line distance to compensate acceleration */
  Real admissibleSeparation(Real v) = stopDist(v) + accelComp(v); /* Separation that allows accelerating on a new curve */

  Bool isWellformedDir(Real dx, Real dy) <-> dx^2 + dy^2 = 1;       /* The orientation of the robot is a unit vector. */

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A >= 0                                                                                        /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
  );

  /* Stopped somewhere safe initially */
  Bool initialState(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir(dx, dy)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <->
    (bounds() & initialState(x, y, v, dx, dy, xo, yo));

  /* Conditions that are true on each loop iteration */
  Bool loopinv(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v >= 0
    & isWellformedDir(dx, dy)
    & (abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  );
End.

ProgramVariables
  Real x, y;    /* robot position */
  Real v, w;    /* robot translational and rotational velocity */
  Real a;       /* robot translational acceleration */
  Real dx, dy;  /* robot orientation */
  Real r;       /* robot curve radius */
  Real xo, yo;  /* position of closest obstacle on curve */
  Real t;       /* time */
End.

Problem
assumptions(x, y, v, dx, dy, xo, yo) ->
  [
    {
      {
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      {
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        t' = 1 & t <= ep & v >= 0
      }@invariant(t>=0, isWellformedDir(dx, dy),
        (v'=-b -> v = old(v) - b*t),
        (v'=-b -> (-t * (old(v) - b/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - b/2*t))),
        (v'=-b -> (-t * (old(v) - b/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - b/2*t))),
        (v'=0 -> v = old(v)),
        (v'=0 -> x = old(x)),
        (v'=0 -> y = old(y)),
        (v'=A -> v = old(v) + A*t),
        (v'=A -> (-t * (old(v) + A/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A/2*t))),
        (v'=A -> (-t * (old(v) + A/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A/2*t)))
      )
      }
    }*@invariant(loopinv(x, y, v, dx, dy, xo, yo))
  ](x - xo)^2 + (y - yo)^2 > 0
End.

Tactic "Scripted proof"
  useSolver("Mathematica");

  tactic diall as (
    diffInvariant("t>=0", 1);
    diffInvariant("dx^2+dy^2=1", 1)
  );

  tactic dib as (
    diall;
    diffInvariant("v = old(v) - b*t", 1);
    diffInvariant("-t * (v + b/2*t) <= x - old(x) & x - old(x) <= t * (v + b/2*t)", 1);
    diffInvariant("-t * (v + b/2*t) <= y - old(y) & y - old(y) <= t * (v + b/2*t)", 1)
  );

  tactic di0 as (
    diall;
    diffInvariant("v = old(v)", 1);
    diffInvariant("x = old(x)", 1);
    diffInvariant("y = old(y)", 1)
  );

  tactic dia as (
    diall;
    diffInvariant("v = old(v) + A*t", 1);
    diffInvariant("-t * (v - A/2*t) <= x - old(x) & x - old(x) <= t * (v - A/2*t)", 1);
    diffInvariant("-t * (v - A/2*t) <= y - old(y) & y - old(y) <= t * (v - A/2*t)", 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print("Transforming...");
    transform("abs(x_0-xo)>v_0^2/(2*b)+(A/b+1)*(A/2*t^2+t*v_0)", 'L=="abs(x_0-xo)>v_0^2/(2*b) + (A/b + 1) * (A/2 * ep^2 + ep*v_0)");
    hideR('R=="abs(y-yo)>v^2 / (2*b)");
    smartQE;
    print("Proved acc arithmetic")
  );

  tactic yAccArith as (
    andL('L)*;
    print("Transforming...");
    transform("abs(y_0-yo)>v_0^2/(2*b)+(A/b+1)*(A/2*t^2+t*v_0)", 'L=="abs(y_0-yo)>v_0^2/(2*b) + (A/b + 1) * (A/2 * ep^2 + ep*v_0)");
    hideR('R=="abs(x-xo)>v^2 / (2*b)");
    smartQE;
    print("Proved acc arithmetic")
  );

  implyR(1); andL('L)*; loop("v >= 0 & dx^2+dy^2=1 & (abs(x-xo) > v^2 / (2*b) | abs(y-yo) > v^2 / (2*b))", 1); <(
    print("Base case..."); smartQE; print("Base case done")
    ,
    print("Use case..."); smartQE; print("Use case done")
    ,
    print("Induction step"); unfold; <(
      print("Braking branch"); dib; dw; prop; doall(smartQE); print("Braking branch done")
      ,
      print("Stopped branch"); di0; dw; prop; doall(smartQE); print("Stopped branch done")
      ,
      print("Acceleration branch");
      hideL('L == "abs(x-xo_0)>v^2 / (2*b)|abs(y-yo_0)>v^2 / (2*b)");
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print("Acceleration branch done")
    );
    print("Induction step done")
  );
  done;
  print("Proof done")
End.

End.

ArchiveEntry "Benchmarks/Advanced/Robot collision avoidance in two-dimensional space: Passive safety"

Description "Safety of collision avoidance in environments with moving obstacles of known maximum speed.".
Citation "Stefan Mitsch, Khalil Ghorbal, David Vogelbacher, and André Platzer. Formal verification of obstacle avoidance and navigation of ground robots. International Journal of Robotics Research. 36(12), pp. 1312-1340, 2017.".
Link "http://symbolaris.com/pub/morerobix.pdf#page=11".

Definitions
  Real ep;      /* time limit for control decisions */
  Real b;       /* minimum braking capability of the robot */
  Real A;       /* maximum acceleration -b <= a <= A */
  Real W;       /* maximum steering */
  Real V;       /* maximum obstacle velocity */

  Real stopDist(Real v) = v^2 / (2*b) + V*v/b;
  Real accelComp(Real v) = ((A/b + 1) * (A/2 * ep^2 + ep*(v+V)));
  Real admissibleSeparation(Real v) = stopDist(v) + accelComp(v);

  Bool isWellformedDir(Real dx, Real dy) <-> (dx^2 + dy^2 = 1);     /* The orientation of the robot is a unit vector. */

  Bool bounds() <-> (                                                                  /* Bounds for global constants */
      A >= 0                                                                                        /* Working engine */
    & b > 0                                                                                         /* Working brakes */
    & ep > 0                                                                              /* Controller reaction time */
    & V >= 0
  );

  /* Stopped somewhere safe initially */
  Bool initialState(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir(dx, dy)
  );

  /* Under these assumptions we guarantee safety */
  Bool assumptions(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (bounds() & initialState(x, y, v, dx, dy, xo, yo));

  /* Conditions that need to be proved to be true on each loop iteration */
  Bool loopinv(Real x, Real y, Real v, Real dx, Real dy, Real xo, Real yo) <-> (
    v >= 0
    & isWellformedDir(dx, dy)
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  );
End.

ProgramVariables
  Real x, y;    /* robot position */
  Real v, w;    /* robot translational and rotational velocity */
  Real a;       /* robot translational acceleration */
  Real dx, dy;  /* robot orientation */
  Real r;       /* robot curve radius */
  Real xo, yo;  /* position of closest obstacle on curve */
  Real vxo, vyo; /* velocity of obstacle */
  Real t;       /* time */
End.

Problem
assumptions(x, y, v, dx, dy, xo, yo) ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      {
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }@invariant(t>=0, isWellformedDir(dx, dy),
          (-t*V <= xo - old(xo) & xo - old(xo) <= t*V),
          (-t*V <= yo - old(yo) & yo - old(yo) <= t*V),
          (v'=-b -> v = old(v) - b*t),
          (v'=-b -> (-t * (old(v) - b/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - b/2*t))),
          (v'=-b -> (-t * (old(v) - b/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - b/2*t))),
          (v'=0 -> v = old(v)),
          (v'=0 -> x = old(x)),
          (v'=0 -> y = old(y)),
          (v'=A -> v = old(v) + A*t),
          (v'=A -> (-t * (old(v) + A/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A/2*t))),
          (v'=A -> (-t * (old(v) + A/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A/2*t)))
        )
      }
    }*@invariant(loopinv(x, y, v, dx, dy, xo, yo))
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Scripted proof"
useSolver("Mathematica");
implyR('R=="assumptions(x,y,v,dx,dy,xo,yo)->[{{{vxo:=*;vyo:=*;?vxo^2+vyo^2<=V()^2;}{a:=-b();++?v=0;a:=0;w:=0;++a:=A();w:=*;?-W()<=w&w<=W();r:=*;xo:=*;yo:=*;?r!=0&r*w=v;?abs(x-xo)>admissibleSeparation(v)|abs(y-yo)>admissibleSeparation(v);}t:=0;}{x'=v*dx,y'=v*dy,v'=a,dx'=-w*dy,dy'=w*dx,w'=a/r,xo'=vxo,yo'=vyo,t'=1&t<=ep()&v>=0}}*](v>0->(x-xo)^2+(y-yo)^2>0)");
expand("assumptions");
loop("loopinv(x,y,v,dx,dy,xo,yo)", 'R=="[{{{vxo:=*;vyo:=*;?vxo^2+vyo^2<=V()^2;}{a:=-b();++?v=0;a:=0;w:=0;++a:=A();w:=*;?-W()<=w&w<=W();r:=*;xo:=*;yo:=*;?r!=0&r*w=v;?abs(x-xo)>admissibleSeparation(v)|abs(y-yo)>admissibleSeparation(v);}t:=0;}{x'=v*dx,y'=v*dy,v'=a,dx'=-w*dy,dy'=w*dx,w'=a/r,xo'=vxo,yo'=vyo,t'=1&t<=ep()&v>=0}}*](v>0->(x-xo)^2+(y-yo)^2>0)"); <(
  "Init":
    expandAllDefs();
    unfold;
    simplify('R=="v>=0&dx^2+dy^2=1&(v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b())");
    closeT,
  "Post":
    expandAllDefs();
    QE,
  "Step":
    expandAllDefs();
    unfold; <(
      "[a:=-b();][t:=0;][{x'=v*dx,y'=v*dy,v'=a,dx'=-w*dy,dy'=w*dx,w'=a/r,xo'=vxo,yo'=vyo,t'=1&t<=ep()&v>=0}](v>=0&dx^2+dy^2=1&(v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b()))":
        diffInvariant("t>=0", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "t=0" ;
        diffInvariant("dx^2+dy^2=1", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "dx^2+dy^2=1" ;
        diffInvariant("-t*V()<=xo-old(xo)&xo-old(xo)<=t*V()", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "vxo^2+vyo^2<=V()^2 :: t=0 :: V()>=0 :: nil" ;
        diffInvariant("-t*V()<=yo-old(yo)&yo-old(yo)<=t*V()", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "vxo^2+vyo^2<=V()^2 :: t=0 :: V()>=0 :: nil";
        diffInvariant("v=old(v)-b()*t", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "t=0 :: v>=0 :: b()>0 :: nil" ;
        diffInvariant("-t*(v+b()/2*t)<=x-old(x)&x-old(x)<=t*(v+b()/2*t)", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "t=0 :: v_0>=0 :: b()>0 :: v_0=v :: nil" ;
        diffInvariant("-t*(v+b()/2*t)<=y-old(y)&y-old(y)<=t*(v+b()/2*t)", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "t=0 :: v_0>=0 :: b()>0 :: v_0=v :: nil";
        dW('R=="[{x'=v*dx,y'=v*dy,v'=-b(),dx'=-w*dy,dy'=w*dx,w'=(-b())/r,xo'=vxo,yo'=vyo,t'=1&(((((((t<=ep()&v>=0)&t>=0)&dx^2+dy^2=1)&-t*V()<=xo-xo_0&xo-xo_0<=t*V())&-t*V()<=yo-yo_0&yo-yo_0<=t*V())&v=v_0-b()*t)&-t*(v+b()/2*t)<=x-x_0&x-x_0<=t*(v+b()/2*t))&-t*(v+b()/2*t)<=y-y_0&y-y_0<=t*(v+b()/2*t)}](v>=0&dx^2+dy^2=1&(v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b()))");
        unfold;
        simplify('R=="v>=0&dx^2+dy^2=1&(v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b())") using "dx^2+dy^2=1 :: v>=0 :: nil";
        implyR('R=="v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b()");
        orR('R=="abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b()");
        edit("v_0>0", 'L=="v_0>=0") using "v=v_0-b()*t :: v>0 :: b()>0 :: t>=0 :: nil";
        simplify('L=="v_0>0->abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()|abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()") using "v_0>0";
        orL('L=="abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()|abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()"); <(
          "abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()":
            QE using "b()>0 :: v=v_0-b()*t :: -t*(v+b()/2*t)<=x-x_0 :: x-x_0<=t*(v+b()/2*t) :: -t*V()<=xo-xo_0 :: xo-xo_0<=t*V() :: v_0>0 :: abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b() :: t>=0 :: v>0 :: abs(x-xo)>v^2/(2*b())+V()*v/b() :: nil",
          "abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()":
            QE using "-t*(v+b()/2*t)<=y-y_0 :: y-y_0<=t*(v+b()/2*t) :: b()>0 :: v=v_0-b()*t :: -t*V()<=yo-yo_0 :: yo-yo_0<=t*V() :: v_0>0 :: abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b() :: t>=0 :: v>0 :: abs(y-yo)>v^2/(2*b())+V()*v/b() :: nil"
        )
        ,
      "[?v=0;a:=0;w:=0;][t:=0;][{x'=v*dx,y'=v*dy,v'=a,dx'=-w*dy,dy'=w*dx,w'=a/r,xo'=vxo,yo'=vyo,t'=1&t<=ep()&v>=0}](v>=0&dx^2+dy^2=1&(v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b()))":
        diffInvariant("t>=0", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "t=0";
        diffInvariant("dx^2+dy^2=1", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "dx^2+dy^2=1";
        diffInvariant("-t*V()<=xo-old(xo)&xo-old(xo)<=t*V()", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "vxo^2+vyo^2<=V()^2 :: t=0 :: V()>=0 :: nil" ;
        diffInvariant("-t*V()<=yo-old(yo)&yo-old(yo)<=t*V()", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "vxo^2+vyo^2<=V()^2 :: t=0 :: V()>=0 :: nil";
        diffInvariant("v=old(v)", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "t=0 :: v=0 :: nil" ;
        diffInvariant("x=old(x)", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "t=0 :: v_0=0 :: v_0=v :: nil" ;
        diffInvariant("y=old(y)", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "t=0 :: v_0=0 :: v_0=v :: nil";
        dW('R=="[{x'=v*dx,y'=v*dy,v'=0,dx'=-w*dy,dy'=w*dx,w'=0/r,xo'=vxo,yo'=vyo,t'=1&(((((((t<=ep()&v>=0)&t>=0)&dx^2+dy^2=1)&-t*V()<=xo-xo_0&xo-xo_0<=t*V())&-t*V()<=yo-yo_0&yo-yo_0<=t*V())&v=v_0)&x=x_0)&y=y_0}](v>=0&dx^2+dy^2=1&(v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b()))");
        unfold;
        simplify('R=="v>=0&dx^2+dy^2=1&(v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b())") using "dx^2+dy^2=1 :: v>=0 :: nil";
        implyR('R=="v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b()");
        QE,
      "[a:=A();w:=*;?-W()<=w&w<=W();r:=*;xo:=*;yo:=*;?r!=0&r*w=v;?abs(x-xo)>v^2/(2*b())+V()*v/b()+(A()/b()+1)*(A()/2*ep()^2+ep()*(v+V()))|abs(y-yo)>v^2/(2*b())+V()*v/b()+(A()/b()+1)*(A()/2*ep()^2+ep()*(v+V()));][t:=0;][{x'=v*dx,y'=v*dy,v'=a,dx'=-w*dy,dy'=w*dx,w'=a/r,xo'=vxo,yo'=vyo,t'=1&t<=ep()&v>=0}](v>=0&dx^2+dy^2=1&(v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b()))":
        diffInvariant("t>=0", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "t=0" ;
        diffInvariant("dx^2+dy^2=1", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "dx^2+dy^2=1" ;
        diffInvariant("-t*V()<=xo-old(xo)&xo-old(xo)<=t*V()", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "vxo^2+vyo^2<=V()^2 :: t=0 :: V()>=0 :: nil" ;
        diffInvariant("-t*V()<=yo-old(yo)&yo-old(yo)<=t*V()", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "vxo^2+vyo^2<=V()^2 :: t=0 :: V()>=0 :: nil";
        diffInvariant("v=old(v)+A()*t", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "t=0 :: v>=0 :: A()>=0 :: nil" ;
        diffInvariant("-t*(v-A()/2*t)<=x-old(x)&x-old(x)<=t*(v-A()/2*t)", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "t=0 :: v_0>=0 :: A()>=0 :: v_0=v :: nil" ;
        diffInvariant("-t*(v-A()/2*t)<=y-old(y)&y-old(y)<=t*(v-A()/2*t)", 'R~="[ode;]loopinv(x,y,v,dx,dy,xo,yo)") using "t=0 :: v_0>=0 :: A()>=0 :: v_0=v :: nil";
        dW('R=="[{x'=v*dx,y'=v*dy,v'=A(),dx'=-w*dy,dy'=w*dx,w'=A()/r,xo'=vxo,yo'=vyo,t'=1&(((((((t<=ep()&v>=0)&t>=0)&dx^2+dy^2=1)&-t*V()<=xo-xo_1&xo-xo_1<=t*V())&-t*V()<=yo-yo_1&yo-yo_1<=t*V())&v=v_0+A()*t)&-t*(v-A()/2*t)<=x-x_0&x-x_0<=t*(v-A()/2*t))&-t*(v-A()/2*t)<=y-y_0&y-y_0<=t*(v-A()/2*t)}](v>=0&dx^2+dy^2=1&(v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b()))");
        andL('L)*;
        simplify('R=="v>=0&dx^2+dy^2=1&(v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b())") using "dx^2+dy^2=1 :: v>=0 :: nil";
        implyR('R=="v>0->abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b()");
        edit("abs(x_0-xo_1)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))|abs(y_0-yo_1)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))", 'L=="abs(x_0-xo_1)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*ep()^2+ep()*(v_0+V()))|abs(y_0-yo_1)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*ep()^2+ep()*(v_0+V()))") using "abs(x_0-xo_1)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*ep()^2+ep()*(v_0+V()))|abs(y_0-yo_1)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*ep()^2+ep()*(v_0+V())) :: v_0>=0 :: A()>=0 :: t>=0 :: b()>0 :: t<=ep() :: ep()>0 :: V()>=0 :: nil";
        orR('R=="abs(x-xo)>v^2/(2*b())+V()*v/b()|abs(y-yo)>v^2/(2*b())+V()*v/b()");
        orL('L=="abs(x_0-xo_1)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))|abs(y_0-yo_1)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))"); <(
          "abs(x_0-xo_1)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))":
            QE using "abs(x_0-xo_1)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V())) :: v=v_0+A()*t :: -t*(v-A()/2*t)<=x-x_0 :: x-x_0<=t*(v-A()/2*t) :: v_0>=0 :: A()>=0 :: -t*V()<=xo-xo_1 :: xo-xo_1<=t*V() :: t>=0 :: b()>0 :: v>=0 :: V()>=0 :: abs(x-xo)>v^2/(2*b())+V()*v/b() :: nil",
          "abs(y_0-yo_1)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))":
            QE using "-t*(v-A()/2*t)<=y-y_0 :: y-y_0<=t*(v-A()/2*t) :: abs(y_0-yo_1)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V())) :: v=v_0+A()*t :: v_0>=0 :: A()>=0 :: -t*V()<=yo-yo_1 :: yo-yo_1<=t*V() :: t>=0 :: b()>0 :: v>=0 :: V()>=0 :: abs(y-yo)>v^2/(2*b())+V()*v/b() :: nil"
        )
    )
)
End.

End.

ArchiveEntry "Benchmarks/Advanced/Chinese Train Control System Level 3 (CTCS-3)"

Citation "Liang Zou, Jidong Lv, Shuling Wang, Naijun Zhan, Tao Tang, Lei Yuan, Yu Liu. Verifying Chinese Train Control System under a Combined Scenario by Theorem Proving. VSTTE 2013, pp. 262-280".
Link "https://doi.org/10.1007/978-3-642-54108-7_14".

Definitions
  Real Cb;
  Real Ca;
  Real CA;
  Real T;
  Real x1, x2;
  Real e21, e22, e23, e31, e32, e33;

  Bool initial(Real a, Real v, Real s, Real i, Real lvl, Real lu, Real COswitched, Real conf,
               Real v211, Real v212, Real v221, Real v222, Real v231, Real v232,
               Real v311, Real v312, Real v321, Real v322, Real v331, Real v332) <-> (
      CA=1
    & Ca=-0.2
    & Cb=-1
    & T=0.125
    & x1=3200
    & x2=6400
    & e21=3200
    & e22=6400
    & e23=9600
    & e31=3200
    & e32=6400
    & e33=9600
    & a=0
    & v=0
    & s=0
    & i=0
    & lvl=2
    & lu=0
    & COswitched=0
    & conf=0
    & v211=105/3.6
    & v212=100/3.6
    & v221=105/3.6
    & v222=100/3.6
    & v231=45/3.6
    & v232=40/3.6
    & v311=255/3.6
    & v312=250/3.6
    & v321=255/3.6
    & v322=250/3.6
    & v331=0
    & v332=0);

  Bool testCO(Real COswitched, Real s) <-> (COswitched=0 & s<e32 & s>e32-300);

  Real fv(Real v) = ((v+CA*T)^2);

  HP FB2 ::= {
     vr1:=(v211+CA*T)^2;
     vr1:=min(vr1,(v221*v221-2*Cb*e21+2*Cb*s+Cb*CA*T*T+2*Cb*v*T));
     vr1:=min(vr1,(v231*v231-2*Cb*e22+2*Cb*s+Cb*CA*T*T+2*Cb*v*T));
     vr1:=min(vr1,(2*Cb*s-2*Cb*e23+Cb*CA*T*T+2*Cb*v*T));
     vr2:=(v212+CA*T)^2;
     vr2:=min(vr2,(v222*v222-2*Cb*e21+2*Cb*s+Cb*CA*T*T+2*Cb*v*T));
     vr2:=min(vr2,(v232*v232-2*Cb*e22+2*Cb*s+Cb*CA*T*T+2*Cb*v*T));
     vr2:=min(vr2,(2*Cb*s-2*Cb*e23+Cb*CA*T*T+2*Cb*v*T));
  };

  HP FB22 ::= {
     vr1:=(v221+CA*T)^2;
     vr1:=min(vr1,(v231*v231-2*Cb*e22+2*Cb*s+Cb*CA*T*T+2*Cb*v*T));
     vr1:=min(vr1,(2*Cb*s-2*Cb*e23+Cb*CA*T*T+2*Cb*v*T));
     vr2:=(v222+CA*T)^2;
     vr2:=min(vr2,(v232*v232-2*Cb*e22+2*Cb*s+Cb*CA*T*T+2*Cb*v*T));
     vr2:=min(vr2,(2*Cb*s-2*Cb*e23+Cb*CA*T*T+2*Cb*v*T));

     vr1:=min(vr1,(v321+CA*T)^2);
     vr1:=min(vr1,(v331*v331-2*Cb*e32+2*Cb*s+Cb*CA*T*T+2*Cb*v*T));
     vr1:=min(vr1,(2*Cb*s-2*Cb*e33+Cb*CA*T*T+2*Cb*v*T));
     vr2:=min(vr2,(v322+CA*T)^2);
     vr2:=min(vr2,(v332*v332-2*Cb*e32+2*Cb*s+Cb*CA*T*T+2*Cb*v*T));
     vr2:=min(vr2,(2*Cb*s-2*Cb*e33+Cb*CA*T*T+2*Cb*v*T));
  };

  HP FB3 ::= {
     vr1:=(v331+CA*T)^2;
     vr1:=min(vr1,(2*Cb*s-2*Cb*e33+Cb*CA*T*T+2*Cb*v*T));
     vr2:=(v332+CA*T)^2;
     vr2:=min(vr2,(2*Cb*s-2*Cb*e33+Cb*CA*T*T+2*Cb*v*T));
  };

  HP switchCO ::= {
     v331:=45/3.6; v332:=40/3.6;
  };

  HP accl ::= {
     ? fv(v)>=vr1 ; a:=Cb;
  ++ ? fv(v)>=vr2 & fv(v)<vr1; a:=Ca;
  ++ ? fv(v)<vr1  & fv(v)<vr2; a:=CA;
  };

  HP I2 ::= {
     ? i=2 & s>=x1; lvl:=2.5; I2a;
  ++ ? i=0 & s>200; i:=1; lu:=1; i:=2; FB2; accl;
  ++ ? (i=0 & s<=200) | (i=2 & s<x1); FB2; accl;
  };

  HP I2a ::= {
     ? s>x2; lvl:=3; I3;
  ++ ? s<=x2; FB22; accl;
  };

  HP I3 ::= {
     ?  testCO(COswitched,s); conf:=1; COswitched:=1; switchCO; FB3; accl;
  ++ ? !testCO(COswitched,s); FB3; accl;
  };

  HP ctrl ::= {
     ? lvl=2; I2;
  ++ ? lvl=2.5; I2a;
  ++ ? lvl=3; I3;
  };

  HP drive ::= {
    t := 0;
    {s'=v, v'=a, t'=1 & v>=0 & t<=T}
  };

End.

ProgramVariables
  Real a;
  Real v;
  Real s;
  Real lvl;
  Real lu;
  Real i;
  Real COswitched;
  Real conf;
  Real t;
  Real vr1;
  Real vr2;
  Real v211;
  Real v212;
  Real v221;
  Real v222;
  Real v231;
  Real v232;
  Real v311;
  Real v312;
  Real v321;
  Real v322;
  Real v331;
  Real v332;
End.

Problem

initial(a, v, s, i, lvl, lu, COswitched, conf, v211, v212, v221, v222, v231, v232, v311, v312, v321, v322, v331, v332)
->
[{ctrl; drive;}*]s<=x2

End.

End.

ArchiveEntry "Benchmarks/Advanced/Lunar lander descent guidance (slow descent)"

Citation "Hengjun Zhao, Mengfei Yang, Naijun Zhan, Bin GuLiang Zou, Yao Chen. Formal Verification of a Descent Guidance Control Program of a Lunar Lander. FM 2014.".

Definitions
  Real Isp1   = 2500;  /* thrust engine impulse (low thrust) */
  Real Isp2   = 2800;  /* thrust engine impulse (high thrust) */
  Real gM     = 1.622; /* gravitational acceleration on the moon */
  Real eps    = 0.05;  /* v fluctuation tolerance */
  Real vslw   = -2;    /* target velocity slow descent */
  Real vmax   = 5;     /* max velocity */
  Real DeltaT = 0.128; /* controller sampling time */
  Real mMin   = 1100;  /* maximum lander mass */
  Real mMax   = 3000;  /* minimum lander mass */
  Real c1     = 0.01;  /* control coeffiecent */
  Real c2     = 0.6;   /* control coefficient */
End.

ProgramVariables
  Real r;   /* altitude relative to lunar surface */
  Real v;   /* vertical velocity */
  Real m;   /* lunar lander mass */
  Real Fc;  /* lander thrust */
  Real t;   /* time */
  Real isp; /* engine impulse depending on thrust */

  Real a;
  Real alC;
End.

Problem
  m=1250 & r=30 & v=-2 & Fc=2027.5
  ->
  [{
     /* guidance program (plant updates mass) */
     {
     a := Fc/m;
     alC := max(-c1*(a-gM) - c2*(v-vslw) + gM, 1500);
     Fc := max(min(m*alC, 5000), 1500);
     }
     /* plant */
     {
     t:=0;
     if (Fc <= 3000) { isp:=Isp1; } else { isp:=Isp2; }
     /*{ r'=v, v'=Fc/m-gM, m'=-Fc/isp, t'=1 & r>=0 & t<=DeltaT & mMin<=m&m<=mMax }*/
     /* recast per paper */
     { r'=v, v'=a-gM, a'=a^2/isp, t'=1 & r>=0 & t<=DeltaT & mMin<=m&m<=mMax }
     }
   }*@invariant( (v - vslw)^2 <= eps^2 & v^2<=vmax^2 )
  ]((v - vslw)^2 <= eps^2 & v^2<=vmax^2)
End.

End.

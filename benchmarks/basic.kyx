ArchiveEntry "Benchmarks/Basic/Static semantics correctness: Assignment 1"

Description "Basic assignment".

ProgramVariables
  Real x;
End.

Problem
  x>=0 -> [x:=x+1;]x>=1
End.

Tactic "Scripted proof"
  implyR('R=="x>=0 -> [x:=x+1;]x>=1");
  assignb('R=="[x:=x+1;]x>=1");
  QE
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Static semantics correctness: Assignment 2"

Description "Overwrite assignment on some branches".

ProgramVariables
  Real x;
  Real y;
End.

Problem
  x>=0 -> [x:=x+1;][x:=x+1; ++ y:=x+1;]x>=1
End.

Tactic "Scripted proof"
assignb('R=="x>=0->#[x:=x+1;][x:=x+1;++y:=x+1;]x>=1#");
choiceb('R=="x_0>=0->\forall x (x=x_0+1->#[x:=x+1;++y:=x+1;]x>=1#)");
assignb('R=="x_0>=0->\forall x (x=x_0+1->#[x:=x+1;]x>=1#&[y:=x+1;]x>=1)");
assignb('R=="x_0>=0->\forall x (x=x_0+1->x+1>=1&#[y:=x+1;]x>=1#)");
QE
End.

Tactic "Scripted proof (2)"
implyR('R=="x>=0->[x:=x+1;][x:=x+1;++y:=x+1;]x>=1");
assignb('R=="[x:=x+1;][x:=x+1;++y:=x+1;]x>=1");
choiceb('R=="[x:=x+1;++y:=x+1;]x>=1");
andR('R=="[x:=x+1;]x>=1&[y:=x+1;]x>=1"); <(
  "[x:=x+1;]x>=1":
    assignb('R=="[x:=x+1;]x>=1");
    QE,
  "[y:=x+1;]x>=1":
    assignb('R=="[y:=x+1;]x>=1");
    QE
)
End.

Tactic "Automated proof"
  auto
End.

End.


ArchiveEntry "Benchmarks/Basic/Static semantics correctness: Assignment 3"

Description "Overwrite assignment in loop".

ProgramVariables
  Real x;
End.

Problem
  x>=0 -> [x:=x+1;][{x:=x+1;}*@invariant(x>=1)]x>=1
End.

Tactic "Scripted proof"
unfold;
loop("x>=1", 'R=="[{x:=x+1;}*]x>=1"); <(
  "Init":
    QE,
  "Post":
    id,
  "Step":
    assignb('R=="[x:=x+1;]x>=1");
    QE
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Static semantics correctness: Assignment 4"

Description "Overwrite assignment in ODE".

ProgramVariables
  Real x;
End.

Problem
  x>=0 -> [x:=x+1;][{x'=2}]x>=1
End.

Tactic "Scripted proof"
  implyR(1) ; assignb(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Static semantics correctness: Assignment 5"

Description "Overwrite with nondeterministic assignment".

ProgramVariables
  Real x;
End.

Problem
  x>=0 -> [x:=x+1;][x:=*; ?x>=1;]x>=1
End.

Tactic "Scripted proof"
  implyR(1) ; assignb(1) ; composeb(1) ; randomb(1) ; allR(1) ; testb(1) ; prop
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Static semantics correctness: Assignment 6"

Description "Tests and universal quantification".

ProgramVariables
  Real x;
  Real y;
End.

Problem
  x>=0 -> [x:=x+1;][?x>=2; x:=x-1; ++ ?\forall x (x>=1 -> y>=1); x:=y;]x>=1
End.

Tactic "Scripted proof"
implyR('R=="x>=0->[x:=x+1;][?x>=2;x:=x-1;++?\forall x (x>=1->y>=1);x:=y;]x>=1");
assignb('R=="[x:=x+1;][?x>=2;x:=x-1;++?\forall x (x>=1->y>=1);x:=y;]x>=1");
choiceb('R=="[?x+1>=2;x:=x+1-1;++?\forall x (x>=1->y>=1);x:=y;]x>=1");
andR('R=="[?x+1>=2;x:=x+1-1;]x>=1&[?\forall x (x>=1->y>=1);x:=y;]x>=1"); <(
  "[?x+1>=2;x:=x+1-1;]x>=1":
    composeb('R=="[?x+1>=2;x:=x+1-1;]x>=1");
    testb('R=="[?x+1>=2;][x:=x+1-1;]x>=1");
    implyR('R=="x+1>=2->[x:=x+1-1;]x>=1");
    assignb('R=="[x:=x+1-1;]x>=1");
    QE,
  "[?\forall x (x>=1->y>=1);x:=y;]x>=1":
    composeb('R=="[?\forall x (x>=1->y>=1);x:=y;]x>=1");
    testb('R=="[?\forall x (x>=1->y>=1);][x:=y;]x>=1");
    implyR('R=="\forall x (x>=1->y>=1)->[x:=y;]x>=1");
    assignb('R=="[x:=y;]x>=1");
    allL("x+1", 'L=="\forall x (x>=1->y>=1)");
    implyL('L=="x+1>=1->y>=1"); <(
      "x+1>=1":
        QE,
      "y>=1":
        id
    )
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Static semantics correctness: Assignment 7"

Description "Overwrite assignment several times".

ProgramVariables
  Real x;
  Real y;
End.

Problem
  x>=0 & y>=1 -> [x:=x+1;][{x:=x+1;}*@invariant(x>=1) ++ y:=x+1;][{y'=2}][x:=y;]x>=1
End.

Tactic "Scripted proof"
implyR('R=="x>=0&y>=1->[x:=x+1;][{x:=x+1;}*++y:=x+1;][{y'=2}][x:=y;]x>=1");
assignb('R=="[x:=x+1;][{x:=x+1;}*++y:=x+1;][{y'=2}][x:=y;]x>=1");
choiceb('R=="[{x:=x+1;}*++y:=x+1;][{y'=2}][x:=y;]x>=1");
andR('R=="[{x:=x+1;}*][{y'=2}][x:=y;]x>=1&[y:=x+1;][{y'=2}][x:=y;]x>=1"); <(
  "[{x:=x+1;}*][{y'=2}][x:=y;]x>=1":
    loop("x>=1", 'R=="[{x:=x+1;}*][{y'=2}][x:=y;]x>=1"); <(
      "Init":
        QE,
      "Post":
        assignb('R=="[{y'=2}]#[x:=y;]x>=1#");
        ODEinv('R=="[{y'=2}]y>=1"),
      "Step":
        assignb('R=="[x:=x+1;]x>=1");
        QE
    ),
  "[y:=x+1;][{y'=2}][x:=y;]x>=1":
    assignb('R=="[y:=x+1;][{y'=2}][x:=y;]x>=1");
    assignb('R=="[{y'=2}]#[x:=y;]x>=1#");
    ODEinv('R=="[{y'=2}]y>=1")
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Static semantics correctness: Assignment 8"

Description "Potentially overwrite dynamics".

ProgramVariables
  Real x;
  Real y;
End.

Problem
  x>0 & y>0 -> [{x'=5}][{x:=x+3;}*@invariant(x>0) ++ y:=x;](x>0&y>0)
End.

Tactic "Scripted proof"
implyR('R=="x>0&y>0->[{x'=5}][{x:=x+3;}*++y:=x;](x>0&y>0)");
ODE('R=="[{x'=5}][{x:=x+3;}*++y:=x;](x>0&y>0)");
(dW('R=="[{x'=5,time_'=1&true&time_>=0&x=5*time_+x_0}][{x:=x+3;}*++y:=x;](x>0&y>0)") |
 dW('R=="[{x'=5,time_'=1&true&time_>=0&x=x_0+5*time_}][{x:=x+3;}*++y:=x;](x>0&y>0)"));
choiceb('R=="[{x:=x+3;}*++y:=x;](x>0&y>0)");
andR('R=="[{x:=x+3;}*](x>0&y>0)&[y:=x;](x>0&y>0)"); <(
  "[{x:=x+3;}*](x>0&y>0)":
    loop("x>0", 'R=="[{x:=x+3;}*](x>0&y>0)"); <(
      "Init":
        QE,
      "Post":
        prop,
      "Step":
        assignb('R=="[x:=x+3;]x>0");
        QE
    ),
  "[y:=x;](x>0&y>0)":
    assignb('R=="[y:=x;](x>0&y>0)");
    QE
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Static semantics correctness: Assignment 9"

Description "Potentially overwrite exponential decay".

ProgramVariables
  Real x;
  Real y;
End.

Problem
  x>0 & y>0 -> [{x'=-x}@invariant(x>0)][{x:=x+3;}*@invariant(x>0) ++ y:=x;](x>0&y>0)
End.

Tactic "Scripted proof"
implyR('R=="x>0&y>0->[{x'=-x}][{x:=x+3;}*++y:=x;](x>0&y>0)");
ODE('R=="[{x'=-x}][{x:=x+3;}*++y:=x;](x>0&y>0)");
?(dW('R=="[{x'=-x&x>0}][{x:=x+3;}*++y:=x;](x>0&y>0)"));
unfold; <(
  "[{x:=x+3;}*](x>0&y>0)":
    loop("x>0", 'R=="[{x:=x+3;}*](x>0&y>0)"); <(
      "Init":
        id,
      "Post":
        prop,
      "Step":
        assignb('R=="[x:=x+3;]x>0");
        QE
    ),
  "[y:=x;](x>0&y>0)":
    prop
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Cascaded"

ProgramVariables
  Real x;
  Real y;
End.

Problem
  x>0 -> [{x'=5};{x'=2};{x'=x}]x>0
End.

Tactic "Scripted proof"
implyR('R=="x>0->[{x'=5}{x'=2}{x'=x}]x>0");
composeb('R=="[{x'=5}{x'=2}{x'=x}]x>0");
ODE('R=="[{x'=5}][{x'=2}{x'=x}]x>0");
dW('R~="[{x'=5,time_'=1&true&time_>=0&x=f(time_,x_0)}][{x'=2}{x'=x}]x>0");
composeb('R=="[{x'=2}{x'=x}]x>0");
ODE('R=="[{x'=2}][{x'=x}]x>0");
dW('R~="[{x'=2,time__0'=1&true&time__0>=0&x=f(time__0,x_1)}][{x'=x}]x>0");
ODE('R=="[{x'=x}]x>0")
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Single integrator time"

ProgramVariables
  Real x;
End.

Problem
  x=0->[{x'=1}]x>=0
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Single integrator"

ProgramVariables
  Real x;
  Real y;
End.

Problem
  x>=0 & y>=0 -> [{x'=y}]x>=0
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Double integrator"

ProgramVariables
  Real x;
  Real y;
  Real z;
End.

Problem
  x>=0 & y>=0 & z>=0 -> [{x'=y,y'=z}]x>=0
End.

Tactic "Scripted proof"
  implyR(1) ; ODE(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Triple integrator"

ProgramVariables
  Real x;
  Real y;
  Real z;
  Real j;
End.

Problem
  x>=0 & y>=0 & z>=0 & j>=0 -> [{x'=y,y'=z,z'=j,j'=j^2}@invariant(j>=0, z>=0, y>=0, x>=0)]x>=0
End.

Tactic "Scripted proof"
  implyR(1) ; ODE(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Exponential decay (1)"

ProgramVariables
  Real x;
End.

Problem
  x>0 -> [{x'=-x}@invariant(x>0)]x>0
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Exponential decay (2)"

ProgramVariables
  Real x;
End.

Problem
  x>0 -> [{x'=-x+1}@invariant(x>0)]x>0
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Exponential decay (3)"

ProgramVariables
  Real x;
  Real y;
End.

Problem
  x>0 & y>0->[{x'=-y*x}@invariant(x>0)]x>0
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Exponential growth (1)"

ProgramVariables
  Real x;
End.

Problem
  x>=0 -> [{x'=x}@invariant(x>=0)]x>=0
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Exponential growth (2)"

ProgramVariables
  Real x;
  Real y;
End.

Problem
  x>=0 & y>=0 -> [{x'=y, y'=y^2}@invariant(y>=0, x>=0)]x>=0
End.

Tactic "Scripted proof"
  implyR(1) ; ODE(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Exponential growth (4)"

ProgramVariables
  Real x;
End.

Problem
  x>0 -> [{x'=x^x}@invariant(x>0)]x>0
End.

Tactic "Scripted proof"
  useSolver("Mathematica");
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Exponential growth (5)"

ProgramVariables
  Real x;
End.

Problem
  x>=1 -> [{x'=x^2+2*x^4}@invariant(x>=1)]x^3>=x^2
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Rotational dynamics (1)"

ProgramVariables
  Real x;
  Real y;
End.

Problem
  x^2+y^2=1 -> [{x'=-y, y'=x}@invariant(x^2+y^2=1)]x^2+y^2=1
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Rotational dynamics (2)"

ProgramVariables
  Real x;
  Real y;
  Real g;
End.

Problem
  x^2+y^2=1 & g=x -> [{x'=-y, y'=g, g'=-y}@invariant(x^2+y^2=1 & g=x)](x^2+y^2=1 & g=x)
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Rotational dynamics (3)"

ProgramVariables
  Real x1;
  Real x2;
  Real d1;
  Real d2;
  Real w;
  Real p;
End.

Problem
  d1^2+d2^2=w^2*p^2 & d1=-w*x2 & d2=w*x1 ->
    [{x1'=d1, x2'=d2, d1'=-w*d2, d2'=w*d1}@invariant(d1^2+d2^2=w^2*p^2 & d1=-w*x2 & d2=w*x1)](d1^2+d2^2=w^2*p^2 & d1=-w*x2 & d2=w*x1)
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Spiral to equilibrium"

ProgramVariables
  Real w;
  Real x;
  Real y;
End.

Problem
  w>=0 & x=0 & y=3 -> [{x'=y, y'=-w^2*x-2*w*y}@invariant(w^2*x^2+y^2<=9)]w^2*x^2+y^2<=9
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Open cases"

ProgramVariables
  Real x;
  Real y;
End.

Problem
  x^3>5 & y>2 -> [{x'=x^3+x^4, y'=5*y+y^2}@invariant(x^3>5 & y>2)](x^3>5 & y>2)
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Closed cases"

ProgramVariables
  Real x;
  Real y;
  Real z;
End.

Problem
  x>=1 & y=10 & z=-2 -> [{x'=y, y'=z+y^2-y & y>=0}](x>=1 & y>=0)
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Conserved quantity"

ProgramVariables
  Real x1;
  Real x2;
  Real c;
End.

Problem
  x1^4*x2^2+x1^2*x2^4-3*x1^2*x2^2+1 <= c ->
    [{x1'=2*x1^4*x2+4*x1^2*x2^3-6*x1^2*x2, x2'=-4*x1^3*x2^2-2*x1*x2^4+6*x1*x2^2}] x1^4*x2^2+x1^2*x2^4-3*x1^2*x2^2+1 <= c
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Darboux equality"

Definitions
  Real B();
End.

ProgramVariables
  Real x;
  Real y;
  Real z;
  Real A;
End.

Problem
  x+z=0 -> [{x'=(A*x^2+B()*x), z' = A*z*x+B()*z}] 0=-x-z
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Fractional Darboux equality"

Description "Tests a fractional Darboux equality in an ODE without progress".

Definitions
  Real A, B;
  Real y;
End.

ProgramVariables
  Real x, z;
End.

Problem
  x+z=0 -> [{x'=(A*y+B*x)/z^2, z' = (A*x+B)/z & y = x^2 & z^2 > 0}] x+z=0
End.

Tactic "Scripted proof"
  useSolver("Mathematica");
  implyR(1);
  dbx("(x*A+B())/z^2", 1)
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Darboux inequality"

ProgramVariables
  Real x;
  Real y;
  Real z;
End.

Problem
  x+z>=0 & y=x^2 -> [{x'=x^2, z'=z*x+y}]x+z>=0
End.

Tactic "Scripted proof"
  implyR(1); andL(-1); dbx("x", 1)
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Bifurcation"

ProgramVariables
  Real r;
  Real x;
End.

Problem
  r <= 0 -> \exists f (x=f -> [{x'=r+x^2}]x=f)
End.

Tactic "Scripted proof"
implyR('R=="r<=0->\exists f (x=f->[{x'=r+x^2}]x=f)");
cut("r=0|r < 0"); <(
  "Use":
    hideL('L=="r<=0");
    orL('L=="r=0|r < 0"); <(
      "r=0":
        existsR("0", 'R=="\exists f (x=f->[{x'=r+x^2}]x=f)");
        implyR('R=="x=0->[{x'=r+x^2}]x=0");
        dG("{y'=-x*y}", "y*x=0&y>0", 'R=="[{x'=r+x^2}]x=0");
        existsR("1", 'R=="\exists y [{x'=r+x^2,y'=(-x)*y+0}](y*x=0&y>0)");
        boxAnd('R=="[{x'=r+x^2,y'=(-x)*y+0}](y*x=0&y>0)");
        andR('R=="[{x'=r+x^2,y'=(-x)*y+0}]y*x=0&[{x'=r+x^2,y'=(-x)*y+0}]y>0"); <(
          "[{x'=r+x^2,y'=(-x)*y+0}]y*x=0":
            dI('R=="[{x'=r+x^2,y'=(-x)*y+0}]y*x=0"),
          "[{x'=r+x^2,y'=(-x)*y+0}]y>0":
            dG("{z'=x/2*z}", "z^2*y=1", 'R=="[{x'=r+x^2,y'=(-x)*y+0}]y>0");
            existsR("1", 'R=="\exists z [{x'=r+x^2,y'=(-x)*y+0,z'=x/2*z+0}]z^2*y=1");
            dI('R=="[{x'=r+x^2,y'=(-x)*y+0,z'=x/2*z+0}]z^2*y=1")
        ),
      "r < 0":
        cut("\exists s r=-s*s"); <(
          "Use":
            existsL('L=="\exists s r=-s*s");
            existsR("-s", 'R=="\exists f (x=f->[{x'=r+x^2}]x=f)");
            implyR('R=="x=-s->[{x'=r+x^2}]x=-s");
            dG("{y'=(-(x-s))*y}", "y*(x+s)=0&y>0", 'R=="[{x'=r+x^2}]x=-s");
            existsR("1", 'R=="\exists y [{x'=r+x^2,y'=(-(x-s))*y+0}](y*(x+s)=0&y>0)");
            boxAnd('R=="[{x'=r+x^2,y'=(-(x-s))*y+0}](y*(x+s)=0&y>0)");
            andR('R=="[{x'=r+x^2,y'=(-(x-s))*y+0}]y*(x+s)=0&[{x'=r+x^2,y'=(-(x-s))*y+0}]y>0"); <(
              "[{x'=r+x^2,y'=(-(x-s))*y+0}]y*(x+s)=0":
                dI('R=="[{x'=r+x^2,y'=(-(x-s))*y+0}]y*(x+s)=0"),
              "[{x'=r+x^2,y'=(-(x-s))*y+0}]y>0":
                dG("{z'=(x-s)/2*z}", "z^2*y=1", 'R=="[{x'=r+x^2,y'=(-(x-s))*y+0}]y>0");
                existsR("1", 'R=="\exists z [{x'=r+x^2,y'=(-(x-s))*y+0,z'=(x-s)/2*z+0}]z^2*y=1");
                dI('R=="[{x'=r+x^2,y'=(-(x-s))*y+0,z'=(x-s)/2*z+0}]z^2*y=1")
            ),
          "Show":
            hideR('R=="\exists f (x=f->[{x'=r+x^2}]x=f)");
            QE
        )
    ),
  "Show":
    hideR('R=="\exists f (x=f->[{x'=r+x^2}]x=f)");
    QE
)
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Parametric switching between two different damped oscillators"

Description "Parametric switching between two different damped oscillators".
Citation "Andre Platzer. Logical Analysis of Hybrid Systems: Proving Theorems for Complex Dynamics. Springer, 2010".

ProgramVariables
  Real x;
  Real y;
  Real w;
  Real d;
  Real c;
  Real a;
  Real b;
End.

Problem
    w>=0 & d>=0
  & (-2)<=a&a<=2
  & b^2>=1/3
  & w^2*x^2+y^2 <= c
->
  [{
    {x'=y, y'=-w^2*x-2*d*w*y}@invariant(w^2*x^2+y^2<=c&d>=0&w>=0);
    {  { ?(x=y*a); w:=2*w; d:=d/2; c := c * ((2*w)^2+1^2) / (w^2+1^2); }
    ++ { ?(x=y*b); w:=w/2; d:=2*d; c := c * (w^2+1^2) / ((2*w^2)+1^2); }
    ++ { ?true; } }
   }*@invariant(w^2*x^2+y^2<=c&d>=0&w>=0)
  ] w^2*x^2+y^2 <= c
End.

Tactic "Scripted proof"
useSolver("Mathematica");
implyR('R=="w>=0&d>=0&(-2)<=a&a<=2&b^2>=1/3&w^2*x^2+y^2<=c->[{{x'=y,y'=-w^2*x-2*d*w*y}{?x=y*a;w:=2*w;d:=d/2;c:=c*((2*w)^2+1^2)/(w^2+1^2);++?x=y*b;w:=w/2;d:=2*d;c:=c*(w^2+1^2)/(2*w^2+1^2);++?true;}}*]w^2*x^2+y^2<=c");
loop("w^2*x^2+y^2<=c&d>=0&w>=0", 'R=="[{{x'=y,y'=-w^2*x-2*d*w*y}{?x=y*a;w:=2*w;d:=d/2;c:=c*((2*w)^2+1^2)/(w^2+1^2);++?x=y*b;w:=w/2;d:=2*d;c:=c*(w^2+1^2)/(2*w^2+1^2);++?true;}}*]w^2*x^2+y^2<=c"); <(
  "Init":
    auto,
  "Post":
    auto,
  "Step":
    composeb('R=="[{x'=y,y'=-w^2*x-2*d*w*y}{?x=y*a;w:=2*w;d:=d/2;c:=c*((2*w)^2+1^2)/(w^2+1^2);++?x=y*b;w:=w/2;d:=2*d;c:=c*(w^2+1^2)/(2*w^2+1^2);++?true;}](w^2*x^2+y^2<=c&d>=0&w>=0)");
    MR("w^2*x^2+y^2<=c&d>=0&w>=0", 'R=="[{x'=y,y'=-w^2*x-2*d*w*y}][?x=y*a;w:=2*w;d:=d/2;c:=c*((2*w)^2+1^2)/(w^2+1^2);++?x=y*b;w:=w/2;d:=2*d;c:=c*(w^2+1^2)/(2*w^2+1^2);++?true;](w^2*x^2+y^2<=c&d>=0&w>=0)"); <(
      "Use Q->P":
        auto,
      "Show [a]Q":
        auto
    )
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Nonlinear 1"

ProgramVariables
  Real x;
  Real a;
End.

Problem
  x^3 >= -1 -> [{x'=(x-3)^4+a & a>=0}] x^3>=-1
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Nonlinear 2"

Description "Example 2".
Citation "Tiwari, A. & Khanna, G. Alur, R. & Pappas, G. J. (ed.) Nonlinear Systems: Approximating Reach Sets. HSCC, Springer, 2004, 2993, 600-614".

ProgramVariables
  Real x1;
  Real x2;
  Real a;
End.

Problem
  x1+x2^2/2=a -> [{x1'=x1*x2,x2'=-x1}]x1+x2^2/2=a
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Nonlinear 4"

Description "Example 4".
Citation "Tiwari, A. & Khanna, G. Alur, R. & Pappas, G. J. (ed.) Nonlinear Systems: Approximating Reach Sets. HSCC, Springer, 2004, 2993, 600-614".

ProgramVariables
  Real x1;
  Real x2;
  Real a;
End.

Problem
  x1^2/2-x2^2/2>=a -> [{x1'=x2+x1*x2^2, x2'=-x1+x1^2*x2 & x1>=0 & x2>=0}]x1^2/2-x2^2/2>=a
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Nonlinear 5"

Description "Example 5".
Citation "Tiwari, A. & Khanna, G. Alur, R. & Pappas, G. J. (ed.) Nonlinear Systems: Approximating Reach Sets. HSCC, Springer, 2004, 2993, 600-614".

ProgramVariables
  Real x1;
  Real x2;
  Real a;
End.

Problem
  -x1*x2>=a -> [{x1'=x1-x2+x1*x2, x2'=-x2-x2^2}]-x1*x2>=a
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Riccati"

ProgramVariables
  Real x;
End.

Problem
   2*x^3 >= 1/4 -> [{x'=x^2+x^4}] 2*x^3>=1/4
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/Dynamics: Nonlinear differential cut"

ProgramVariables
  Real x;
  Real y;
End.

Problem
  x^3 >= -1 & y^5 >= 0 -> [{x'=(x-3)^4+y^5, y'=y^2}] (x^3 >= -1 & y^5 >= 0)
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

Theorem "Benchmarks/Basic/Affine: Overdamped Door Closing Mechanism"

Citation "Huerta y Munive, J.J. (2020). Affine Systems of ODEs in Isabelle/HOL for Hybrid-Program Verification. In: de Boer, F., Cerone, A. (eds) Software Engineering and Formal Methods. SEFM 2020. Lecture Notes in Computer Science(), vol 12310. Springer, Cham. https://doi.org/10.1007/978-3-030-58768-0_5".

Definitions
  Real a, b;
End.

ProgramVariables
  Real x, y;
End.

Problem
  x=0 & b^2+a*4 > 0 & a<0 & b<=0 -> [{x:=*; ?x>0; y:=0; {x'=y, y'=a*x+b*y}@invariant(x>=0)}*@invariant(x>=0)]x>=0
End.

Tactic "Scripted proof"
useSolver("Mathematica");
implyR('R=="x=0&b()^2+a()*4>0&a() < 0&b()<=0->[{x:=*;?x>0;y:=0;{x'=y,y'=a()*x+b()*y}}*]x>=0");
loop("x>=0", 'R=="[{x:=*;?x>0;y:=0;{x'=y,y'=a()*x+b()*y}}*]x>=0"); <(
  "Init":
    QE using "x=0 :: x>=0 :: nil",
  "Post":
    id,
  "Step":
    unfold;
    cut("\exists w w=(-b()+(b()^2+4*a())^(1/2))/2"); <(
      "Use":
        existsL('L=="\exists w w=(-b()+(b()^2+4*a())^(1/2))/2");
        dC("-w*x<=y&y<=0", 'R=="[{x'=y,y'=a()*x+b()*y}]x>=0"); <(
          "Use":
            dW('R=="[{x'=y,y'=a()*x+b()*y&true&-w*x<=y&y<=0}]x>=0");
            QE,
          "Show":
            ODEinv('R=="[{x'=y,y'=a()*x+b()*y}](-w*x<=y&y<=0)")
        ),
      "Show":
        QE using "b()^2+a()*4>0 :: \exists w w=(-b()+(b()^2+4*a())^(1/2))/2 :: nil"
    )
)
End.

End.

ArchiveEntry "Benchmarks/Basic/STTT Tutorial: Example 1"

Description "A simple system in which a car starts at some nonnegative velocity and accelerates at a constant rate along a straight lane. The requirement we want to prove is that the car never travels backward in space.".
Citation "Jan-David Quesel, Stefan Mitsch, Sarah Loos, Nikos Aréchiga, and André Platzer. How to model and prove hybrid systems with KeYmaera: A tutorial on safety. STTT, 18(1), pp. 67-91, 2016.".
Link "http://symbolaris.com/pub/KeYmaera-tutorial.pdf#page=7".

Definitions
  Real A;
End.

ProgramVariables
  Real x;
  Real v;
End.

Problem
  v >= 0 & A > 0 -> [ { x' = v, v' = A } ] v >= 0
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/STTT Tutorial: Example 2"

Description "A hybrid system model of a car with discrete control choices: accelerate, stay stopped, or brake. The requirement to prove is that the car never travels backwards in space.".
Citation "Jan-David Quesel, Stefan Mitsch, Sarah Loos, Nikos Aréchiga, and André Platzer. How to model and prove hybrid systems with KeYmaera: A tutorial on safety. STTT, 18(1), pp. 67-91, 2016.".
Link "http://symbolaris.com/pub/KeYmaera-tutorial.pdf#page=8".

Definitions
  Real A;
  Real B;
End.

ProgramVariables
  Real x;
  Real v;
  Real a;
End.

Problem
    v >= 0 & A > 0 & B > 0
 -> [
      { {a := A; ++ a := 0; ++ a := -B;};
        { x' = v, v' = a & v >= 0 }
      }*@invariant(v >= 0)
    ] v >= 0
End.

Tactic "Scripted proof"
implyR('R=="v>=0&A()>0&B()>0->[{{a:=A();++a:=0;++a:=-B();}{x'=v,v'=a&v>=0}}*]v>=0");
loop("v>=0", 'R=="[{{a:=A();++a:=0;++a:=-B();}{x'=v,v'=a&v>=0}}*]v>=0"); <(
  "Init":
    id,
  "Post":
    id,
  "Step":
    composeb('R=="[{a:=A();++a:=0;++a:=-B();}{x'=v,v'=a&v>=0}]v>=0");
    DW('R=="[a:=A();++a:=0;++a:=-B();]#[{x'=v,v'=a&v>=0}]v>=0#");
    simplify('R=="[a:=A();++a:=0;++a:=-B();][{x'=v,v'=a&v>=0}](v>=0->v>=0)");
    GV('R=="[a:=A();++a:=0;++a:=-B();]#[{x'=v,v'=a&v>=0}]true#");
    GV('R=="[a:=A();++a:=0;++a:=-B();]true");
    closeT
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/STTT Tutorial: Example 3a"

Description "A hybrid car model where the controller runs when the car is about to run a stop sign. The requirement to prove is that the car never runs the stop sign.".
Citation "Jan-David Quesel, Stefan Mitsch, Sarah Loos, Nikos Aréchiga, and André Platzer. How to model and prove hybrid systems with KeYmaera: A tutorial on safety. STTT, 18(1), pp. 67-91, 2016.".
Link "http://symbolaris.com/pub/KeYmaera-tutorial.pdf#page=10".

Definitions
  Real A;
  Real B;
  Real S;
End.

ProgramVariables
  Real x;
  Real v;
  Real a;
End.

Problem
    v >= 0 & A > 0 & B > 0 & x+v^2/(2*B) < S
 -> [
      { {   ?x+v^2/(2*B) < S; a := A;
         ++ ?v=0; a := 0;
         ++ a := -B;
        }

        {
           {x' = v, v' = a & v >= 0 & x+v^2/(2*B) <= S}
        ++ {x' = v, v' = a & v >= 0 & x+v^2/(2*B) >= S}
        }
      }*@invariant(v >= 0 & x+v^2/(2*B) <= S)
    ] x <= S
End.

Tactic "Scripted proof"
implyR('R=="v>=0&A()>0&B()>0&x+v^2/(2*B()) < S()->[{{?x+v^2/(2*B()) < S();a:=A();++?v=0;a:=0;++a:=-B();}{{x'=v,v'=a&v>=0&x+v^2/(2*B())<=S()}++{x'=v,v'=a&v>=0&x+v^2/(2*B())>=S()}}}*]x<=S()");
loop("v>=0&x+v^2/(2*B())<=S()", 'R=="[{{?x+v^2/(2*B()) < S();a:=A();++?v=0;a:=0;++a:=-B();}{{x'=v,v'=a&v>=0&x+v^2/(2*B())<=S()}++{x'=v,v'=a&v>=0&x+v^2/(2*B())>=S()}}}*]x<=S()"); <(
  "Init":
    QE,
  "Post":
    QE,
  "Step":
    unfold;
    doall(ODE(1))
)
End.

Tactic "Scripted proof (2)"
unfold;
loop("v>=0&x+v^2/(2*B())<=S()", 'R=="[{{?x+v^2/(2*B()) < S();a:=A();++?v=0;a:=0;++a:=-B();}{{x'=v,v'=a&v>=0&x+v^2/(2*B())<=S()}++{x'=v,v'=a&v>=0&x+v^2/(2*B())>=S()}}}*]x<=S()"); <(
  "Init":
    QE,
  "Post":
    QE,
  "Step":
    unfold; <(
      "[{x'=v,v'=A()&v>=0&x+v^2/(2*B())<=S()}](v>=0&x+v^2/(2*B())<=S())":
        dW('R=="[{x'=v,v'=A()&v>=0&x+v^2/(2*B())<=S()}](v>=0&x+v^2/(2*B())<=S())");
        propClose,
      "[{x'=v,v'=0&v>=0&x+v^2/(2*B())<=S()}](v>=0&x+v^2/(2*B())<=S())":
        dW('R=="[{x'=v,v'=0&v>=0&x+v^2/(2*B())<=S()}](v>=0&x+v^2/(2*B())<=S())");
        propClose,
      "[{x'=v,v'=-B()&v>=0&x+v^2/(2*B())<=S()}](v>=0&x+v^2/(2*B())<=S())":
        dW('R=="[{x'=v,v'=-B()&v>=0&x+v^2/(2*B())<=S()}](v>=0&x+v^2/(2*B())<=S())");
        propClose,
      "[{x'=v,v'=-B()&v>=0&x+v^2/(2*B())>=S()}](v>=0&x+v^2/(2*B())<=S())":
        diffUnpackEvolDomain('R=="[{x'=v,v'=-B()&v>=0&x+v^2/(2*B())>=S()}](v>=0&x+v^2/(2*B())<=S())");
        dC("v<=old(v)", 'R=="[{x'=v,v'=-B()&v>=0&x+v^2/(2*B())>=S()}](v>=0&x+v^2/(2*B())<=S())"); <(
          "Use":
            dC("x+v^2/(2*B())<=old(x+v^2/(2*B()))", 'R=="[{x'=v,v'=-B()&(v>=0&x+v^2/(2*B())>=S())&v<=v_0}](v>=0&x+v^2/(2*B())<=S())"); <(
              "Use":
                dWplus('R=="[{x'=v,v'=-B()&((v>=0&x+v^2/(2*B())>=S())&v<=v_0)&x+v^2/(2*B())<=old}](v>=0&x+v^2/(2*B())<=S())");
                unfold;
                QE using "B()>0 :: x_0+v_0^2/(2*B())<=S() :: old=x_0+v_0^2/(2*B()) :: x_0+v_0^2/(2*B())>=S() :: x+v^2/(2*B())<=old :: v>=0 :: v>=0&x+v^2/(2*B())<=S() :: nil",
              "Show":
                dIClose(1) using "B()>0 :: old=x+v^2/(2*B()) :: [{x'=v,v'=-B()&(v>=0&x+v^2/(2*B())>=S())&v<=v_0}]x+v^2/(2*B())<=old :: nil"
            ),
          "Show":
            dIClose(1) using "B()>0 :: v_0=v :: [{x'=v,v'=-B()&v>=0&x+v^2/(2*B())>=S()}]v<=v_0 :: nil"
        ),
      "[{x'=v,v'=A()&v>=0&x+v^2/(2*B())>=S()}](v>=0&x+v^2/(2*B())<=S())":
        diffUnpackEvolDomain('R=="[{x'=v,v'=A()&v>=0&x+v^2/(2*B())>=S()}](v>=0&x+v^2/(2*B())<=S())");
        QE using "B()>0 :: x+v^2/(2*B()) < S() :: v>=0&x+v^2/(2*B())>=S() :: nil",
      "[{x'=v,v'=0&v>=0&x+v^2/(2*B())>=S()}](v>=0&x+v^2/(2*B())<=S())":
        diffUnpackEvolDomain('R=="[{x'=v,v'=0&v>=0&x+v^2/(2*B())>=S()}](v>=0&x+v^2/(2*B())<=S())");
        dC("v=old(v)", 'R=="[{x'=v,v'=0&v>=0&x+v^2/(2*B())>=S()}](v>=0&x+v^2/(2*B())<=S())"); <(
          "Use":
            dC("x=old(x)", 'R=="[{x'=v,v'=0&(v>=0&x+v^2/(2*B())>=S())&v=v_0}](v>=0&x+v^2/(2*B())<=S())"); <(
              "Use":
                dWplus('R=="[{x'=v,v'=0&((v>=0&x+v^2/(2*B())>=S())&v=v_0)&x=x_0}](v>=0&x+v^2/(2*B())<=S())");
                unfold;
                QE using "x_0+v_0^2/(2*B())<=S() :: x=x_0 :: v=v_0 :: v>=0 :: v>=0&x+v^2/(2*B())<=S() :: nil",
              "Show":
                dIClose(1) using "v_0=0 :: x_0=x :: [{x'=v,v'=0&(v>=0&x+v^2/(2*B())>=S())&v=v_0}]x=x_0 :: nil"
            ),
          "Show":
            dIClose(1) using "v_0=v :: [{x'=v,v'=0&v>=0&x+v^2/(2*B())>=S()}]v=v_0 :: nil"
        )
    )
)
End.

Tactic "Automated proof (from annotations)"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/STTT Tutorial: Example 4a"

Description "A hybrid car model where the controller runs when the car is about to run a stop sign. The example illustrates that certain modeling pitfalls result in vacuous proofs.".
Citation "Jan-David Quesel, Stefan Mitsch, Sarah Loos, Nikos Aréchiga, and André Platzer. How to model and prove hybrid systems with KeYmaera: A tutorial on safety. STTT, 18(1), pp. 67-91, 2016.".
Link "http://symbolaris.com/pub/KeYmaera-tutorial.pdf#page=12".

Definitions
  Real A;
  Real V;
End.

ProgramVariables
  Real x;
  Real v;
  Real a;
End.

Problem
    v <= V & A > 0
 -> [
      { {
           ?v=V; a:=0;
        ++ ?v!=V; a:=A;
        }

        {x' = v, v' = a & v <= V}
      }*@invariant(v <= V)
    ] v <= V
End.

Tactic "Scripted proof"
implyR('R=="v<=V()&A()>0->[{{?v=V();a:=0;++?v!=V();a:=A();}{x'=v,v'=a&v<=V()}}*]v<=V()");
loop("v<=V()", 'R=="[{{?v=V();a:=0;++?v!=V();a:=A();}{x'=v,v'=a&v<=V()}}*]v<=V()"); <(
  "Init":
    id,
  "Post":
    id,
  "Step":
    composeb('R=="[{?v=V();a:=0;++?v!=V();a:=A();}{x'=v,v'=a&v<=V()}]v<=V()");
    DW('R=="[?v=V();a:=0;++?v!=V();a:=A();]#[{x'=v,v'=a&v<=V()}]v<=V()#");
    simplify('R=="[?v=V();a:=0;++?v!=V();a:=A();][{x'=v,v'=a&v<=V()}](v<=V()->v<=V())");
    GV('R=="[?v=V();a:=0;++?v!=V();a:=A();]#[{x'=v,v'=a&v<=V()}]true#");
    GV('R=="[?v=V();a:=0;++?v!=V();a:=A();]true");
    closeT
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/STTT Tutorial: Example 4b"

Description "A hybrid car model where the controller runs when the car is about to run a stop sign. The example illustrates that overly strong evolution domain constraints can result in a vacuous proof.".
Citation "Jan-David Quesel, Stefan Mitsch, Sarah Loos, Nikos Aréchiga, and André Platzer. How to model and prove hybrid systems with KeYmaera: A tutorial on safety. STTT, 18(1), pp. 67-91, 2016.".
Link "http://symbolaris.com/pub/KeYmaera-tutorial.pdf#page=12".

Definitions
  Real A;
  Real V;
End.

ProgramVariables
  Real x;
  Real v;
  Real a;
End.

Problem
    v <= V & A > 0
 -> [
      { a := A;

        {x' = v, v' = a & v <= V}
      }*@invariant(v <= V)
    ] v <= V
End.

Tactic "Scripted proof"
implyR('R=="v<=V()&A()>0->[{a:=A();{x'=v,v'=a&v<=V()}}*]v<=V()");
loop("v<=V()", 'R=="[{a:=A();{x'=v,v'=a&v<=V()}}*]v<=V()"); <(
  "Init":
    id,
  "Post":
    id,
  "Step":
    composeb('R=="[a:=A();{x'=v,v'=a&v<=V()}]v<=V()");
    DW('R=="[a:=A();]#[{x'=v,v'=a&v<=V()}]v<=V()#");
    simplify('R=="[a:=A();][{x'=v,v'=a&v<=V()}](v<=V()->v<=V())");
    GV('R=="[a:=A();]#[{x'=v,v'=a&v<=V()}]true#");
    GV('R=="[a:=A();]true");
    closeT
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/STTT Tutorial: Example 4c"

Description "A hybrid car model where the controller runs when the car is about to run a stop sign. The example illustrates the correct modeling idiom to prevent vacuous proofs from evolution domain constraints.".
Citation "Jan-David Quesel, Stefan Mitsch, Sarah Loos, Nikos Aréchiga, and André Platzer. How to model and prove hybrid systems with KeYmaera: A tutorial on safety. STTT, 18(1), pp. 67-91, 2016.".
Link "http://symbolaris.com/pub/KeYmaera-tutorial.pdf#page=12".

Definitions
  Real A;
  Real V;
End.

ProgramVariables
  Real x;
  Real v;
  Real a;
End.

Problem
    v <= V & A > 0
 -> [
      { {
           ?v=V; a:=0;
        ++ ?v!=V; a:=A;
        }

        {  {x' = v, v' = a & v <= V}
        ++ {x' = v, v' = a & v >= V}}
      }*@invariant(v <= V)
    ] v <= V
End.

Tactic "Scripted proof"
implyR('R=="v<=V()&A()>0->[{{?v=V();a:=0;++?v!=V();a:=A();}{{x'=v,v'=a&v<=V()}++{x'=v,v'=a&v>=V()}}}*]v<=V()");
loop("v<=V()", 'R=="[{{?v=V();a:=0;++?v!=V();a:=A();}{{x'=v,v'=a&v<=V()}++{x'=v,v'=a&v>=V()}}}*]v<=V()"); <(
  "Init":
    id,
  "Post":
    id,
  "Step":
    composeb('R=="[{?v=V();a:=0;++?v!=V();a:=A();}{{x'=v,v'=a&v<=V()}++{x'=v,v'=a&v>=V()}}]v<=V()");
    choiceb('R=="[?v=V();a:=0;++?v!=V();a:=A();]#[{x'=v,v'=a&v<=V()}++{x'=v,v'=a&v>=V()}]v<=V()#");
    DW('R=="[?v=V();a:=0;++?v!=V();a:=A();](#[{x'=v,v'=a&v<=V()}]v<=V()#&[{x'=v,v'=a&v>=V()}]v<=V())");
    simplify('R=="[?v=V();a:=0;++?v!=V();a:=A();]([{x'=v,v'=a&v<=V()}](v<=V()->v<=V())&[{x'=v,v'=a&v>=V()}]v<=V())");
    GV('R=="[?v=V();a:=0;++?v!=V();a:=A();](#[{x'=v,v'=a&v<=V()}]true#&[{x'=v,v'=a&v>=V()}]v<=V())");
    trueAnd('R=="[?v=V();a:=0;++?v!=V();a:=A();]#true&[{x'=v,v'=a&v>=V()}]v<=V()#");
    choiceb('R=="[?v=V();a:=0;++?v!=V();a:=A();][{x'=v,v'=a&v>=V()}]v<=V()");
    andR('R=="[?v=V();a:=0;][{x'=v,v'=a&v>=V()}]v<=V()&[?v!=V();a:=A();][{x'=v,v'=a&v>=V()}]v<=V()"); <(
      "[?v=V();a:=0;][{x'=v,v'=a&v>=V()}]v<=V()":
        unfold;
        ODEinv('R=="[{x'=v,v'=0&v>=V()}]v<=V()"),
      "[?v!=V();a:=A();][{x'=v,v'=a&v>=V()}]v<=V()":
        unfold;
        diffUnpackEvolDomain('R=="[{x'=v,v'=A()&v>=V()}]v<=V()");
        hideR('R=="[{x'=v,v'=A()&v>=V()}]v<=V()");
        QE
    )
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/STTT Tutorial: Example 5"

Description "A hybrid car model where the controller runs periodically at some maximum time interval between executions. The requirement to prove is that the car never runs the stop sign.".
Citation "Jan-David Quesel, Stefan Mitsch, Sarah Loos, Nikos Aréchiga, and André Platzer. How to model and prove hybrid systems with KeYmaera: A tutorial on safety. STTT, 18(1), pp. 67-91, 2016.".
Link "http://symbolaris.com/pub/KeYmaera-tutorial.pdf#page=13".

Definitions
  Real A;
  Real B;
  Real S;
  Real ep;
End.

ProgramVariables
  Real x;
  Real v;
  Real a;
  Real c;
End.

Problem
    v >= 0 & A > 0 & B > 0 & x+v^2/(2*B) <= S & ep > 0
 -> [
      { {   ?x+v^2/(2*B) + (A/B+1)*(A/2*ep^2+ep*v) <= S; a := A;
         ++ ?v=0; a := 0;
         ++ a := -B;
        };

        c := 0;
        { x' = v, v' = a, c' = 1 & v >= 0 & c <= ep }
      }*@invariant(v >= 0 & x+v^2/(2*B) <= S)
    ] x <= S
End.

Tactic "Scripted proof"
implyR('R=="v>=0&A()>0&B()>0&x+v^2/(2*B())<=S()&ep()>0->[{{?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=A();++?v=0;a:=0;++a:=-B();}c:=0;{x'=v,v'=a,c'=1&v>=0&c<=ep()}}*]x<=S()");
loop("v>=0&x+v^2/(2*B())<=S()", 'R=="[{{?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=A();++?v=0;a:=0;++a:=-B();}c:=0;{x'=v,v'=a,c'=1&v>=0&c<=ep()}}*]x<=S()"); <(
  "Init":
    QE,
  "Post":
    QE,
  "Step":
    composeb('R=="[{?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=A();++?v=0;a:=0;++a:=-B();}c:=0;{x'=v,v'=a,c'=1&v>=0&c<=ep()}](v>=0&x+v^2/(2*B())<=S())");
    composeb('R=="[?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=A();++?v=0;a:=0;++a:=-B();]#[c:=0;{x'=v,v'=a,c'=1&v>=0&c<=ep()}](v>=0&x+v^2/(2*B())<=S())#");
    boxAnd('R=="[?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=A();++?v=0;a:=0;++a:=-B();][c:=0;]#[{x'=v,v'=a,c'=1&v>=0&c<=ep()}](v>=0&x+v^2/(2*B())<=S())#");
    DW('R=="[?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=A();++?v=0;a:=0;++a:=-B();][c:=0;](#[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]v>=0#&[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]x+v^2/(2*B())<=S())");
    simplify('R=="[?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=A();++?v=0;a:=0;++a:=-B();][c:=0;]([{x'=v,v'=a,c'=1&v>=0&c<=ep()}](v>=0&c<=ep()->v>=0)&[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]x+v^2/(2*B())<=S())");
    GV('R=="[?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=A();++?v=0;a:=0;++a:=-B();][c:=0;](#[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]true#&[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]x+v^2/(2*B())<=S())");
    trueAnd('R=="[?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=A();++?v=0;a:=0;++a:=-B();][c:=0;]#true&[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]x+v^2/(2*B())<=S()#");
    solve('R=="[?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=A();++?v=0;a:=0;++a:=-B();][c:=0;]#[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]x+v^2/(2*B())<=S()#");
    unfold; <(
      "[?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=A();][c:=0;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->a*s_+v>=0&s_+c<=ep())->a*(t_^2/2)+v*t_+x+(a*t_+v)^2/(2*B())<=S())":
        QE,
      "[?v=0;a:=0;][c:=0;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->a*s_+v>=0&s_+c<=ep())->a*(t_^2/2)+v*t_+x+(a*t_+v)^2/(2*B())<=S())":
        allL2R('L=="v=0");
        simplify('R=="#0*(t_^2/2)+0*t_+x+(0*t_+0)^2/(2*B())#<=S()");
        simplify('L=="x+#0^2/(2*B())#<=S()");
        id,
      "[a:=-B();][c:=0;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->a*s_+v>=0&s_+c<=ep())->a*(t_^2/2)+v*t_+x+(a*t_+v)^2/(2*B())<=S())":
        QE
    )
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/STTT Tutorial: Example 6"

Description "A hybrid car model where the controller can make non-deterministic decisions on acceleration. The requirement to prove is that the controller never runs the stop sign.".
Citation "Jan-David Quesel, Stefan Mitsch, Sarah Loos, Nikos Aréchiga, and André Platzer. How to model and prove hybrid systems with KeYmaera: A tutorial on safety. STTT, 18(1), pp. 67-91, 2016.".
Link "http://symbolaris.com/pub/KeYmaera-tutorial.pdf#page=14".

Definitions
  Real A;
  Real B;
  Real S;
  Real ep;
End.

ProgramVariables
  Real x;
  Real v;
  Real a;
  Real c;
End.

Problem
    v >= 0 & A > 0 & B > 0 & x+v^2/(2*B) <= S & ep > 0
 -> [
      { {   ?x+v^2/(2*B) + (A/B+1)*(A/2*ep^2+ep*v) <= S; a :=*; ?-B <= a & a <= A;
         ++ ?v=0; a := 0;
         ++ a := -B;
        };

        c := 0;
        { x' = v, v' = a, c' = 1 & v >= 0 & c <= ep }
      }*@invariant(v >= 0 & x+v^2/(2*B) <= S)
    ] x <= S
End.

Tactic "Scripted proof"
useSolver("Mathematica");
implyR('R=="v>=0&A()>0&B()>0&x+v^2/(2*B())<=S()&ep()>0->[{{?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=-B();}c:=0;{x'=v,v'=a,c'=1&v>=0&c<=ep()}}*]x<=S()");
loop("v>=0&x+v^2/(2*B())<=S()", 'R=="[{{?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=-B();}c:=0;{x'=v,v'=a,c'=1&v>=0&c<=ep()}}*]x<=S()"); <(
  "Init":
    QE,
  "Post":
    QE,
  "Step":
    composeb('R=="[{?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=-B();}c:=0;{x'=v,v'=a,c'=1&v>=0&c<=ep()}](v>=0&x+v^2/(2*B())<=S())");
    composeb('R=="[?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=-B();]#[c:=0;{x'=v,v'=a,c'=1&v>=0&c<=ep()}](v>=0&x+v^2/(2*B())<=S())#");
    boxAnd('R=="[?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=-B();][c:=0;]#[{x'=v,v'=a,c'=1&v>=0&c<=ep()}](v>=0&x+v^2/(2*B())<=S())#");
    DW('R=="[?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=-B();][c:=0;](#[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]v>=0#&[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]x+v^2/(2*B())<=S())");
    simplify('R=="[?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=-B();][c:=0;]([{x'=v,v'=a,c'=1&v>=0&c<=ep()}](v>=0&c<=ep()->v>=0)&[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]x+v^2/(2*B())<=S())");
    GV('R=="[?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=-B();][c:=0;](#[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]true#&[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]x+v^2/(2*B())<=S())");
    trueAnd('R=="[?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=-B();][c:=0;]#true&[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]x+v^2/(2*B())<=S()#");
    solve('R=="[?x+v^2/(2*B())+(A()/B()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=-B();][c:=0;]#[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]x+v^2/(2*B())<=S()#");
    unfold;
    doall(print("QE..."); QE; print("done"))
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/STTT Tutorial: Example 7"

Description "A hybrid car model with non-deterministic braking characteristics. The requirement to prove is that the car never runs a stop sign.".
Citation "Jan-David Quesel, Stefan Mitsch, Sarah Loos, Nikos Aréchiga, and André Platzer. How to model and prove hybrid systems with KeYmaera: A tutorial on safety. STTT, 18(1), pp. 67-91, 2016.".
Link "http://symbolaris.com/pub/KeYmaera-tutorial.pdf#page=15".

Definitions
  Real A;
  Real B;
  Real b;
  Real S;
  Real ep;
End.

ProgramVariables
  Real x;
  Real v;
  Real a;
  Real c;
End.

Problem
    v >= 0 & A > 0 & B >= b & b > 0 & x+v^2/(2*b) <= S & ep > 0
 -> [
      { {   ?x+v^2/(2*b) + (A/b+1)*(A/2*ep^2+ep*v) <= S; a :=*; ?-B <= a & a <= A;
         ++ ?v=0; a := 0;
         ++ a :=*; ?-B <=a & a <= -b;
        };

        c := 0;
        { x' = v, v' = a, c' = 1 & v >= 0 & c <= ep }
      }*@invariant(v >= 0 & x+v^2/(2*b) <= S)
    ] x <= S
End.

Tactic "Scripted proof"
implyR('R=="v>=0&A()>0&B()>=b()&b()>0&x+v^2/(2*b())<=S()&ep()>0->[{{?x+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=*;?-B()<=a&a<=-b();}c:=0;{x'=v,v'=a,c'=1&v>=0&c<=ep()}}*]x<=S()");
loop("v>=0&x+v^2/(2*b())<=S()", 'R=="[{{?x+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=*;?-B()<=a&a<=-b();}c:=0;{x'=v,v'=a,c'=1&v>=0&c<=ep()}}*]x<=S()"); <(
  "Init":
    QE,
  "Post":
    QE,
  "Step":
    composeb('R=="[{?x+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=*;?-B()<=a&a<=-b();}c:=0;{x'=v,v'=a,c'=1&v>=0&c<=ep()}](v>=0&x+v^2/(2*b())<=S())");
    composeb('R=="[?x+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=*;?-B()<=a&a<=-b();]#[c:=0;{x'=v,v'=a,c'=1&v>=0&c<=ep()}](v>=0&x+v^2/(2*b())<=S())#");
    boxAnd('R=="[?x+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;]#[{x'=v,v'=a,c'=1&v>=0&c<=ep()}](v>=0&x+v^2/(2*b())<=S())#");
    DW('R=="[?x+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;](#[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]v>=0#&[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]x+v^2/(2*b())<=S())");
    simplify('R=="[?x+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;]([{x'=v,v'=a,c'=1&v>=0&c<=ep()}](v>=0&c<=ep()->v>=0)&[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]x+v^2/(2*b())<=S())");
    GV('R=="[?x+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;](#[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]true#&[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]x+v^2/(2*b())<=S())");
    trueAnd('R=="[?x+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;]#true&[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]x+v^2/(2*b())<=S()#");
    solve('R=="[?x+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v)<=S();a:=*;?-B()<=a&a<=A();++?v=0;a:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;]#[{x'=v,v'=a,c'=1&v>=0&c<=ep()}]x+v^2/(2*b())<=S()#");
    unfold;
    doall(print("QE..."); QE; print("done"))
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/STTT Tutorial: Example 9a"

Description "A PD controlled car. The requirement to prove is that the Lyapunov function is a differential invariant.".
Citation "Jan-David Quesel, Stefan Mitsch, Sarah Loos, Nikos Aréchiga, and André Platzer. How to model and prove hybrid systems with KeYmaera: A tutorial on safety. STTT, 18(1), pp. 67-91, 2016.".
Link "http://symbolaris.com/pub/KeYmaera-tutorial.pdf#page=17".

Definitions
  Real Kp();
  Real Kd();
  Real xr();
  Real c();
End.

ProgramVariables
  Real x1;
  Real v;
End.

Problem
    v >= 0 & c() > 0 & Kp() = 2 & Kd() = 3 & 5/4*(x1-xr())^2 + (x1-xr())*v/2 + v^2/4 < c()
 -> [
      { x1' = v, v' = -Kp()*(x1-xr()) - Kd()*v }
    ] 5/4*(x1-xr())^2 + (x1-xr())*v/2 + v^2/4 < c()
End.

Tactic "Scripted proof"
  implyR(1) ; ODEinv(1)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/STTT Tutorial: Example 9b"

Description "A PD controlled car with a trajectory generator for setting target speeds. The requirement to prove is that the car never runs a stop sign.".
Citation "Jan-David Quesel, Stefan Mitsch, Sarah Loos, Nikos Aréchiga, and André Platzer. How to model and prove hybrid systems with KeYmaera: A tutorial on safety. STTT, 18(1), pp. 67-91, 2016.".
Link "http://symbolaris.com/pub/KeYmaera-tutorial.pdf#page=18".

Definitions
  Real Kp;
  Real Kd;
  Real S;
End.

ProgramVariables
  Real x2;
  Real xm;
  Real xr;
  Real v;
End.

Problem
    v >= 0 & xm <= x2 & x2 <= S & xr = (xm + S)/2 & Kp = 2 & Kd = 3
           & 5/4*(x2-xr)^2 + (x2-xr)*v/2 + v^2/4 < ((S - xm)/2)^2
 -> [ { {  xm := x2;
           xr := (xm + S)/2;
           ?5/4*(x2-xr)^2 + (x2-xr)*v/2 + v^2/4 < ((S - xm)/2)^2;
        ++ ?true;
        };
        {{ x2' = v, v' = -Kp*(x2-xr) - Kd*v & v >= 0 }
          @invariant(
            xm<=x2,
            5/4*(x2-(xm+S())/2)^2 + (x2-(xm+S())/2)*v/2 + v^2/4 < ((S()-xm)/2)^2
         )
        }
      }*@invariant(v >= 0 & xm <= x2 & xr = (xm + S)/2 & 5/4*(x2-xr)^2 + (x2-xr)*v/2 + v^2/4 < ((S - xm)/2)^2)
    ] x2 <= S
End.

Tactic "Scripted proof"
implyR('R=="v>=0&xm<=x2&x2<=S()&xr=(xm+S())/2&Kp()=2&Kd()=3&5/4*(x2-xr)^2+(x2-xr)*v/2+v^2/4 < ((S()-xm)/2)^2->[{{xm:=x2;xr:=(xm+S())/2;?5/4*(x2-xr)^2+(x2-xr)*v/2+v^2/4 < ((S()-xm)/2)^2;++?true;}{x2'=v,v'=-Kp()*(x2-xr)-Kd()*v&v>=0}}*]x2<=S()");
loop("v>=0&xm<=x2&xr=(xm+S())/2&5/4*(x2-xr)^2+(x2-xr)*v/2+v^2/4 < ((S()-xm)/2)^2", 'R=="[{{xm:=x2;xr:=(xm+S())/2;?5/4*(x2-xr)^2+(x2-xr)*v/2+v^2/4 < ((S()-xm)/2)^2;++?true;}{x2'=v,v'=-Kp()*(x2-xr)-Kd()*v&v>=0}}*]x2<=S()"); <(
  "Init":
    prop,
  "Post":
    QE,
  "Step":
    unfold;
    doall(
      dC("xm<=x2", 1); <(
        "Use":
          dC("5/4*(x2-(xm+S())/2)^2+(x2-(xm+S())/2)*v/2+v^2/4 < ((S()-xm)/2)^2", 1); <(
            "Use":
              dW(1);
              QE,
            "Show":
              dI(1)
          ),
        "Show":
          dI(1)
      )
    )
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/STTT Tutorial: Example 10"

Description "A car with steering. The requirement to prove is that the car always stays inside the lane boundaries.".
Citation "Jan-David Quesel, Stefan Mitsch, Sarah Loos, Nikos Aréchiga, and André Platzer. How to model and prove hybrid systems with KeYmaera: A tutorial on safety. STTT, 18(1), pp. 67-91, 2016.".
Link "http://symbolaris.com/pub/KeYmaera-tutorial.pdf#page=20".

Definitions
  import kyx.math.abs;
  Real A;
  Real B;
  Real b;
  Real ep;
  Real lw;
  Real ly;
End.

ProgramVariables
  Real x;
  Real y;
  Real v;
  Real a;
  Real r;
  Real dx;
  Real dy;
  Real w;
  Real c;
End.

Problem
    v >= 0 & A > 0 & B >= b & b > 0 & ep > 0 & lw > 0 & y = ly & r != 0 & dx^2 + dy^2 = 1
           & abs(y-ly) + v^2/(2*b) < lw
 -> [
      { {   ?abs(y-ly) + v^2/(2*b) + (A/b+1)*(A/2*ep^2+ep*v) < lw;
            a :=*; ?-B <= a & a <= A;
            w :=*; r :=*; ?r != 0 & w*r = v;
         ++ ?v=0; a := 0; w := 0;
         ++ a :=*; ?-B <=a & a <= -b;
        }

        c := 0;
        {
        { x' = v*dx, y' = v*dy, v' = a, dx' = -dy*w, dy' = dx*w, w'=a/r, c' = 1 & v >= 0 & c <= ep }
        @invariant(
          c>=0,
          dx^2+dy^2=1,
          (v'=0 -> v=old(v)),
          (v'=0 -> -c*v <= y - old(y) & y - old(y) <= c*v),
          (v'=a -> v=old(v)+a*c),
          (v'=a -> -c*(v-a/2*c) <= y - old(y) & y - old(y) <= c*(v-a/2*c))
        )
        }
      }*@invariant(v >= 0 & dx^2+dy^2 = 1 & r != 0 & abs(y-ly) + v^2/(2*b) < lw)
    ] abs(y-ly) < lw
End.

Tactic "Scripted proof"
unfold;
loop("v>=0&dx^2+dy^2=1&r!=0&abs(y-ly())+v^2/(2*b()) < lw()", 'R=="[{{?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();}c:=0;{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}}*]abs(y-ly()) < lw()"); <(
  "Init":
    propClose,
  "Post":
    unfold;
    QE using "b()>0 :: lw()>0 :: abs(y-ly())+v^2/(2*b()) < lw() :: abs(y-ly()) < lw() :: nil",
  "Step":
    composeb('R=="[{?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();}c:=0;{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}](v>=0&dx^2+dy^2=1&r!=0&abs(y-ly())+v^2/(2*b()) < lw())");
    composeb('R=="[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();]#[c:=0;{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}](v>=0&dx^2+dy^2=1&r!=0&abs(y-ly())+v^2/(2*b()) < lw())#");
    boxAnd('R=="[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;]#[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}](v>=0&dx^2+dy^2=1&r!=0&abs(y-ly())+v^2/(2*b()) < lw())#");
    useAt("DW differential weakening", "0", 'R=="[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;](#[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}]v>=0#&[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}](dx^2+dy^2=1&r!=0&abs(y-ly())+v^2/(2*b()) < lw()))");
    simplify('R=="[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;]([{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}]#(v>=0&c<=ep()->v>=0)#&[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}](dx^2+dy^2=1&r!=0&abs(y-ly())+v^2/(2*b()) < lw()))");
    GV('R=="[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;](#[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}]true#&[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}](dx^2+dy^2=1&r!=0&abs(y-ly())+v^2/(2*b()) < lw()))");
    trueAnd('R=="[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;]#true&[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}](dx^2+dy^2=1&r!=0&abs(y-ly())+v^2/(2*b()) < lw())#");
    dC("c>=0", 'R=="[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;]#[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}](dx^2+dy^2=1&r!=0&abs(y-ly())+v^2/(2*b()) < lw())#"); <(
      "Use":
        dC("dx^2+dy^2=1", 'R=="[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;]#[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&(v>=0&c<=ep())&c>=0}](dx^2+dy^2=1&r!=0&abs(y-ly())+v^2/(2*b()) < lw())#"); <(
          "Use":
            boxAnd('R=="[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;]#[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1}](dx^2+dy^2=1&r!=0&abs(y-ly())+v^2/(2*b()) < lw())#");
            useAt("DW differential weakening", "0", 'R=="[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;](#[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1}]dx^2+dy^2=1#&[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1}](r!=0&abs(y-ly())+v^2/(2*b()) < lw()))");
            simplify('R=="[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;]([{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1}]#(((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1->dx^2+dy^2=1)#&[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1}](r!=0&abs(y-ly())+v^2/(2*b()) < lw()))");
            GV('R=="[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;](#[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1}]true#&[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1}](r!=0&abs(y-ly())+v^2/(2*b()) < lw()))");
            trueAnd('R=="[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;]#true&[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1}](r!=0&abs(y-ly())+v^2/(2*b()) < lw())#");
            dC("v=old(v)+a*c", 'R=="[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;]#[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1}](r!=0&abs(y-ly())+v^2/(2*b()) < lw())#"); <(
              "Use":
                dC("-c*(v-a/2*c)<=y-old(y)&y-old(y)<=c*(v-a/2*c)", 'R=="[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;++?v=0;a:=0;w:=0;++a:=*;?-B()<=a&a<=-b();][c:=0;]\forall v_0 (v_0=v->#[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&(((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1)&v=v_0+a*c}](r!=0&abs(y-ly())+v^2/(2*b()) < lw())#)"); <(
                  "Use":
                    unfold; <(
                      "[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;][c:=0;]\forall v_0 (v_0=v->\forall y_0 (y_0=y->[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1)&v=v_0+a*c)&-c*(v-a/2*c)<=y-y_0&y-y_0<=c*(v-a/2*c)}](r!=0&abs(y-ly())+v^2/(2*b()) < lw())))":
                        dWplus('R=="[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1)&v=v_0+a*c)&-c*(v-a/2*c)<=y-y_0&y-y_0<=c*(v-a/2*c)}](r!=0&abs(y-ly())+v^2/(2*b()) < lw())");
                        simplify(1) using "r!=0 :: r!=0&abs(y-ly())+v^2/(2*b()) < lw() :: nil";
                        unfold;
                        hideL('L=="r!=0");
                        hideL('L=="w_0*r=v_0");
                        hideL('L=="dx_0^2+dy_0^2=1");
                        hideL('L=="r_0!=0");
                        hideL('L=="abs(y_0-ly())+v_0^2/(2*b()) < lw()");
                        hideL('L=="dx^2+dy^2=1");
                        edit("abs(y_0-ly())+v_0^2/(2*b())+(A()/b()+1)*(A()/2*c^2+c*v_0) < lw()", -6) using "A()>0 :: b()>0 :: ep()>0 :: abs(y_0-ly())+v_0^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v_0) < lw() :: v_0>=0 :: c>=0 :: c<=ep() :: nil";
                        QE using "A()>0 :: b()>0 :: abs(y_0-ly())+v_0^2/(2*b())+(A()/b()+1)*(A()/2*c^2+c*v_0) < lw() :: v_0>=0 :: a<=A() :: v=v_0+a*c :: -c*(v-a/2*c)<=y-y_0 :: y-y_0<=c*(v-a/2*c) :: c>=0 :: v>=0 :: abs(y-ly())+v^2/(2*b()) < lw() :: nil",
                      "[?v=0;a:=0;w:=0;][c:=0;]\forall v_0 (v_0=v->\forall y_0 (y_0=y->[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1)&v=v_0+a*c)&-c*(v-a/2*c)<=y-y_0&y-y_0<=c*(v-a/2*c)}](r!=0&abs(y-ly())+v^2/(2*b()) < lw())))":
                        dWplus('R=="[{x'=v*dx,y'=v*dy,v'=0,dx'=-dy*w,dy'=dx*w,w'=0/r,c'=1&((((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1)&v=v_0+0*c)&-c*(v-0/2*c)<=y-y_0&y-y_0<=c*(v-0/2*c)}](r!=0&abs(y-ly())+v^2/(2*b()) < lw())");
                        simplify(1) using "r!=0 :: r!=0&abs(y-ly())+v^2/(2*b()) < lw() :: nil";
                        unfold;
                        allL2R('L=="v_0=0");
                        simplify('L=="v=#0+0*c#");
                        allL2R('L=="v=0");
                        cut("y=y_0"); <(
                          "Use":
                            allL2R('L=="y=y_0");
                            id,
                          "Show":
                            QE using "-c*(0-0/2*c)<=y-y_0 :: y-y_0<=c*(0-0/2*c) :: y=y_0 :: nil"
                        ),
                      "[a:=*;?-B()<=a&a<=-b();][c:=0;]\forall v_0 (v_0=v->\forall y_0 (y_0=y->[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1)&v=v_0+a*c)&-c*(v-a/2*c)<=y-y_0&y-y_0<=c*(v-a/2*c)}](r!=0&abs(y-ly())+v^2/(2*b()) < lw())))":
                        dWplus('R=="[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1)&v=v_0+a*c)&-c*(v-a/2*c)<=y-y_0&y-y_0<=c*(v-a/2*c)}](r!=0&abs(y-ly())+v^2/(2*b()) < lw())");
                        simplify(1) using "r!=0 :: r!=0&abs(y-ly())+v^2/(2*b()) < lw() :: nil";
                        unfold;
                        QE using "b()>0 :: lw()>0 :: v_0>=0 :: a<=-b() :: abs(y_0-ly())+v_0^2/(2*b()) < lw() :: v=v_0+a*c :: -c*(v-a/2*c)<=y-y_0 :: y-y_0<=c*(v-a/2*c) :: c>=0 :: v>=0 :: abs(y-ly())+v^2/(2*b()) < lw() :: nil"
                    ),
                  "Show":
                    unfold; <(
                      "[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;][c:=0;]\forall v_0 (v_0=v->\forall y_0 (y_0=y->[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&(((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1)&v=v_0+a*c}](-c*(v-a/2*c)<=y-y_0&y-y_0<=c*(v-a/2*c))))":
                        dIClose(1) using "v_0=v :: y_0=y :: [{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&(((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1)&v=v_0+a*c}](-c*(v-a/2*c)<=y-y_0&y-y_0<=c*(v-a/2*c)) :: nil",
                      "[?v=0;a:=0;w:=0;][c:=0;]\forall v_0 (v_0=v->\forall y_0 (y_0=y->[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&(((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1)&v=v_0+a*c}](-c*(v-a/2*c)<=y-y_0&y-y_0<=c*(v-a/2*c))))":
                        dIClose(1) using "v_0=v :: y_0=y :: [{x'=v*dx,y'=v*dy,v'=0,dx'=-dy*w,dy'=dx*w,w'=0/r,c'=1&(((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1)&v=v_0+0*c}](-c*(v-0/2*c)<=y-y_0&y-y_0<=c*(v-0/2*c)) :: nil",
                      "[a:=*;?-B()<=a&a<=-b();][c:=0;]\forall v_0 (v_0=v->\forall y_0 (y_0=y->[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&(((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1)&v=v_0+a*c}](-c*(v-a/2*c)<=y-y_0&y-y_0<=c*(v-a/2*c))))":
                        dIClose(1) using "v_0=v :: y_0=y :: v>=0 :: [{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&(((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1)&v=v_0+a*c}](-c*(v-a/2*c)<=y-y_0&y-y_0<=c*(v-a/2*c)) :: nil"
                    )
                ),
              "Show":
                unfold; <(
                  "[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;][c:=0;]\forall v_0 (v_0=v->[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1}]v=v_0+a*c)":
                    dIClose(1) using "c=0 :: v_0=v :: [{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1}]v=v_0+a*c :: nil",
                  "[?v=0;a:=0;w:=0;][c:=0;]\forall v_0 (v_0=v->[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1}]v=v_0+a*c)":
                    dIClose(1) using "v_0=v :: [{x'=v*dx,y'=v*dy,v'=0,dx'=-dy*w,dy'=dx*w,w'=0/r,c'=1&((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1}]v=v_0+0*c :: nil",
                  "[a:=*;?-B()<=a&a<=-b();][c:=0;]\forall v_0 (v_0=v->[{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1}]v=v_0+a*c)":
                    dIClose(1) using "c=0 :: v_0=v :: [{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&((v>=0&c<=ep())&c>=0)&dx^2+dy^2=1}]v=v_0+a*c :: nil"
                )
            ),
          "Show":
            unfold; <(
              "[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;][c:=0;][{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&(v>=0&c<=ep())&c>=0}]dx^2+dy^2=1":
                dIClose(1) using "dx^2+dy^2=1 :: [{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&(v>=0&c<=ep())&c>=0}]dx^2+dy^2=1 :: nil",
              "[?v=0;a:=0;w:=0;][c:=0;][{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&(v>=0&c<=ep())&c>=0}]dx^2+dy^2=1":
                dIClose(1) using "dx^2+dy^2=1 :: [{x'=v*dx,y'=v*dy,v'=0,dx'=-dy*w,dy'=dx*w,w'=0/r,c'=1&(v>=0&c<=ep())&c>=0}]dx^2+dy^2=1 :: nil",
              "[a:=*;?-B()<=a&a<=-b();][c:=0;][{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&(v>=0&c<=ep())&c>=0}]dx^2+dy^2=1":
                dIClose(1) using "dx^2+dy^2=1 :: [{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&(v>=0&c<=ep())&c>=0}]dx^2+dy^2=1 :: nil"
            )
        ),
      "Show":
        unfold; <(
          "[?abs(y-ly())+v^2/(2*b())+(A()/b()+1)*(A()/2*ep()^2+ep()*v) < lw();a:=*;?-B()<=a&a<=A();w:=*;r:=*;?r!=0&w*r=v;][c:=0;][{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}]c>=0":
            dIClose(1) using "c=0 :: [{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}]c>=0 :: nil",
          "[?v=0;a:=0;w:=0;][c:=0;][{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}]c>=0":
            dIClose(1) using "c=0 :: [{x'=v*dx,y'=v*dy,v'=0,dx'=-dy*w,dy'=dx*w,w'=0/r,c'=1&v>=0&c<=ep()}]c>=0 :: nil",
          "[a:=*;?-B()<=a&a<=-b();][c:=0;][{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}]c>=0":
            dIClose(1) using "c=0 :: [{x'=v*dx,y'=v*dy,v'=a,dx'=-dy*w,dy'=dx*w,w'=a/r,c'=1&v>=0&c<=ep()}]c>=0 :: nil"
        )
    )
)
End.

End.

ArchiveEntry "Benchmarks/Basic/LICS: Example 1 Continuous car accelerates forward"

Citation "André Platzer. Logics of dynamical systems. ACM/IEEE Symposium on Logic in Computer Science, LICS 2012, June 25-28, 2012, Dubrovnik, Croatia, pp. 13-24. IEEE 2012.".
Link "http://symbolaris.com/pub/lds-lics.pdf#page=4".

ProgramVariables /* program variables may change their value over time */
  Real x;            /* position of the car */
  Real v;            /* velocity of the car */
  Real a;            /* acceleration of the car */
End.

Problem          /* differential dynamic logic formula */
    v>=0 & a>=0
 -> [
      {x'=v, v'=a & v>=0}
    ] v>=0
End.

Tactic "Scripted proof"
DW('R=="v>=0&a>=0->#[{x'=v,v'=a&v>=0}]v>=0#");
simplify('R=="v>=0&a>=0->[{x'=v,v'=a&v>=0}](v>=0->v>=0)");
GV('R=="v>=0&a>=0->#[{x'=v,v'=a&v>=0}]true#");
implyTrue('R=="v>=0&a>=0->true");
closeT
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/LICS: Example 2 Single car drives forward"

Citation "André Platzer. Logics of dynamical systems. ACM/IEEE Symposium on Logic in Computer Science, LICS 2012, June 25-28, 2012, Dubrovnik, Croatia, pp. 13-24. IEEE 2012.".
Link "http://symbolaris.com/pub/lds-lics.pdf#page=5".

Definitions        /* function symbols cannot change their value */
  Real b();          /* braking capabilities */
  Real A();          /* maximum acceleration */
End.

ProgramVariables /* program variables may change their value over time */
  Real x;            /* position of the car */
  Real v;            /* velocity of the car */
  Real a;            /* acceleration of the car */
End.

Problem          /* differential dynamic logic formula */
    v>=0  & A>=0 & b>0
 -> [
      {
        {a:=A; ++ a:=-b;}
        {x'=v, v'=a & v>=0}
      }*@invariant(v>=0)
    ] v>=0
End.

Tactic "Scripted proof"
implyR('R=="v>=0&A()>=0&b()>0->[{{a:=A();++a:=-b();}{x'=v,v'=a&v>=0}}*]v>=0");
loop("v>=0", 'R=="[{{a:=A();++a:=-b();}{x'=v,v'=a&v>=0}}*]v>=0"); <(
  "Init":
    id,
  "Post":
    id,
  "Step":
    composeb('R=="[{a:=A();++a:=-b();}{x'=v,v'=a&v>=0}]v>=0");
    DW('R=="[a:=A();++a:=-b();]#[{x'=v,v'=a&v>=0}]v>=0#");
    simplify('R=="[a:=A();++a:=-b();][{x'=v,v'=a&v>=0}](v>=0->v>=0)");
    GV('R=="[a:=A();++a:=-b();]#[{x'=v,v'=a&v>=0}]true#");
    GV('R=="[a:=A();++a:=-b();]true");
    closeT
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/LICS: Example 3a event-triggered car drives forward"

Citation "André Platzer. Logics of dynamical systems. ACM/IEEE Symposium on Logic in Computer Science, LICS 2012, June 25-28, 2012, Dubrovnik, Croatia, pp. 13-24. IEEE 2012.".
Link "http://symbolaris.com/pub/lds-lics.pdf#page=7".

ProgramVariables
	Real x;  /* x position of car */
	Real v;  /* v velocity of car */
	Real a;  /* a acceleration of car */
	Real b;  /* A max acceleration */
	Real A;  /* b max braking */
	Real m;  /* m position of Stop Sign */
End.

Problem
   ( v >= 0
	 & A >= 0
	 & b > 0 )
->
  [
    {
      {  ?(m-x>=2); a := A;
      ++ a := -b;
      };
      {x' = v, v' = a & v >= 0}
    }*@invariant(v >= 0)
  ]v >= 0
End.

Tactic "Scripted proof"
implyR('R=="v>=0&A>=0&b>0->[{{?m-x>=2;a:=A;++a:=-b;}{x'=v,v'=a&v>=0}}*]v>=0");
loop("v>=0", 'R=="[{{?m-x>=2;a:=A;++a:=-b;}{x'=v,v'=a&v>=0}}*]v>=0"); <(
  "Init":
    id,
  "Post":
    id,
  "Step":
    composeb('R=="[{?m-x>=2;a:=A;++a:=-b;}{x'=v,v'=a&v>=0}]v>=0");
    DW('R=="[?m-x>=2;a:=A;++a:=-b;]#[{x'=v,v'=a&v>=0}]v>=0#");
    simplify('R=="[?m-x>=2;a:=A;++a:=-b;][{x'=v,v'=a&v>=0}](v>=0->v>=0)");
    GV('R=="[?m-x>=2;a:=A;++a:=-b;]#[{x'=v,v'=a&v>=0}]true#");
    GV('R=="[?m-x>=2;a:=A;++a:=-b;]true");
    closeT
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/LICS: Example 4a safe stopping of time-triggered car"

Definitions        /* function symbols cannot change their value */
  Real b();          /* braking capabilities */
  Real A();          /* maximum acceleration */
  Real ep();         /* reaction time */
End.

ProgramVariables /* program variables may change their value over time */
  Real x;            /* position of the car */
  Real v;            /* velocity of the car */
  Real a;            /* acceleration of the car */
  Real m;            /* stop sign position */
  Real t;            /* clock variable */
End.

Problem          /* differential dynamic logic formula */
    v^2<=2*b*(m-x) & v>=0  & A>=0 & b>0
 -> [
      {
        {?(2*b*(m-x) >= v^2+(A+b)*(A*ep^2+2*ep*v)); a:=A; ++ a:=-b; }
        t := 0;
        {x'=v, v'=a, t'=1 & v>=0 & t<=ep}
      }*@invariant(v^2<=2*b*(m-x))
    ] x <= m
End.

Tactic "Scripted proof"
  implyR(1) ; loop("v^2<=2*b()*(m-x)", 1) ; <(
    id,
    QE,
    composeb(1) ; composeb(1.1) ; solve(1.1.1) ; unfold ; doall(QE)
  )
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/LICS: Example 4b progress of time-triggered car"

Definitions      /* function symbols cannot change their value */
  Real b();          /* braking capabilities */
  Real A();          /* maximum acceleration */
  Real ep();         /* reaction time */
End.

ProgramVariables /* program variables may change their value over time */
  Real x;            /* position of the car */
  Real v;            /* velocity of the car */
  Real a;            /* acceleration of the car */
  Real t;            /* clock variable */
End.

Problem
  ep() > 0 & A() > 0 & b() > 0 & v>=0
->
  \forall p \exists m
  <
    {
        {?(2*b()*(m-x) >= v^2+(A()+b())*(A()*ep()^2+2*ep()*v)); a:=A(); ++ a:=-b(); }
        t := 0;
        {x'=v, v'=a, t'=1 & v>=0 & t<=ep()}
    }*
  > (x >= p)
End.

End.

ArchiveEntry "Benchmarks/Basic/LICS: Example 4c relative safety of time-triggered car"

Definitions      /* function symbols cannot change their value */
  Real b();          /* braking capabilities */
  Real A();          /* maximum acceleration */
  Real ep();         /* reaction time */
  Real m();          /* stop sign position */
End.

ProgramVariables /* program variables may change their value over time */
  Real x;            /* position of the car */
  Real v;            /* velocity of the car */
  Real a;            /* acceleration of the car */
  Real t;            /* clock variable */
End.

Problem
   ( [{x' = v, v' = -b()}]x<=m()
   & v >= 0
	 & A() >= 0
	 & b() > 0 )
->
  [
    {
      {  ?(2*b()*(m()-x) >= v^2 + (A() + b())*(A()*ep()^2 + 2*ep()*v)); a := A();
      ++ a := -b();
      };
      t := 0;
      {x' = v, v' = a, t' = 1 & v >= 0 & t <= ep()}
    }*@invariant(v^2<=2*b()*(m()-x))
  ]x<=m()
End.

Tactic "Scripted proof"
implyR('R=="[{x'=v,v'=-b()}]x<=m()&v>=0&A()>=0&b()>0->[{{?2*b()*(m()-x)>=v^2+(A()+b())*(A()*ep()^2+2*ep()*v);a:=A();++a:=-b();}t:=0;{x'=v,v'=a,t'=1&v>=0&t<=ep()}}*]x<=m()");
loop("v^2<=2*b()*(m()-x)", 'R=="[{{?2*b()*(m()-x)>=v^2+(A()+b())*(A()*ep()^2+2*ep()*v);a:=A();++a:=-b();}t:=0;{x'=v,v'=a,t'=1&v>=0&t<=ep()}}*]x<=m()"); <(
  "Init":
    solve('L=="[{x'=v,v'=-b()}]x<=m()");
    QE,
  "Post":
    QE,
  "Step":
    composeb('R=="[{?2*b()*(m()-x)>=v^2+(A()+b())*(A()*ep()^2+2*ep()*v);a:=A();++a:=-b();}t:=0;{x'=v,v'=a,t'=1&v>=0&t<=ep()}]v^2<=2*b()*(m()-x)");
    composeb('R=="[?2*b()*(m()-x)>=v^2+(A()+b())*(A()*ep()^2+2*ep()*v);a:=A();++a:=-b();]#[t:=0;{x'=v,v'=a,t'=1&v>=0&t<=ep()}]v^2<=2*b()*(m()-x)#");
    solve('R=="[?2*b()*(m()-x)>=v^2+(A()+b())*(A()*ep()^2+2*ep()*v);a:=A();++a:=-b();][t:=0;]#[{x'=v,v'=a,t'=1&v>=0&t<=ep()}]v^2<=2*b()*(m()-x)#");
    unfold; <(
      "[?2*b()*(m()-x)>=v^2+(A()+b())*(A()*ep()^2+2*ep()*v);a:=A();][t:=0;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->a*s_+v>=0&s_+t<=ep())->(a*t_+v)^2<=2*b()*(m()-(a*(t_^2/2)+v*t_+x)))":
        QE,
      "[a:=-b();][t:=0;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->a*s_+v>=0&s_+t<=ep())->(a*t_+v)^2<=2*b()*(m()-(a*(t_^2/2)+v*t_+x)))":
        QE
    )
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/LICS: Example 5 Controllability Equivalence"

Definitions
  Real b;
  Real m;
End.

ProgramVariables
	Real v;
	Real x;
End.

Problem
  v>=0 & b>0 -> ( v^2<=2*b*(m-x) <-> [{x'=v, v'=-b}]x<=m )
End.

Tactic "Scripted proof"
implyR('R=="v>=0&b()>0->(v^2<=2*b()*(m()-x)<->[{x'=v,v'=-b()}]x<=m())");
equivR('R=="v^2<=2*b()*(m()-x)<->[{x'=v,v'=-b()}]x<=m()"); <(
  "v^2<=2*b()*(m()-x)&[{x'=v,v'=-b()}]x<=m()":
    solve('R=="[{x'=v,v'=-b()}]x<=m()");
    QE,
  "!v^2<=2*b()*(m()-x)&![{x'=v,v'=-b()}]x<=m()":
    solve('L=="[{x'=v,v'=-b()}]x<=m()");
    QE
)
End.

Tactic "Automated proof"
  auto
End.

End.

ArchiveEntry "Benchmarks/Basic/LICS: Example 6 MPC Acceleration Equivalence"

Definitions
  Real b;
  Real A;
  Real m;
  Real ep;
End.

ProgramVariables
	Real v;
	Real x;
	Real t;
End.

Problem
  v>=0 & b>0 & A>=0 & ep>=0 -> (
    [t:=0; {x'=v, v'=A, t'=1 & t<=ep}][{x'=v, v'=-b}]x<=m
    <->
    2*b*(m-x) >= v^2 + (A + b)*(A*ep^2 + 2*ep*v)
   )
End.

Tactic "Scripted proof"
useSolver("Mathematica");
implyR('R=="v>=0&b()>0&A()>=0&ep()>=0->([t:=0;{x'=v,v'=A(),t'=1&t<=ep()}][{x'=v,v'=-b()}]x<=m()<->2*b()*(m()-x)>=v^2+(A()+b())*(A()*ep()^2+2*ep()*v))");
equivR('R=="[t:=0;{x'=v,v'=A(),t'=1&t<=ep()}][{x'=v,v'=-b()}]x<=m()<->2*b()*(m()-x)>=v^2+(A()+b())*(A()*ep()^2+2*ep()*v)"); <(
  "[t:=0;{x'=v,v'=A(),t'=1&t<=ep()}][{x'=v,v'=-b()}]x<=m()&2*b()*(m()-x)>=v^2+(A()+b())*(A()*ep()^2+2*ep()*v)":
    composeb('L=="[t:=0;{x'=v,v'=A(),t'=1&t<=ep()}][{x'=v,v'=-b()}]x<=m()");
    solve('L=="[t:=0;][{x'=v,v'=A(),t'=1&t<=ep()}]#[{x'=v,v'=-b()}]x<=m()#");
    solve('L=="[t:=0;]#[{x'=v,v'=A(),t'=1&t<=ep()}]\forall t_ (t_>=0->(-b())*(t_^2/2)+v*t_+x<=m())#");
    assignb('L=="[t:=0;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->s_+t<=ep())->\exists kyxtime (kyxtime=t_&kyxtime+t<=ep()&\forall t_ (t_>=0->(-b())*(t_^2/2)+(A()*kyxtime+v)*t_+(A()*(kyxtime^2/2)+v*kyxtime+x)<=m())))");
    QE,
  "![t:=0;{x'=v,v'=A(),t'=1&t<=ep()}][{x'=v,v'=-b()}]x<=m()&!2*b()*(m()-x)>=v^2+(A()+b())*(A()*ep()^2+2*ep()*v)":
    composeb('R=="[t:=0;{x'=v,v'=A(),t'=1&t<=ep()}][{x'=v,v'=-b()}]x<=m()");
    assignb('R=="[t:=0;][{x'=v,v'=A(),t'=1&t<=ep()}][{x'=v,v'=-b()}]x<=m()");
    solve('R=="[{x'=v,v'=A(),t'=1&t<=ep()}]#[{x'=v,v'=-b()}]x<=m()#");
    solve('R=="[{x'=v,v'=A(),t'=1&t<=ep()}]\forall t_ (t_>=0->(-b())*(t_^2/2)+v*t_+x<=m())");
    allR('R=="\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->s_+t<=ep())->\forall kyxtime (kyxtime=t_->\forall t_ (t_>=0->(-b())*(t_^2/2)+(A()*kyxtime+v)*t_+(A()*(kyxtime^2/2)+v*kyxtime+x)<=m())))");
    implyR('R=="t_>=0->\forall s_ (0<=s_&s_<=t_->s_+t<=ep())->\forall kyxtime (kyxtime=t_->\forall t_ (t_>=0->(-b())*(t_^2/2)+(A()*kyxtime+v)*t_+(A()*(kyxtime^2/2)+v*kyxtime+x)<=m()))");
    implyR('R=="\forall s_ (0<=s_&s_<=t_->s_+t<=ep())->\forall kyxtime (kyxtime=t_->\forall t_ (t_>=0->(-b())*(t_^2/2)+(A()*kyxtime+v)*t_+(A()*(kyxtime^2/2)+v*kyxtime+x)<=m()))");
    allR('R=="\forall kyxtime (kyxtime=t_->\forall t_ (t_>=0->(-b())*(t_^2/2)+(A()*kyxtime+v)*t_+(A()*(kyxtime^2/2)+v*kyxtime+x)<=m()))");
    implyR('R=="kyxtime=t_->\forall t_ (t_>=0->(-b())*(t_^2/2)+(A()*kyxtime+v)*t_+(A()*(kyxtime^2/2)+v*kyxtime+x)<=m())");
    allR('R=="\forall t_ (t_>=0->(-b())*(t_^2/2)+(A()*kyxtime+v)*t_+(A()*(kyxtime^2/2)+v*kyxtime+x)<=m())");
    implyR('R=="t_>=0->(-b())*(t_^2/2)+(A()*kyxtime+v)*t_+(A()*(kyxtime^2/2)+v*kyxtime+x)<=m()");
    allL("t__0", 'L=="\forall s_ (0<=s_&s_<=t__0->s_+t<=ep())");
    implyL('L=="0<=t__0&t__0<=t__0->t__0+t<=ep()"); <(
      "0<=t__0&t__0<=t__0":
        hideR('R=="(-b())*(t_^2/2)+(A()*kyxtime+v)*t_+(A()*(kyxtime^2/2)+v*kyxtime+x)<=m()");
        QE,
      "t__0+t<=ep()":
        QE
    )
)
End.

Tactic "Scripted proof (2)"
implyR('R=="v>=0&b()>0&A()>=0&ep()>=0->([t:=0;{x'=v,v'=A(),t'=1&t<=ep()}][{x'=v,v'=-b()}]x<=m()<->2*b()*(m()-x)>=v^2+(A()+b())*(A()*ep()^2+2*ep()*v))");
equivR('R=="[t:=0;{x'=v,v'=A(),t'=1&t<=ep()}][{x'=v,v'=-b()}]x<=m()<->2*b()*(m()-x)>=v^2+(A()+b())*(A()*ep()^2+2*ep()*v)"); <(
  "[t:=0;{x'=v,v'=A(),t'=1&t<=ep()}][{x'=v,v'=-b()}]x<=m()&2*b()*(m()-x)>=v^2+(A()+b())*(A()*ep()^2+2*ep()*v)":
    chaseAt('L=="[t:=0;{x'=v,v'=A(),t'=1&t<=ep()}][{x'=v,v'=-b()}]x<=m()");
    solve('L=="\forall t (t=0->#[{x'=v,v'=A(),t'=1&t<=ep()}][{x'=v,v'=-b()}]x<=m()#)");
    solve('L=="\forall t (t=0->\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->s_+t<=ep())->t_+t<=ep()&\exists v (v=A()*t_+v_1&\exists x (x=A()*(t_^2/2)+v_1*t_+x_1&#[{x'=v,v'=-b()}]x<=m()#))))");
    QE,
  "![t:=0;{x'=v,v'=A(),t'=1&t<=ep()}][{x'=v,v'=-b()}]x<=m()&!2*b()*(m()-x)>=v^2+(A()+b())*(A()*ep()^2+2*ep()*v)":
    unfold;
    solve('R=="[{x'=v,v'=A(),t'=1&t<=ep()}][{x'=v,v'=-b()}]x<=m()");
    solve('R=="\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->s_+t<=ep())->\forall v (v=A()*t_+v_1->\forall x (x=A()*(t_^2/2)+v_1*t_+x_1->#[{x'=v,v'=-b()}]x<=m()#)))");
    QE
)
End.

End.

ArchiveEntry "Benchmarks/Basic/LICS: Example 7 Model-Predictive Control Design Car"

Definitions      /* function symbols cannot change their value */
  Real b();          /* braking capabilities */
  Real A();          /* maximum acceleration */
  Real ep();         /* reaction time */
End.

ProgramVariables /* program variables may change their value over time */
  Real x;            /* position of the car */
  Real v;            /* velocity of the car */
  Real a;            /* acceleration of the car */
  Real m;            /* stop sign position */
  Real t;            /* clock variable */
End.

Problem          /* differential dynamic logic formula */
  [{x'=v, v'=-b}](x<=m)
   & v >= 0
   & A >= 0
   & b > 0
->
  [
    {
    {{?([t:=0; {x'=v, v'=A, t'=1 & v >= 0 & t<=ep}] [{x'=v, v'=-b}](x<=m));
       a := A;}
    ++ a := -b;}
      t := 0;
      {x'=v, v'=a, t'=1 & v>=0 & t<=ep}
    }*@invariant([{x'=v, v'=-b}](x<=m))
  ] (x <= m)
End.

Tactic "Scripted proof"
implyR('R=="[{x'=v,v'=-b()}]x<=m&v>=0&A()>=0&b()>0->[{{?[t:=0;{x'=v,v'=A(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m;a:=A();++a:=-b();}t:=0;{x'=v,v'=a,t'=1&v>=0&t<=ep()}}*]x<=m");
loop("[{x'=v,v'=-b()}]x<=m", 'R=="[{{?[t:=0;{x'=v,v'=A(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m;a:=A();++a:=-b();}t:=0;{x'=v,v'=a,t'=1&v>=0&t<=ep()}}*]x<=m"); <(
  "Init":
    id,
  "Post":
    solve('L=="[{x'=v,v'=-b()}]x<=m");
    QE,
  "Step":
    composeb('R=="[{?[t:=0;{x'=v,v'=A(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m;a:=A();++a:=-b();}t:=0;{x'=v,v'=a,t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m");
    choiceb('R=="[?[t:=0;{x'=v,v'=A(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m;a:=A();++a:=-b();][t:=0;{x'=v,v'=a,t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m");
    andR('R=="[?[t:=0;{x'=v,v'=A(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m;a:=A();][t:=0;{x'=v,v'=a,t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m&[a:=-b();][t:=0;{x'=v,v'=a,t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m"); <(
      "[?[t:=0;{x'=v,v'=A(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m;a:=A();][t:=0;{x'=v,v'=a,t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m":
        composeb('R=="[?[t:=0;{x'=v,v'=A(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m;a:=A();][t:=0;{x'=v,v'=a,t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m");
        assignb('R=="[?[t:=0;{x'=v,v'=A(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m;]#[a:=A();][t:=0;{x'=v,v'=a,t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m#");
        testb('R=="[?[t:=0;{x'=v,v'=A(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m;][t:=0;{x'=v,v'=A(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m");
        implyR('R=="[t:=0;{x'=v,v'=A(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m->[t:=0;{x'=v,v'=A(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m");
        composeb('R=="[t:=0;{x'=v,v'=A(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m");
        assignb('R=="[t:=0;][{x'=v,v'=A(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m");
        composeb('L=="[t_0:=0;{x'=v,v'=A(),t_0'=1&v>=0&t_0<=ep()}][{x'=v,v'=-b()}]x<=m");
        assignb('L=="[t_0:=0;][{x'=v,v'=A(),t_0'=1&v>=0&t_0<=ep()}][{x'=v,v'=-b()}]x<=m");
        alphaRenAll("t_0", "t"); <(
          "Use":
            id,
          "Show":
            QE using "t=0 :: t_0=0 :: t_0=t :: nil"
        ),
      "[a:=-b();][t:=0;{x'=v,v'=a,t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m":
        assignb('R=="[a:=-b();][t:=0;{x'=v,v'=a,t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m");
        composeb('R=="[t:=0;{x'=v,v'=-b(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m");
        assignb('R=="[t:=0;][{x'=v,v'=-b(),t'=1&v>=0&t<=ep()}][{x'=v,v'=-b()}]x<=m");
        cut("[{x'=v,v'=-b(),t'=1}][{x'=v,v'=-b()}]x<=m"); <(
          "Use":
            cut("[{x'=v,v'=-b(),t'=1&v>=0&t<=ep()}](v>=0&t<=ep()->true)"); <(
              "Use":
                implyRi(-5, 1);
                implyRi(-5, 1);
                hideL('L=="[{x'=v,v'=-b()}]x<=m");
                hideL('L=="A()>=0");
                hideL('L=="b()>0");
                hideL('L=="t=0");
                byUS("DMP differential modus ponens"),
              "Show":
                implyTrue('R=="[{x'=v,v'=-b(),t'=1&v>=0&t<=ep()}]#(v>=0&t<=ep()->true)#");
                boxTrue('R=="[{x'=v,v'=-b(),t'=1&v>=0&t<=ep()}]true")
            ),
          "Show":
            useAt(", commute", "0", 'R=="[{x'=v,v'=-b(),t'=1}][{x'=v,v'=-b()}]x<=m");
            useAt(", commute", "0", 'R=="[{v'=-b(),t'=1,x'=v}][{x'=v,v'=-b()}]x<=m");
            dGi('R=="[{t'=1,x'=v,v'=-b()}][{x'=v,v'=-b()}]x<=m");
            useAt("D[;] differential self compose", "1", 'R=="[{x'=v,v'=-b()}][{x'=v,v'=-b()}]x<=m");
            id
        )
    )
)
End.

End.

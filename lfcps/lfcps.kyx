ArchiveEntry "05: Short Bouncing Ball: single hop"
Description "5.4: A Proof of a Short Bouncing Ball single-hop without loop".

Definitions      /* function symbols cannot change their value */
  Real H;        /* initial height */
  Real g;        /* gravity */
  Real c;        /* damping coefficient */
End.

ProgramVariables /* program variables may change their value over time */
  Real x, v;     /* height and velocity */
End.

Problem
  x>=0 & x=H
  & v=0 & g>0 & 1>=c&c>=0
 ->
  [
      {x'=v,v'=-g}
      {?x=0; v:=-c*v;  ++  ?x>=0;}
  ] (x>=0 & x<=H)
End.

Tactic "05: Short Bouncing Ball: single hop: Proof named"
    implyR('R=="x>=0&x=H()&v=0&g()>0&1>=c()&c()>=0->[{x'=v,v'=-g()}{?x=0;v:=-c()*v;++?x>=0;}](x>=0&x<=H())");
    composeb('R=="[{x'=v,v'=-g()}{?x=0;v:=-c()*v;++?x>=0;}](x>=0&x<=H())");
    choiceb('R=="[{x'=v,v'=-g()}]#[?x=0;v:=-c()*v;++?x>=0;](x>=0&x<=H())#");
    composeb('R=="[{x'=v,v'=-g()}](#[?x=0;v:=-c()*v;](x>=0&x<=H())#&[?x>=0;](x>=0&x<=H()))");
    testb('R=="[{x'=v,v'=-g()}](#[?x=0;][v:=-c()*v;](x>=0&x<=H())#&[?x>=0;](x>=0&x<=H()))");
    testb('R=="[{x'=v,v'=-g()}]((x=0->[v:=-c()*v;](x>=0&x<=H()))&#[?x>=0;](x>=0&x<=H())#)");
    assignb('R=="[{x'=v,v'=-g()}]((x=0->#[v:=-c()*v;](x>=0&x<=H())#)&(x>=0->x>=0&x<=H()))");
    solve('R=="[{x'=v,v'=-g()}]((x=0->x>=0&x<=H())&(x>=0->x>=0&x<=H()))");
    QE
End.

Tactic "05: Short Bouncing Ball: single hop: Proof positionally"
  implyR(1) ; composeb(1) ; choiceb(1.1) ; composeb(1.1.0) ; testb(1.1.0) ; testb(1.1.1) ; assignb(1.1.0.1) ; solve(1) ; QE
End.

Tactic "05: Short Bouncing Ball: single hop: Proof auto"
  auto
End.

Illustration "https://lfcps.org/info/fig-bouncing-ball-dark1ghost.png".
End.
ArchiveEntry "07: Bouncing Ball"
Description "7.4: Acrophobic Bouncing Ball".

Definitions      /* function symbols cannot change their value */
  Real H;        /* initial height */
  Real g;        /* gravity */
  Real c;        /* damping coefficient */
End.

ProgramVariables /* program variables may change their value over time */
  Real x, v;     /* height and vertical velocity */
End.

Problem
  (x>=0 & x=H & v=0) &
  (g>0 & 1=c&c>=0)
 ->
  [
    {
      {x'=v,v'=-g&x>=0}
      {?x=0; v:=-c*v;  ++  ?x!=0;}
    }* @invariant(2*g*x=2*g*H-v^2 & x>=0)
  ] (x>=0 & x<=H)
End.

Tactic "07: Bouncing Ball: generalizing as in book: positional"
  implyR(1) ; loop("2*g*x=2*g*H-v^2&x>=0", 1) ; <(
  "Init": QE, 
  "Post": QE, 
  "Step": composeb(1) ; MR("2*g*x=2*g*H-v^2&x>=0&c=1&g>0", 1) ; <(
    "Use Q->P": solve(1) ; QE, 
    "Show [a]Q": choiceb(1) ; andR(1) ; <(
      composeb(1) ; testb(1) ; implyR(1) ; assignb(1) ; QE, 
        testb(1) ; prop
      )
    )
)
End.
       
Tactic "07: Bouncing Ball: generalizing as in book: named"
  implyR('R=="(x>=0&x=H()&v=0)&g()>0&1=c()&c()>=0->[{{x'=v,v'=-g()&x>=0}{?x=0;v:=-c()*v;++?x!=0;}}*](x>=0&x<=H())");
  loop("2*g()*x=2*g()*H()-v^2&x>=0", 'R=="[{{x'=v,v'=-g()&x>=0}{?x=0;v:=-c()*v;++?x!=0;}}*](x>=0&x<=H())"); <(
    "Init":
      QE,
    "Post":
      QE,
    "Step":
      composeb('R=="[{x'=v,v'=-g()&x>=0}{?x=0;v:=-c()*v;++?x!=0;}](2*g()*x=2*g()*H()-v^2&x>=0)");
      MR("2*g()*x=2*g()*H()-v^2&x>=0&c()=1&g()>0", 'R=="[{x'=v,v'=-g()&x>=0}][?x=0;v:=-c()*v;++?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0)"); <(
        "Use Q->P":
          solve('R=="[{x'=v,v'=-g()&x>=0}](2*g()*x=2*g()*H()-v^2&x>=0&c()=1&g()>0)");
          QE,
        "Show [a]Q":
          choiceb('R=="[?x=0;v:=-c()*v;++?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0)");
          andR('R=="[?x=0;v:=-c()*v;](2*g()*x=2*g()*H()-v^2&x>=0)&[?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0)"); <(
            "[?x=0;v:=-c()*v;](2*g()*x=2*g()*H()-v^2&x>=0)":
              composeb('R=="[?x=0;v:=-c()*v;](2*g()*x=2*g()*H()-v^2&x>=0)");
              testb('R=="[?x=0;][v:=-c()*v;](2*g()*x=2*g()*H()-v^2&x>=0)");
              implyR('R=="x=0->[v:=-c()*v;](2*g()*x=2*g()*H()-v^2&x>=0)");
              assignb('R=="[v:=-c()*v;](2*g()*x=2*g()*H()-v^2&x>=0)");
              QE,
            "[?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0)":
              testb('R=="[?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0)");
              propClose
          )
      )
  )
End.

Tactic "07: Bouncing Ball: top-level: positional"
  implyR(1) ; loop("2*g*x=2*g*H-v^2&x>=0", 1) ; <(
  "Init": QE, 
  "Post": QE, 
  "Step": composeb(1) ; solve(1) ; allR(1) ; implyR(1) ; implyR(1) ; allL("t_", -6) ; allR(1) ; implyR(1) ; choiceb(1) ; andR(1) ; <(
    composeb(1) ; testb(1) ; implyR(1) ; assignb(1) ; QE, 
    testb(1) ; implyR(1) ; QE
)
)
End.

Tactic "07: Bouncing Ball: top-level: named"
implyR('R=="(x>=0&x=H()&v=0)&g()>0&1=c()&c()>=0->[{{x'=v,v'=-g()&x>=0}{?x=0;v:=-c()*v;++?x!=0;}}*](x>=0&x<=H())");
loop("2*g()*x=2*g()*H()-v^2&x>=0", 'R=="[{{x'=v,v'=-g()&x>=0}{?x=0;v:=-c()*v;++?x!=0;}}*](x>=0&x<=H())"); <(
  "Init":
    QE,
  "Post":
    QE,
  "Step":
    composeb('R=="[{x'=v,v'=-g()&x>=0}{?x=0;v:=-c()*v;++?x!=0;}](2*g()*x=2*g()*H()-v^2&x>=0)");
    solve('R=="[{x'=v,v'=-g()&x>=0}][?x=0;v:=-c()*v;++?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0)");
    allR('R=="\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v_1*s_+x>=0)->\forall v (v=(-g())*t_+v_1->[?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x=0;v:=-c()*v;++?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x!=0;](2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0)))");
    implyR('R=="t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v_1*s_+x>=0)->\forall v (v=(-g())*t_+v_1->[?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x=0;v:=-c()*v;++?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x!=0;](2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0))");
    implyR('R=="\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v_1*s_+x>=0)->\forall v (v=(-g())*t_+v_1->[?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x=0;v:=-c()*v;++?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x!=0;](2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0))");
    allL("t_", 'L=="\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v_1*s_+x>=0)");
    allR('R=="\forall v (v=(-g())*t_+v_1->[?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x=0;v:=-c()*v;++?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x!=0;](2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0))");
    implyR('R=="v=(-g())*t_+v_1->[?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x=0;v:=-c()*v;++?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x!=0;](2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0)");
    choiceb('R=="[?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x=0;v:=-c()*v;++?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x!=0;](2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0)");
    andR('R=="[?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x=0;v:=-c()*v;](2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0)&[?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x!=0;](2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0)"); <(
      "[?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x=0;v:=-c()*v;](2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0)":
        composeb('R=="[?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x=0;v:=-c()*v;](2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0)");
        testb('R=="[?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x=0;][v:=-c()*v;](2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0)");
        implyR('R=="(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x=0->[v:=-c()*v;](2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0)");
        assignb('R=="[v:=-c()*v;](2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0)");
        QE,
      "[?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x!=0;](2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0)":
        testb('R=="[?(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x!=0;](2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0)");
        implyR('R=="(-g())*((0+1*t_-0)^2/2)+v_1*(0+1*t_-0)+x!=0->2*g()*((-g())*(t_^2/2)+v_1*t_+x)=2*g()*H()-v^2&(-g())*(t_^2/2)+v_1*t_+x>=0");
        QE
    )
)End.

Tactic "07: Bouncing Ball: in-place proof: positional"
  implyR(1) ; loop("2*g*x=2*g*H-v^2&x>=0", 1) ; <(
    "Init": QE, 
    "Post": QE, 
    "Step": composeb(1) ; choiceb(1.1) ; composeb(1.1.0) ; testb(1.1.0) ; assignb(1.1.0.1) ; testb(1.1.1) ; solve(1) ; QE
)
End.

Tactic "07: Bouncing Ball: in-place proof: named"
  implyR('R=="(x>=0&x=H()&v=0)&g()>0&1=c()&c()>=0->[{{x'=v,v'=-g()&x>=0}{?x=0;v:=-c()*v;++?x!=0;}}*](x>=0&x<=H())");
  loop("2*g()*x=2*g()*H()-v^2&x>=0", 'R=="[{{x'=v,v'=-g()&x>=0}{?x=0;v:=-c()*v;++?x!=0;}}*](x>=0&x<=H())"); <(
    "Init":
      QE,
    "Post":
      QE,
    "Step":
      composeb('R=="[{x'=v,v'=-g()&x>=0}{?x=0;v:=-c()*v;++?x!=0;}](2*g()*x=2*g()*H()-v^2&x>=0)");
      choiceb('R=="[{x'=v,v'=-g()&x>=0}]#[?x=0;v:=-c()*v;++?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0)#");
      composeb('R=="[{x'=v,v'=-g()&x>=0}](#[?x=0;v:=-c()*v;](2*g()*x=2*g()*H()-v^2&x>=0)#&[?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0))");
      testb('R=="[{x'=v,v'=-g()&x>=0}](#[?x=0;][v:=-c()*v;](2*g()*x=2*g()*H()-v^2&x>=0)#&[?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0))");
      assignb('R=="[{x'=v,v'=-g()&x>=0}]((x=0->#[v:=-c()*v;](2*g()*x=2*g()*H()-v^2&x>=0)#)&[?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0))");
      testb('R=="[{x'=v,v'=-g()&x>=0}]((x=0->2*g()*x=2*g()*H()-(-c()*v)^2&x>=0)&#[?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0)#)");
      solve('R=="[{x'=v,v'=-g()&x>=0}]((x=0->2*g()*x=2*g()*H()-(-c()*v)^2&x>=0)&(x!=0->2*g()*x=2*g()*H()-v^2&x>=0))");
      QE
  )
End.
       
Tactic "07: Bouncing Ball: automatic"
  auto
End.
       
Illustration "https://lfcps.org/info/fig-bouncing-ball-dark-trace.png".
End.
       
       
ArchiveEntry "07: Simple Discrete Loop"
Description "Example 7.2: Stronger Invariants for simple discrete loop".

ProgramVariables
  Real x, y;
End.

Problem
  x>=8 & 5>=y&y>=0
 ->
  [{x:=x+y; y:=x-2*y;}* @invariant(x>=y & y>=0)] x>=0
End.

Tactic "07: Simple Discrete Loop: stepwise"
  implyR(1) ; loop("x>=y&y>=0", 1) ; <(
    "Init": QE, 
    "Post": QE, 
    "Step": composeb(1) ; assignb(1.1) ; assignb(1) ; QE
)
End.
       
Tactic "07: Simple Discrete Loop: automatic"
  auto
End.

End.
ArchiveEntry "08: Event-triggered Ping-Pong Ball"
Description "8.2.7 Proposition 8.1: Event-triggered ping-pong is safe".

Definitions
  Real H;        /* initial height */
  Real g;        /* gravity */
  Real c;        /* damping coefficient */
  Real f;        /* paddle factor */
End.

ProgramVariables
  Real x, v;     /* height, velocity */
End.
                
Problem
  (0<=x&x<=5 & v<=0) &
  (g>0 & 1>=c&c>=0 & f>=0)
  ->
  [
    {
      { {x'=v,v'=-g&x>=0&x<=5}++{x'=v,v'=-g&x>=5} }
      {?x=0; v:=-c*v; ++ ?(4<=x&x<=5&v>=0); v:=-f*v; ++ ?(x!=0&x<4|x>5);}
    }* @invariant(5>=x&x>=0 & (x=5->v<=0))
  ] (0<=x&x<=5)
End.

Tactic "08: Event-triggered Ping Pong Ball: Proof: positional"
  implyR(1) ; loop("5>=x&x>=0&(x=5->v<=0)", 1) ; <(
    "Init": QE, 
    "Post": QE, 
    "Step": composeb(1) ; choiceb(1.1) ; choiceb(1.1.1) ; composeb(1.1.0) ; composeb(1.1.1.0) ; assignb(1.1.0.1) ; testb(1.1.0) ; assignb(1.1.1.0.1) ; testb(1.1.1.0) ; testb(1.1.1.1) ; choiceb(1) ; andR(1) ; <(
      solve(1) ; QE, 
        solve(1) ; QE
    )
  )
End.

Tactic "08: Event-triggered Ping Pong Ball: Proof: named"
  implyR('R=="(0<=x&x<=5&v<=0)&g()>0&1>=c()&c()>=0&f()>=0->[{{{x'=v,v'=-g()&x>=0&x<=5}++{x'=v,v'=-g()&x>=5}}{?x=0;v:=-c()*v;++?4<=x&x<=5&v>=0;v:=-f()*v;++?x!=0&x < 4|x>5;}}*](0<=x&x<=5)");
  loop("5>=x&x>=0&(x=5->v<=0)", 'R=="[{{{x'=v,v'=-g()&x>=0&x<=5}++{x'=v,v'=-g()&x>=5}}{?x=0;v:=-c()*v;++?4<=x&x<=5&v>=0;v:=-f()*v;++?x!=0&x < 4|x>5;}}*](0<=x&x<=5)"); <(
    "Init":
      QE,
    "Post":
      QE,
    "Step":
      composeb('R=="[{{x'=v,v'=-g()&x>=0&x<=5}++{x'=v,v'=-g()&x>=5}}{?x=0;v:=-c()*v;++?4<=x&x<=5&v>=0;v:=-f()*v;++?x!=0&x < 4|x>5;}](5>=x&x>=0&(x=5->v<=0))");
      choiceb('R=="[{x'=v,v'=-g()&x>=0&x<=5}++{x'=v,v'=-g()&x>=5}]#[?x=0;v:=-c()*v;++?4<=x&x<=5&v>=0;v:=-f()*v;++?x!=0&x < 4|x>5;](5>=x&x>=0&(x=5->v<=0))#");
      choiceb('R=="[{x'=v,v'=-g()&x>=0&x<=5}++{x'=v,v'=-g()&x>=5}]([?x=0;v:=-c()*v;](5>=x&x>=0&(x=5->v<=0))&#[?4<=x&x<=5&v>=0;v:=-f()*v;++?x!=0&x < 4|x>5;](5>=x&x>=0&(x=5->v<=0))#)");
      composeb('R=="[{x'=v,v'=-g()&x>=0&x<=5}++{x'=v,v'=-g()&x>=5}](#[?x=0;v:=-c()*v;](5>=x&x>=0&(x=5->v<=0))#&[?4<=x&x<=5&v>=0;v:=-f()*v;](5>=x&x>=0&(x=5->v<=0))&[?x!=0&x < 4|x>5;](5>=x&x>=0&(x=5->v<=0)))");
      composeb('R=="[{x'=v,v'=-g()&x>=0&x<=5}++{x'=v,v'=-g()&x>=5}]([?x=0;][v:=-c()*v;](5>=x&x>=0&(x=5->v<=0))&#[?4<=x&x<=5&v>=0;v:=-f()*v;](5>=x&x>=0&(x=5->v<=0))#&[?x!=0&x < 4|x>5;](5>=x&x>=0&(x=5->v<=0)))");
      assignb('R=="[{x'=v,v'=-g()&x>=0&x<=5}++{x'=v,v'=-g()&x>=5}]([?x=0;]#[v:=-c()*v;](5>=x&x>=0&(x=5->v<=0))#&[?4<=x&x<=5&v>=0;][v:=-f()*v;](5>=x&x>=0&(x=5->v<=0))&[?x!=0&x < 4|x>5;](5>=x&x>=0&(x=5->v<=0)))");
      testb('R=="[{x'=v,v'=-g()&x>=0&x<=5}++{x'=v,v'=-g()&x>=5}](#[?x=0;](5>=x&x>=0&(x=5->-c()*v<=0))#&[?4<=x&x<=5&v>=0;][v:=-f()*v;](5>=x&x>=0&(x=5->v<=0))&[?x!=0&x < 4|x>5;](5>=x&x>=0&(x=5->v<=0)))");
      assignb('R=="[{x'=v,v'=-g()&x>=0&x<=5}++{x'=v,v'=-g()&x>=5}]((x=0->5>=x&x>=0&(x=5->-c()*v<=0))&[?4<=x&x<=5&v>=0;]#[v:=-f()*v;](5>=x&x>=0&(x=5->v<=0))#&[?x!=0&x < 4|x>5;](5>=x&x>=0&(x=5->v<=0)))");
      testb('R=="[{x'=v,v'=-g()&x>=0&x<=5}++{x'=v,v'=-g()&x>=5}]((x=0->5>=x&x>=0&(x=5->-c()*v<=0))&#[?4<=x&x<=5&v>=0;](5>=x&x>=0&(x=5->-f()*v<=0))#&[?x!=0&x < 4|x>5;](5>=x&x>=0&(x=5->v<=0)))");
      testb('R=="[{x'=v,v'=-g()&x>=0&x<=5}++{x'=v,v'=-g()&x>=5}]((x=0->5>=x&x>=0&(x=5->-c()*v<=0))&(4<=x&x<=5&v>=0->5>=x&x>=0&(x=5->-f()*v<=0))&#[?x!=0&x < 4|x>5;](5>=x&x>=0&(x=5->v<=0))#)");
      choiceb('R=="[{x'=v,v'=-g()&x>=0&x<=5}++{x'=v,v'=-g()&x>=5}]((x=0->5>=x&x>=0&(x=5->-c()*v<=0))&(4<=x&x<=5&v>=0->5>=x&x>=0&(x=5->-f()*v<=0))&(x!=0&x < 4|x>5->5>=x&x>=0&(x=5->v<=0)))");
      andR('R=="[{x'=v,v'=-g()&x>=0&x<=5}]((x=0->5>=x&x>=0&(x=5->-c()*v<=0))&(4<=x&x<=5&v>=0->5>=x&x>=0&(x=5->-f()*v<=0))&(x!=0&x < 4|x>5->5>=x&x>=0&(x=5->v<=0)))&[{x'=v,v'=-g()&x>=5}]((x=0->5>=x&x>=0&(x=5->-c()*v<=0))&(4<=x&x<=5&v>=0->5>=x&x>=0&(x=5->-f()*v<=0))&(x!=0&x < 4|x>5->5>=x&x>=0&(x=5->v<=0)))"); <(
        "[{x'=v,v'=-g()&x>=0&x<=5}]((x=0->5>=x&x>=0&(x=5->-c()*v<=0))&(4<=x&x<=5&v>=0->5>=x&x>=0&(x=5->-f()*v<=0))&(x!=0&x < 4|x>5->5>=x&x>=0&(x=5->v<=0)))":
          solve('R=="[{x'=v,v'=-g()&x>=0&x<=5}]((x=0->5>=x&x>=0&(x=5->-c()*v<=0))&(4<=x&x<=5&v>=0->5>=x&x>=0&(x=5->-f()*v<=0))&(x!=0&x < 4|x>5->5>=x&x>=0&(x=5->v<=0)))");
          QE,
        "[{x'=v,v'=-g()&x>=5}]((x=0->5>=x&x>=0&(x=5->-c()*v<=0))&(4<=x&x<=5&v>=0->5>=x&x>=0&(x=5->-f()*v<=0))&(x!=0&x < 4|x>5->5>=x&x>=0&(x=5->v<=0)))":
          solve('R=="[{x'=v,v'=-g()&x>=5}]((x=0->5>=x&x>=0&(x=5->-c()*v<=0))&(4<=x&x<=5&v>=0->5>=x&x>=0&(x=5->-f()*v<=0))&(x!=0&x < 4|x>5->5>=x&x>=0&(x=5->v<=0)))");
          QE
      )
  )
End.

Tactic "08: Event-triggered Ping Pong Ball: automatic"
  auto
End.


Illustration "https://lfcps.org/info/ping-pong-ball-early.png".
End.
       ArchiveEntry "09: Time-Triggered Ping-Pong Ball"
Description "9.2.5 Proposition 9.1: Time-triggered ping-pong is safe".

Definitions
  Real H;        /* initial height */
  Real g;        /* gravity */
  Real c;        /* damping coefficient */
  Real f;        /* paddle factor */
End.

ProgramVariables
  Real x, v;     /* height, velocity */
  Real t;        /* time */
End.
                
Problem
  (2*x=2*H-v^2 & 0<=x&x<=5 & v<=0) &
  (g=1&g>0 & 1=c&c>=0 & 1=f&f>=0)
  ->
  [
    {
      {{?x=0; v:=-c*v; ++ ?x!=0;}
      {?((x>5+1/2-v | 2*x>2*5-v^2&v<1) & v>=0); v:=-f*v; ++ ? !((x>5+1/2-v | 2*x>2*5-v^2&v<1) & v>=0);}}
      t:=0; {x'=v,v'=-g,t'=1 & x>=0&t<=1}
    }* @invariant(2*x=2*H-v^2 & (x>=0&x<=5))
  ] (0<=x&x<=5)
End.

Tactic "09: Time-Triggered Ping Pong Ball: Proof: positional"
  implyR(1) ; loop("2*x=2*H-v^2&x>=0&x<=5", 1) ; <(
  "Init": QE, 
  "Post": QE, 
  "Step": composeb(1) ; composeb(1) ; composeb(1.1.1) ; solve(1.1.1.1) ; assignb(1.1.1) ; choiceb(1) ; andR(1) ; <(
    composeb(1) ; testb(1) ; implyR(1) ; assignb(1) ; choiceb(1) ; andR(1) ; <(
      composeb(1) ; testb(1) ; implyR(1) ; assignb(1) ; QE, 
        testb(1) ; QE
      ), 
      testb(1) ; implyR(1) ; choiceb(1) ; andR(1) ; <(
      composeb(1) ; testb(1) ; implyR(1) ; assignb(1) ; QE, 
        testb(1) ; QE
      )
    )
    )
End.

Tactic "09: Time-Triggered Ping Pong Ball: Proof: named"
  implyR('R=="(2*x=2*H()-v^2&0<=x&x<=5&v<=0)&g()=1&g()>0&1=c()&c()>=0&1=f()&f()>=0->[{{{?x=0;v:=-c()*v;++?x!=0;}{?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);}}t:=0;{x'=v,v'=-g(),t'=1&x>=0&t<=1}}*](0<=x&x<=5)");
  loop("2*x=2*H()-v^2&x>=0&x<=5", 'R=="[{{{?x=0;v:=-c()*v;++?x!=0;}{?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);}}t:=0;{x'=v,v'=-g(),t'=1&x>=0&t<=1}}*](0<=x&x<=5)"); <(
    "Init":
      QE,
    "Post":
      QE,
    "Step":
      composeb('R=="[{{?x=0;v:=-c()*v;++?x!=0;}{?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);}}t:=0;{x'=v,v'=-g(),t'=1&x>=0&t<=1}](2*x=2*H()-v^2&x>=0&x<=5)");
      composeb('R=="[{?x=0;v:=-c()*v;++?x!=0;}{?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);}][t:=0;{x'=v,v'=-g(),t'=1&x>=0&t<=1}](2*x=2*H()-v^2&x>=0&x<=5)");
      composeb('R=="[?x=0;v:=-c()*v;++?x!=0;][?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]#[t:=0;{x'=v,v'=-g(),t'=1&x>=0&t<=1}](2*x=2*H()-v^2&x>=0&x<=5)#");
      solve('R=="[?x=0;v:=-c()*v;++?x!=0;][?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);][t:=0;]#[{x'=v,v'=-g(),t'=1&x>=0&t<=1}](2*x=2*H()-v^2&x>=0&x<=5)#");
      assignb('R=="[?x=0;v:=-c()*v;++?x!=0;][?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]#[t:=0;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+t<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)#");
      choiceb('R=="[?x=0;v:=-c()*v;++?x!=0;][?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
      andR('R=="[?x=0;v:=-c()*v;][?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)&[?x!=0;][?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)"); <(
        "[?x=0;v:=-c()*v;][?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)":
          composeb('R=="[?x=0;v:=-c()*v;][?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
          testb('R=="[?x=0;][v:=-c()*v;][?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
          implyR('R=="x=0->[v:=-c()*v;][?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
          assignb('R=="[v:=-c()*v;][?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
          choiceb('R=="[?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
          andR('R=="[?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)&[?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)"); <(
            "[?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)":
              composeb('R=="[?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
              testb('R=="[?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;][v:=-f()*v;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
              implyR('R=="(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0->[v:=-f()*v;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
              assignb('R=="[v:=-f()*v;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
              QE,
            "[?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)":
              testb('R=="[?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
              implyR('R=="!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0)->\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
              QE
          ),
        "[?x!=0;][?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)":
          testb('R=="[?x!=0;][?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
          implyR('R=="x!=0->[?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
          choiceb('R=="[?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;++?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
          composeb('R=="#[?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;v:=-f()*v;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)#&[?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
          testb('R=="#[?(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0;][v:=-f()*v;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)#&[?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
          andR('R=="((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0->[v:=-f()*v;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5))&[?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)"); <(
            "(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0->[v:=-f()*v;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)":
              implyR('R=="(x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0->[v:=-f()*v;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
              assignb('R=="[v:=-f()*v;]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
              QE,
            "[?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)":
              testb('R=="[?!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0);]\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
              implyR('R=="!((x>5+1/2-v|2*x>2*5-v^2&v < 1)&v>=0)->\forall t_ (t_>=0->\forall s_ (0<=s_&s_<=t_->(-g())*(s_^2/2)+v*s_+x>=0&s_+0<=1)->2*((-g())*(t_^2/2)+v*t_+x)=2*H()-((-g())*t_+v)^2&(-g())*(t_^2/2)+v*t_+x>=0&(-g())*(t_^2/2)+v*t_+x<=5)");
              QE
          )
      )
  )
End.

Tactic "09: Time-Triggered Ping Pong Ball: automatic"
  auto
End.

Illustration "https://lfcps.org/info/ping-pong-ball-time-miss.png".
End.
       ArchiveEntry "10: Simple rotational dynamics"
Description "10.3.7 Simple rotational dynamics".

Definitions
  Real r;        /* radius r of circle around origin */
End.

ProgramVariables
  Real v,w;      /* direction in x/y-axis */
End.

Problem
  v^2+w^2-r^2=0 -> 
    [{v'=w,w'=-v}@invariant(v^2+w^2-r^2=0)] v^2+w^2-r^2=0
End.

Tactic "10: Simple rotational dynamics: Proof Steps: positional"
  implyR(1); dIRule(1); <(
    "dI Init": id,
    "dI Step": Dassignb(1); Dassignb(1); QE
  )
End.

Tactic "10: Simple rotational dynamics: Proof Steps: named"
  implyR('R=="v^2+w^2-r()^2=0->[{v'=w,w'=-v}]v^2+w^2-r()^2=0");
  dIRule('R=="[{v'=w,w'=-v}]v^2+w^2-r()^2=0"); <(
    "dI Init":
      id,
    "dI Step":
      Dassignb('R=="[w':=-v;][v':=w;]2*v^(2-1)*v'+2*w^(2-1)*w'-0=0");
      Dassignb('R=="[v':=w;]2*v^(2-1)*v'+2*w^(2-1)*(-v)-0=0");
      QE
  )
End.

Tactic "10: Simple rotational dynamics: Proof"
  implyR(1) ; dIClose(1)
End.

End.

ArchiveEntry "10: Self-crossing invariant"
Description "Example 10.7: Self-crossing".

Definitions
  Real c;
End.

ProgramVariables
  Real x,y;
End.

Problem
 x^2+x^3-y^2-c=0 -> 
   [{x' = -2*y, y' = -2*x - 3*x^2}] x^2+x^3-y^2-c=0
  
End.

Tactic "10: Self-crossing invariant: Proof Steps: positional"
  implyR(1); dIRule(1); <(
    "dI Init": id,
    "dI Step": Dassignb(1); Dassignb(1); QE
  )
End.

Tactic  "10: Self-crossing invariant: Proof Steps"
  implyR('R=="x^2+x^3-y^2-c()=0->[{x'=(-2)*y,y'=(-2)*x-3*x^2}]x^2+x^3-y^2-c()=0");
  dIRule('R=="[{x'=(-2)*y,y'=(-2)*x-3*x^2}]x^2+x^3-y^2-c()=0"); <(
    "dI Init":
      id,
    "dI Step":
      Dassignb('R=="[y':=(-2)*x-3*x^2;][x':=(-2)*y;]2*x^(2-1)*x'+3*x^(3-1)*x'-2*y^(2-1)*y'-0=0");
      Dassignb('R=="[x':=(-2)*y;]2*x^(2-1)*x'+3*x^(3-1)*x'-2*y^(2-1)*((-2)*x-3*x^2)-0=0");
      QE
  )
End.

Tactic "10: Self-crossing invariant: Proof"
  implyR(1) ; dIClose(1)
End.

Illustration "https://lfcps.org/info/fig-self-crossing.png".
End.

ArchiveEntry "10: Motzkin polynomial invariant"
Description "Example 10.8: Motzkin".

Definitions
  Real c;
End.

ProgramVariables
  Real x;
  Real y;
End.

Problem
  x^4*y^2+x^2*y^4-3*x^2*y^2+1=c ->
  [
    {x'=2*x^4*y+4*x^2*y^3-6*x^2*y, y'=-4*x^3*y^2-2*x*y^4+6*x*y^2}@invariant(x^4*y^2+x^2*y^4-3*x^2*y^2+1-c=0)
  ] x^4*y^2+x^2*y^4-3*x^2*y^2+1=c
End.

Tactic "10: Motzkin polynomial invariant: Proof 1"
  implyR(1) ; dIClose(1)
End.

Illustration "https://lfcps.org/info/fig-DI-dynamics2.png".
End.

ArchiveEntry "10: Henon-Heiles motion of a star"
Description "Henon-Heiles system for the motion of a star around the center of the galaxy".

Definitions
  Real eps;
  Real A;
  Real B;
End. 

ProgramVariables
  Real x, y;     /* x/y-position */
  Real u, v;     /* x/y-direction */
End.

Problem
  1/2 * (u^2 + v^2 + A*x^2 + B*y^2) + x^2*y - 1/3 * eps * y^3 = 0 ->
  [{x'=u,y'=v,u'=-A*x - 2*x*y, v'= -B*y + eps*y^2 - x^2}]1/2 * (u^2 + v^2 + A*x^2 + B*y^2) + x^2*y - 1/3 * eps * y^3 = 0
End.

Tactic "10: Henon-Heiles motion of a star: Proof 1"
  implyR(1) ; dIClose(1)
End.

End.


       ArchiveEntry "11: Aerodynamic Bouncing Ball"
Description "11.12: Proving Aerodynamic Bouncing Balls".

Definitions      /* function symbols cannot change their value */
  Real H;        /* initial height of ball */
  Real g;        /* gravitational constant */
  Real c;        /* elastic damping factor for bounce on the floor (x=0) */
  Real r;        /* aerodynamic damping factor in the air / air resistance */
End.

ProgramVariables /* program variables may change their value over time */
  R x, v;        /* height and vertical velocity of ball */
End.

Problem
  (x<=H & v=0 & x>=0) &
  (g>0 & 1>=c&c>=0 & r>=0)
 ->
  [
    {
      {?x=0; v:=-c*v;  ++  ?x!=0;}
      {{x'=v,v'=-g-r*v^2&x>=0&v>=0} ++ {x'=v,v'=-g+r*v^2&x>=0&v<=0}}
    }* @invariant(2*g*x<=2*g*H-v^2&x>=0)
  ] (0<=x&x<=H)
End.

Tactic "11: Aerodynamic Acrophobic Bouncing Ball: generalizing as in book: positional"
  implyR(1) ; loop("2*g*x<=2*g*H-v^2&x>=0", 1) ; <(
    "Init": QE, 
    "Post": QE, 
    "Step": composeb(1) ; MR("2*g*x<=2*g*H-v^2&x>=0&g>0&r>=0", 1) ; <(
      "Use Q->P": choiceb(1) ; andR(1) ; <(
        composeb(1) ; testb(1) ; implyR(1) ; assignb(1) ; QE, 
          testb(1) ; implyR(1) ; QE
        ), 
      "Show [a]Q": choiceb(1) ; andR(1) ; <(
        dC("2*g*x<=2*g*H-v^2", 1) ; <(
          "Use": dW(1) ; propClose, 
          "Show": dIRule(1) ; <(
              "dI Init": propClose,
              "dI Step": Dassignb(1); Dassignb(1); QE
            )
          ), 
          dC("2*g*x<=2*g*H-v^2", 1) ; <(
            "Use": dW(1) ; propClose, 
            "Show": dIRule(1) ; <(
                "dI Init": propClose,
                "dI Step": Dassignb(1); Dassignb(1); QE
              )
          )
        )
      )
    )
End.

Tactic "11: Aerodynamic Acrophobic Bouncing Ball: generalizing as in book: named"
  implyR('R=="(x<=H()&v=0&x>=0)&g()>0&1>=c()&c()>=0&r()>=0->[{{?x=0;v:=-c()*v;++?x!=0;}{{x'=v,v'=-g()-r()*v^2&x>=0&v>=0}++{x'=v,v'=-g()+r()*v^2&x>=0&v<=0}}}*](0<=x&x<=H())");
  loop("2*g()*x<=2*g()*H()-v^2&x>=0", 'R=="[{{?x=0;v:=-c()*v;++?x!=0;}{{x'=v,v'=-g()-r()*v^2&x>=0&v>=0}++{x'=v,v'=-g()+r()*v^2&x>=0&v<=0}}}*](0<=x&x<=H())"); <(
    "Init":
      QE,
    "Post":
      QE,
    "Step":
      composeb('R=="[{?x=0;v:=-c()*v;++?x!=0;}{{x'=v,v'=-g()-r()*v^2&x>=0&v>=0}++{x'=v,v'=-g()+r()*v^2&x>=0&v<=0}}](2*g()*x<=2*g()*H()-v^2&x>=0)");
      MR("2*g()*x<=2*g()*H()-v^2&x>=0&g()>0&r()>=0", 'R=="[?x=0;v:=-c()*v;++?x!=0;][{x'=v,v'=-g()-r()*v^2&x>=0&v>=0}++{x'=v,v'=-g()+r()*v^2&x>=0&v<=0}](2*g()*x<=2*g()*H()-v^2&x>=0)"); <(
        "Use Q->P":
          choiceb('R=="[?x=0;v:=-c()*v;++?x!=0;](2*g()*x<=2*g()*H()-v^2&x>=0&g()>0&r()>=0)");
          andR('R=="[?x=0;v:=-c()*v;](2*g()*x<=2*g()*H()-v^2&x>=0&g()>0&r()>=0)&[?x!=0;](2*g()*x<=2*g()*H()-v^2&x>=0&g()>0&r()>=0)"); <(
            "[?x=0;v:=-c()*v;](2*g()*x<=2*g()*H()-v^2&x>=0&g()>0&r()>=0)":
              composeb('R=="[?x=0;v:=-c()*v;](2*g()*x<=2*g()*H()-v^2&x>=0&g()>0&r()>=0)");
              testb('R=="[?x=0;][v:=-c()*v;](2*g()*x<=2*g()*H()-v^2&x>=0&g()>0&r()>=0)");
              implyR('R=="x=0->[v:=-c()*v;](2*g()*x<=2*g()*H()-v^2&x>=0&g()>0&r()>=0)");
              assignb('R=="[v:=-c()*v;](2*g()*x<=2*g()*H()-v^2&x>=0&g()>0&r()>=0)");
              QE,
            "[?x!=0;](2*g()*x<=2*g()*H()-v^2&x>=0&g()>0&r()>=0)":
              testb('R=="[?x!=0;](2*g()*x<=2*g()*H()-v^2&x>=0&g()>0&r()>=0)");
              implyR('R=="x!=0->2*g()*x<=2*g()*H()-v^2&x>=0&g()>0&r()>=0");
              QE
          ),
        "Show [a]Q":
          choiceb('R=="[{x'=v,v'=-g()-r()*v^2&x>=0&v>=0}++{x'=v,v'=-g()+r()*v^2&x>=0&v<=0}](2*g()*x<=2*g()*H()-v^2&x>=0)");
          andR('R=="[{x'=v,v'=-g()-r()*v^2&x>=0&v>=0}](2*g()*x<=2*g()*H()-v^2&x>=0)&[{x'=v,v'=-g()+r()*v^2&x>=0&v<=0}](2*g()*x<=2*g()*H()-v^2&x>=0)"); <(
            "[{x'=v,v'=-g()-r()*v^2&x>=0&v>=0}](2*g()*x<=2*g()*H()-v^2&x>=0)":
              dC("2*g()*x<=2*g()*H()-v^2", 'R=="[{x'=v,v'=-g()-r()*v^2&x>=0&v>=0}](2*g()*x<=2*g()*H()-v^2&x>=0)"); <(
                "Use":
                  dW('R=="[{x'=v,v'=-g()-r()*v^2&(x>=0&v>=0)&2*g()*x<=2*g()*H()-v^2}](2*g()*x<=2*g()*H()-v^2&x>=0)");
                  propClose,
                "Show":
                  dIRule('R=="[{x'=v,v'=-g()-r()*v^2&x>=0&v>=0}]2*g()*x<=2*g()*H()-v^2"); <(
                    "dI Init":
                      propClose,
                    "dI Step":
                      Dassignb('R=="[v':=-g()-r()*v^2;][x':=v;]2*g()*x'<=0-2*v^(2-1)*v'");
                      Dassignb('R=="[x':=v;]2*g()*x'<=0-2*v^(2-1)*(-g()-r()*v^2)");
                      QE
                  )
              ),
            "[{x'=v,v'=-g()+r()*v^2&x>=0&v<=0}](2*g()*x<=2*g()*H()-v^2&x>=0)":
              dC("2*g()*x<=2*g()*H()-v^2", 'R=="[{x'=v,v'=-g()+r()*v^2&x>=0&v<=0}](2*g()*x<=2*g()*H()-v^2&x>=0)"); <(
                "Use":
                  dW('R=="[{x'=v,v'=-g()+r()*v^2&(x>=0&v<=0)&2*g()*x<=2*g()*H()-v^2}](2*g()*x<=2*g()*H()-v^2&x>=0)");
                  propClose,
                "Show":
                  dIRule('R=="[{x'=v,v'=-g()+r()*v^2&x>=0&v<=0}]2*g()*x<=2*g()*H()-v^2"); <(
                    "dI Init":
                      propClose,
                    "dI Step":
                      Dassignb('R=="[v':=-g()+r()*v^2;][x':=v;]2*g()*x'<=0-2*v^(2-1)*v'");
                      Dassignb('R=="[x':=v;]2*g()*x'<=0-2*v^(2-1)*(-g()+r()*v^2)");
                      QE
                  )
              )
          )
      )
  )
End.
       
Tactic "11: Aerodynamic Acrophobic Bouncing Ball: top-level"
  implyR(1) ; loop("2*g*x<=2*g*H-v^2&x>=0", 1) ; <(
QE, 
QE, 
composeb(1) ; choiceb(1) ; composeb(1.0) ; testb(1.0) ; andR(1) ; <(
implyR(1) ; assignb(1) ; choiceb(1) ; andR(1) ; <(
  dC("2*g*x<=2*g*H-v^2", 1) ; <(
    dW(1) ; QE, 
      dIClose(1)
    ), 
    dC("2*g*x<=2*g*H-v^2", 1) ; <(
    dW(1) ; QE, 
      dIClose(1)
    )
  ), 
  testb(1) ; implyR(1) ; choiceb(1) ; andR(1) ; <(
  dC("2*g*x<=2*g*H-v^2", 1) ; <(
    dW(1) ; QE, 
      dIClose(1)
    ), 
    dC("2*g*x<=2*g*H-v^2", 1) ; <(
    dW(1) ; QE, 
      dIClose(1)
    )
  )
)
)
End.
       
Tactic "11: Aerodynamic Acrophobic Bouncing Ball: automatic"
  auto
End.

End.

ArchiveEntry "11: Bouncing Ball"
Description "Example 11.6: Acrophobic Bouncing Ball as in chapter 7 but without solutions".

Definitions      /* function symbols cannot change their value */
  Real H;        /* initial height */
  Real g;        /* gravity */
  Real c;        /* damping coefficient */
End.

ProgramVariables /* program variables may change their value over time */
  Real x, v;     /* height and vertical velocity */
End.

Problem
  (x>=0 & x=H & v=0) &
  (g>0 & 1=c&c>=0)
 ->
  [
    {
      {x'=v,v'=-g&x>=0}
      {?x=0; v:=-c*v;  ++  ?x!=0;}
    }*@invariant(2*g*x=2*g*H-v^2 & x>=0)
  ] (x>=0 & x<=H)
End.

Tactic "11: Bouncing Ball: differential invariants"
  implyR(1) ; loop("2*g*x=2*g*H-v^2&x>=0", 1) ; <(
QE, 
QE, 
composeb(1) ; MR("2*g*x=2*g*H-v^2&x>=0&g>0&1=c", 1) ; <(
boxAnd(1) ; andR(1) ; <(
    dIClose(1), 
    dW(1) ; propClose
  ), 
  choiceb(1) ; andR(1) ; <(
    composeb(1) ; testb(1) ; implyR(1) ; assignb(1) ; QE, 
    testb(1) ; prop
  )
)
)
End.
       
Illustration "https://lfcps.org/info/fig-bouncing-ball-dark-trace.png".
End.

ArchiveEntry "11: Damped Oscillator"
Description "Example 11.8: Damped oscillator".

Definitions      /* function symbols cannot change their value */
  Real w;        /* undamped angular frequency */
  Real c;        /* level of ellipse */
  Real d;        /* constant damping ratio */
End.

ProgramVariables /* program variables may change their value over time */
  Real x, y;     /* position and velocity of spring/mass system */
End.

Problem
    w^2*x^2 + y^2 <= c^2
->
  [{x'=y, y'=-w^2*x-2*d*w*y & w>=0 & d>=0}]w^2*x^2 + y^2 <= c^2
End.

Tactic "11: Damped Oscillator: Differential invariant proof"
  implyR(1) ; dIClose(1)
End.

Illustration "https://lfcps.org/info/fig-damposc-evo2t-region.png".
End.


ArchiveEntry "11: Increasingly Damped Oscillator"
Description "Example 11.9: Increasingly damped oscillator".

Definitions
  Real w;        /* undamped angular frequency */
  Real c;        /* level of ellipse */
End.

ProgramVariables
  Real x;        /* position of spring/mass system */
  Real y;        /* velocity */
  Real d;        /* damping ratio */
End.

Problem
    w^2*x^2 + y^2 <= c^2
  & d>=0
->
  [{x'=y, y'=-w^2*x-2*d*w*y, d'=7 & w>=0}]w^2*x^2 + y^2 <= c^2
End.

Tactic "11: Increasingly Damped Oscillator: Differential cut proof"
  implyR(1) ; dC("d>=0", 1) ; <(
    dIClose(1), 
    dIClose(1)
  )
End.

Illustration "https://lfcps.org/info/fig-damped-damped-osc-field-region.png".
End.
       
ArchiveEntry "12: Bouncing Ball with ghost solutions"
Description "12.3.2 Proving Bouncing Balls with Sneaky Solutions".

Definitions      /* function symbols cannot change their value */
  Real H;        /* initial height */
  Real g;        /* gravity */
  Real c;        /* damping coefficient */
End.

ProgramVariables /* program variables may change their value over time */
  Real x, v;     /* height and velocity */
End.

Problem
  (x>=0 & x=H & v=0) &
  (g>0 & 1=c&c>=0)
 ->
  [
    {
      {x'=v,v'=-g&x>=0}
      {?x=0; v:=-c*v;  ++  ?x!=0;}
    }* @invariant(2*g*x=2*g*H-v^2 & x>=0)
  ] (x>=0 & x<=H)
End.

Tactic "12: Bouncing Ball with ghost solutions: ghost solutions: positional"
  implyR(1) ; loop("2*g*x=2*g*H-v^2&x>=0", 1) ; <(
  "Init": QE, 
  "Post": QE, 
  "Step": composeb(1) ; MR("(2*g*x=2*g*H-v^2&x>=0)&g>0&1=c", 1) ; <(
    "Use Q->P": boxAnd(1) ; andR(1) ; <(
      dG("t'=1", 1) ; existsR("0", 1) ; dC("v=old(v)-g*t", 1) ; <(
        "Use": dC("x=old(x)+old(v)*t-g/2*t^2", 1) ; <(
          "Use": dW(1) ; QE, 
          "Show": dIRule(1) ; <(
                      "dI Init": QE,
                      "dI Step": Dassignb(1); Dassignb(1); Dassignb(1); QE
                  )
          ), 
          "Show": dIRule(1) ; <(
                      "dI Init": QE,
                      "dI Step": Dassignb(1); Dassignb(1); Dassignb(1); QE
                  )
        ), 
        GV(1) ; propClose
      ), 
      "Show [a]Q": choiceb(1) ; andR(1) ; <(
      composeb(1) ; testb(1) ; implyR(1) ; assignb(1) ; QE, 
        testb(1) ; implyR(1) ; prop
      )
    )
)
End.

Tactic "12: Bouncing Ball with ghost solutions: ghost solutions: named"
  implyR('R=="(x>=0&x=H()&v=0)&g()>0&1=c()&c()>=0->[{{x'=v,v'=-g()&x>=0}{?x=0;v:=-c()*v;++?x!=0;}}*](x>=0&x<=H())");
  loop("2*g()*x=2*g()*H()-v^2&x>=0", 'R=="[{{x'=v,v'=-g()&x>=0}{?x=0;v:=-c()*v;++?x!=0;}}*](x>=0&x<=H())"); <(
    "Init":
      QE,
    "Post":
      QE,
    "Step":
      composeb('R=="[{x'=v,v'=-g()&x>=0}{?x=0;v:=-c()*v;++?x!=0;}](2*g()*x=2*g()*H()-v^2&x>=0)");
      MR("(2*g()*x=2*g()*H()-v^2&x>=0)&g()>0&1=c()", 'R=="[{x'=v,v'=-g()&x>=0}][?x=0;v:=-c()*v;++?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0)"); <(
        "Use Q->P":
          boxAnd('R=="[{x'=v,v'=-g()&x>=0}]((2*g()*x=2*g()*H()-v^2&x>=0)&g()>0&1=c())");
          andR('R=="[{x'=v,v'=-g()&x>=0}](2*g()*x=2*g()*H()-v^2&x>=0)&[{x'=v,v'=-g()&x>=0}](g()>0&1=c())"); <(
            "[{x'=v,v'=-g()&x>=0}](2*g()*x=2*g()*H()-v^2&x>=0)":
              dG("t'=1", 'R=="[{x'=v,v'=-g()&x>=0}](2*g()*x=2*g()*H()-v^2&x>=0)");
              existsR("0", 'R=="\exists t [{x'=v,v'=-g(),t'=1&x>=0}](2*g()*x=2*g()*H()-v^2&x>=0)");
              dC("v=old(v)-g()*t", 'R=="[{x'=v,v'=-g(),t'=1&x>=0}](2*g()*x=2*g()*H()-v^2&x>=0)"); <(
                "Use":
                  dC("x=old(x)+old(v)*t-g()/2*t^2", 'R=="[{x'=v,v'=-g(),t'=1&x>=0&v=v_0-g()*t}](2*g()*x=2*g()*H()-v^2&x>=0)"); <(
                    "Use":
                      dW('R=="[{x'=v,v'=-g(),t'=1&(x>=0&v=v_0-g()*t)&x=x_0+v_0*t-g()/2*t^2}](2*g()*x=2*g()*H()-v^2&x>=0)");
                      QE,
                    "Show":
                      dIRule('R=="[{x'=v,v'=-g(),t'=1&x>=0&v=v_0-g()*t}]x=x_0+v_0*t-g()/2*t^2"); <(
                        "dI Init":
                          QE,
                        "dI Step":
                          Dassignb('R=="[t':=1;][v':=-g();][x':=v;]x'=0+v_0()*t'-g()/2*(2*t^(2-1)*t')");
                          Dassignb('R=="[v':=-g();][x':=v;]x'=0+v_0()*1-g()/2*(2*t^(2-1)*1)");
                          Dassignb('R=="[x':=v;]x'=0+v_0()*1-g()/2*(2*t^(2-1)*1)");
                          QE
                      )
                  ),
                "Show":
                  dIRule('R=="[{x'=v,v'=-g(),t'=1&x>=0}]v=v_0-g()*t"); <(
                    "dI Init":
                      QE,
                    "dI Step":
                      Dassignb('R=="[t':=1;][v':=-g();][x':=v;]v'=0-g()*t'");
                      Dassignb('R=="[v':=-g();][x':=v;]v'=0-g()*1");
                      Dassignb('R=="[x':=v;]-g()=0-g()*1");
                      QE
                  )
              ),
            "[{x'=v,v'=-g()&x>=0}](g()>0&1=c())":
              GV('R=="[{x'=v,v'=-g()&x>=0}](g()>0&1=c())");
              propClose
          ),
        "Show [a]Q":
          choiceb('R=="[?x=0;v:=-c()*v;++?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0)");
          andR('R=="[?x=0;v:=-c()*v;](2*g()*x=2*g()*H()-v^2&x>=0)&[?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0)"); <(
            "[?x=0;v:=-c()*v;](2*g()*x=2*g()*H()-v^2&x>=0)":
              composeb('R=="[?x=0;v:=-c()*v;](2*g()*x=2*g()*H()-v^2&x>=0)");
              testb('R=="[?x=0;][v:=-c()*v;](2*g()*x=2*g()*H()-v^2&x>=0)");
              implyR('R=="x=0->[v:=-c()*v;](2*g()*x=2*g()*H()-v^2&x>=0)");
              assignb('R=="[v:=-c()*v;](2*g()*x=2*g()*H()-v^2&x>=0)");
              QE,
            "[?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0)":
              testb('R=="[?x!=0;](2*g()*x=2*g()*H()-v^2&x>=0)");
              implyR('R=="x!=0->2*g()*x=2*g()*H()-v^2&x>=0");
              propClose
          )
      )
  )
End.

Illustration "https://lfcps.org/info/fig-bouncing-ball-dark-trace.png".
End.

ArchiveEntry "12: Exponential Decay"
Description "12.3.4 Differential ghost as counterweight".

ProgramVariables
  Real x;
End.

Problem
  x>0 -> [{x'=-x}]x>0
End.

Tactic "12: Exponential Decay from tactic: implicit positional"
  implyR(1);
  dG("y'=1/2*y", "x*y^2=1", 1);
  existsRmon("x*y^2=1", 1); <(
    "Use": QE,
    "Show": dIRule(1); <(
        "dI Init": id,
        "dI Step": Dassignb(1); Dassignb(1); QE
      )
  )
End.

Tactic "12: Exponential Decay from tactic: implicit named"
  implyR('R=="x>0->[{x'=-x}]x>0");
  dG("y'=1/2*y", "x*y^2=1", 'R=="[{x'=-x}]x>0");
  existsRmon("x*y^2=1", 'R=="\exists y [{x'=-x,y'=1/2*y+0}]x*y^2=1"); <(
    "Use":
      QE,
    "Show":
      dIRule('R=="[{x'=-x,y'=1/2*y+0}]x*y^2=1"); <(
        "dI Init":
          id,
        "dI Step":
          Dassignb('R=="[y':=1/2*y+0;][x':=-x;]x'*y^2+x*(2*y^(2-1)*y')=0");
          Dassignb('R=="[x':=-x;]x'*y^2+x*(2*y^(2-1)*(1/2*y+0))=0");
          QE
      )
  )
End.

Tactic "12: Exponential Decay from tactic: named"
  implyR('R=="x>0->[{x'=-x}]x>0");
  dG("y'=1/2*y", "x*y^2=1", 'R=="[{x'=-x}]x>0");
  dIRule('R=="\exists y #[{x'=-x,y'=1/2*y+0}]x*y^2=1#");
  Dassignb('R=="\exists y (true->x*y^2=1&\forall x \forall y #[y':=1/2*y+0;][x':=-x;]x'*y^2+x*(2*y^(2-1)*y')=0#)");
  Dassignb('R=="\exists y (true->x*y^2=1&\forall x \forall y #[x':=-x;]x'*y^2+x*(2*y^(2-1)*(1/2*y+0))=0#)");
  QE
End.

Tactic "12: Exponential Decay from tactic: positional"
  implyR(1) ; dG("y'=1/2*y", "x*y^2=1", 1) ; dIClose(1.0) ; QE
End.

Tactic "12: Exponential Decay: automatic"
  /* needs QE("Mathematica") */
  auto
End.
 

End.

ArchiveEntry "12: Exponential Growth"
Description "Example 12.3".

ProgramVariables
  Real x;
End.

Problem
  x>0 -> [{x'=x}]x>0
End.

Tactic "12: Exponential Growth from tactic"
  implyR(1) ; dG("y'=-1/2*y", "x*y^2=1", 1) ; dIClose(1.0) ; QE
End.

Tactic "12: Exponential Growth from tactic: implicit positional"
  implyR(1);
  dG("y'=-1/2*y", "x*y^2=1", 1);
  existsRmon("x*y^2=1", 1); <(
    "Use": QE,
    "Show": dIRule(1); <(
        "dI Init": id,
        "dI Step": Dassignb(1); Dassignb(1); QE
      )
  )
End.

Tactic "12: Exponential Growth: automatic"
  /* needs QE("Mathematica") */
  auto
End.

End.


ArchiveEntry "12: Exponential at Equilibrium"
Description "Example 12.6 Exponential equilibrium".

ProgramVariables
 Real x;
End.

Problem
 x=0 -> [{x'=x}]x=0
End.

Tactic "12: Exponential at Equilibrium from tactic"
 implyR(1) ; dG("y'=-1*y", "y>0&x*y=0", 1) ; boxAnd(1.0) ; dIClose(1.0.1) ; dG("z'=1/2*z", "y*z^2=1", 1.0.0) ; dIClose(1.0.0.0) ; QE
End.

Tactic "12: Exponential at Equilibrium: top-level: named"
implyR('R=="x=0->[{x'=x}]x=0");
dG("y'=(-1)*y", "y>0&x*y=0", 'R=="[{x'=x}]x=0");
existsRmon("y>0&x*y=0", 'R=="\exists y [{x'=x,y'=(-1)*y+0}](y>0&x*y=0)"); <(
  "Use":
    QE,
  "Show":
    boxAnd('R=="[{x'=x,y'=(-1)*y+0}](y>0&x*y=0)");
    andR('R=="[{x'=x,y'=(-1)*y+0}]y>0&[{x'=x,y'=(-1)*y+0}]x*y=0"); <(
      "[{x'=x,y'=(-1)*y+0}]y>0":
        dG("z'=1/2*z", "y*z^2=1", 'R=="[{x'=x,y'=(-1)*y+0}]y>0");
        existsRmon("y*z^2=1", 'R=="\exists z [{x'=x,y'=(-1)*y+0,z'=1/2*z+0}]y*z^2=1"); <(
          "Use":
            QE,
          "Show":
            dIRule('R=="[{x'=x,y'=(-1)*y+0,z'=1/2*z+0}]y*z^2=1"); <(
              "dI Init":
                propClose,
              "dI Step":
                Dassignb('R=="[z':=1/2*z+0;][y':=(-1)*y+0;][x':=x;]y'*z^2+y*(2*z^(2-1)*z')=0");
                Dassignb('R=="[y':=(-1)*y+0;][x':=x;]y'*z^2+y*(2*z^(2-1)*(1/2*z+0))=0");
                Dassignb('R=="[x':=x;]((-1)*y+0)*z^2+y*(2*z^(2-1)*(1/2*z+0))=0");
                QE
            )
        ),
      "[{x'=x,y'=(-1)*y+0}]x*y=0":
        dIRule('R=="[{x'=x,y'=(-1)*y+0}]x*y=0"); <(
          "dI Init":
            propClose,
          "dI Step":
            Dassignb('R=="[y':=(-1)*y+0;][x':=x;]x'*y+x*y'=0");
            Dassignb('R=="[x':=x;]x'*y+x*((-1)*y+0)=0");
            QE
        )
    )
)
End.

Tactic "12: Exponential at Equilibrium: top-level: positional"
 implyR(1) ; dG("y'=-1*y", "y>0&x*y=0", 1) ; existsR("1", 1) ; boxAnd(1) ; andR(1) ; <(
 dG("z'=1/2*z", "z^2*y=1", 1) ; existsR("1", 1) ; dIClose(1),
 dIClose(1)
 )
End.

Tactic "12: Exponential at Equilibrium: Automatic"
 /* needs QE("Mathematica") */
 auto
End.

End.

ArchiveEntry "12: Exponential Difference"
Description "Example 12.4".

ProgramVariables
  Real x;
End.

Problem
  x!=0 -> [{x'=x}]x!=0
End.

Tactic "12: Exponential difference from tactic"
  implyR(1) ; dG("y'=-1*y", "x*y=1", 1) ; dIClose(1.0) ; QE
End.
   
Tactic "12: Exponential difference: top-level proof"
  implyR(1) ; dG("y'=-1*y", "x*y=1", 1) ; existsR("1/x", 1) ; dIClose(1)
End.
   
End.
       ArchiveEntry "16: Dual Filibuster Game"
Description "Example 16.4".

ProgramVariables
  Real x;
End.

Problem
  x=0
 ->
 <{{{x:=0; ++ x:=1;}^@}*}^@> x=0
End.

Tactic "16: Dual Filibuster Game: Proof: positional"
  implyR(1) ; duald(1) ; box(1) ; loop("x=0", 1) ; <(
    "Init": id, 
    "Step": dualb(1) ; diamond(1) ; choiced(1) ; orR(1) ; assignd(1) ; hideR(2) ; QE, 
    "Post": id
)
End.

Tactic "16: Dual Filibuster Game: Proof: named"
  implyR('R=="x=0-><{{{x:=0;++x:=1;}^@}*}^@>x=0");
  duald('R=="<{{{x:=0;++x:=1;}^@}*}^@>x=0");
  box('R=="!<{{x:=0;++x:=1;}^@}*>(!x=0)");
  loop("x=0", 'R=="[{{x:=0;++x:=1;}^@}*]x=0"); <(
    "Init":
      id,
    "Step":
      dualb('R=="[{x:=0;++x:=1;}^@]x=0");
      diamond('R=="![x:=0;++x:=1;](!x=0)");
      choiced('R=="<x:=0;++x:=1;>x=0");
      orR('R=="<x:=0;>x=0|<x:=1;>x=0");
      assignd('R=="<x:=0;>x=0");
      hideR('R=="<x:=1;>x=0");
      QE,
    "Post":
      id
  )
End.

End.

ArchiveEntry "16: Push-around Cart"
Description "Proposition 16.1: Push-around carts are safe".

ProgramVariables /* program variables may change their value over time */
  Real x;        /* position of cart */
  Real v;        /* velocity of cart */
  Real a;        /* Angel's acceleration pushing/pulling the cart */
  Real d;        /* Demon's acceleration pushing/pulling the cart */
End.

Problem
  x>=0 & v>=0 ->
  [{
    {d:=1;++d:=-1;}^@
    {a:=1;++a:=-1;}
    {x'=v,v'=a+d}
  }* @invariant(x>=0&v>=0)
  ] x>=0
End.

Tactic "16: Push-around Cart: Proof: positional"
  implyR(1) ; loop("x>=0&v>=0", 1) ; <(
    "Init": prop, 
    "Step": composeb(1) ; dualb(1) ; diamond(1) ; composeb(1.1) ; choiced(1) ; orR(1) ; assignd(1) ; assignd(2) ; choiceb(1) ; andR(1) ; <(
      assignb(1) ; solve(1) ; hideR(2) ; QE, 
        assignb(1) ; solve(1) ; hideR(2) ; QE
      ), 
    "Post": prop
  )
End.

Tactic "16: Push-around Cart: Proof: named"
  implyR('R=="x>=0&v>=0->[{{d:=1;++d:=(-1);}^@{a:=1;++a:=(-1);}{x'=v,v'=a+d}}*]x>=0");
  loop("x>=0&v>=0", 'R=="[{{d:=1;++d:=(-1);}^@{a:=1;++a:=(-1);}{x'=v,v'=a+d}}*]x>=0"); <(
    "Init":
      propClose,
    "Step":
      composeb('R=="[{d:=1;++d:=(-1);}^@{a:=1;++a:=(-1);}{x'=v,v'=a+d}](x>=0&v>=0)");
      dualb('R=="[{d:=1;++d:=(-1);}^@][{a:=1;++a:=(-1);}{x'=v,v'=a+d}](x>=0&v>=0)");
      diamond('R=="![d:=1;++d:=(-1);](![{a:=1;++a:=(-1);}{x'=v,v'=a+d}](x>=0&v>=0))");
      composeb('R=="<d:=1;++d:=(-1);>#[{a:=1;++a:=(-1);}{x'=v,v'=a+d}](x>=0&v>=0)#");
      choiced('R=="<d:=1;++d:=(-1);>[a:=1;++a:=(-1);][{x'=v,v'=a+d}](x>=0&v>=0)");
      orR('R=="<d:=1;>[a:=1;++a:=(-1);][{x'=v,v'=a+d}](x>=0&v>=0)|<d:=(-1);>[a:=1;++a:=(-1);][{x'=v,v'=a+d}](x>=0&v>=0)");
      assignd('R=="<d:=1;>[a:=1;++a:=(-1);][{x'=v,v'=a+d}](x>=0&v>=0)");
      assignd('R=="<d:=(-1);>[a:=1;++a:=(-1);][{x'=v,v'=a+d}](x>=0&v>=0)");
      choiceb('R=="[a:=1;++a:=(-1);][{x'=v,v'=a+1}](x>=0&v>=0)");
      andR('R=="[a:=1;][{x'=v,v'=a+1}](x>=0&v>=0)&[a:=(-1);][{x'=v,v'=a+1}](x>=0&v>=0)"); <(
        "[a:=1;][{x'=v,v'=a+1}](x>=0&v>=0)":
          assignb('R=="[a:=1;][{x'=v,v'=a+1}](x>=0&v>=0)");
          solve('R=="[{x'=v,v'=1+1}](x>=0&v>=0)");
          hideR('R=="[a:=1;++a:=(-1);][{x'=v,v'=a+(-1)}](x>=0&v>=0)");
          QE,
        "[a:=(-1);][{x'=v,v'=a+1}](x>=0&v>=0)":
          assignb('R=="[a:=(-1);][{x'=v,v'=a+1}](x>=0&v>=0)");
          solve('R=="[{x'=v,v'=(-1)+1}](x>=0&v>=0)");
          hideR('R=="[a:=1;++a:=(-1);][{x'=v,v'=a+(-1)}](x>=0&v>=0)");
          QE
      ),
    "Post":
      propClose
  )
End.

Illustration "https://lfcps.org/info/fig-push-around-cart.png".
End.

ArchiveEntry "16: Goalie in Robot Soccer"
Description "Proof for Example 14.6".

ProgramVariables
  Real x, y;     /* x/y-coordinate of ball */
  Real v, w;     /* ball's velocity in x/y-direction */
  Real g;        /* y-coordinate of goalie lateral in goal */
  Real u;        /* velocity of goalie */
End.

Problem
  (x/v)^2*(u-w)^2<=1 & x<0&v>0&y=g ->
  <{w:=w; ++ w:=-w;}^@;
   {{u:=u; ++ u:=-u;}; {x'=v,y'=w,g'=u}}> x^2+(y-g)^2<=1
End.

Tactic "16: Goalie in Robot Soccer: Proof: positional"
  implyR(1) ; composed(1) ; composed(1.1) ; duald(1) ; box(1) ; choiceb(1) ; andR(1) ; <(
  assignb(1) ; choiced(1) ; orR(1) ; hideR(2) ; assignd(1) ; solve(1) ; QE("Mathematica"),
  assignb(1) ; choiced(1) ; orR(1) ; hideR(1) ; assignd(1) ; solve(1) ; QE("Mathematica")
  )
End.

Tactic "16: Goalie in Robot Soccer: Proof: named"
  implyR('R=="(x/v)^2*(u-w)^2<=1&x < 0&v>0&y=g-><{w:=w;++w:=-w;}^@{u:=u;++u:=-u;}{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1");
  composed('R=="<{w:=w;++w:=-w;}^@{u:=u;++u:=-u;}{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1");
  composed('R=="<{w:=w;++w:=-w;}^@>#<{u:=u;++u:=-u;}{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1#");
  duald('R=="<{w:=w;++w:=-w;}^@><u:=u;++u:=-u;><{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1");
  box('R=="!<w:=w;++w:=-w;>(!<u:=u;++u:=-u;><{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1)");
  choiceb('R=="[w:=w;++w:=-w;]<u:=u;++u:=-u;><{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1");
  andR('R=="[w:=w;]<u:=u;++u:=-u;><{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1&[w:=-w;]<u:=u;++u:=-u;><{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1"); <(
    "[w:=w;]<u:=u;++u:=-u;><{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1":
      assignb('R=="[w:=w;]<u:=u;++u:=-u;><{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1");
      choiced('R=="<u:=u;++u:=-u;><{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1");
      orR('R=="<u:=u;><{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1|<u:=-u;><{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1");
      hideR('R=="<u:=-u;><{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1");
      assignd('R=="<u:=u;><{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1");
      solve('R=="<{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1");
      QE,
    "[w:=-w;]<u:=u;++u:=-u;><{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1":
      assignb('R=="[w:=-w;]<u:=u;++u:=-u;><{x'=v,y'=w,g'=u}>x^2+(y-g)^2<=1");
      choiced('R=="<u:=u;++u:=-u;><{x'=v,y'=-w,g'=u}>x^2+(y-g)^2<=1");
      orR('R=="<u:=u;><{x'=v,y'=-w,g'=u}>x^2+(y-g)^2<=1|<u:=-u;><{x'=v,y'=-w,g'=u}>x^2+(y-g)^2<=1");
      hideR('R=="<u:=u;><{x'=v,y'=-w,g'=u}>x^2+(y-g)^2<=1");
      assignd('R=="<u:=-u;><{x'=v,y'=-w,g'=u}>x^2+(y-g)^2<=1");
      solve('R=="<{x'=v,y'=-w,g'=-u}>x^2+(y-g)^2<=1");
      QE
  )
End.

Illustration "https://lfcps.org/info/fig-goalie.png".
End.
